{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module find-and-replace/utils\n */\nimport { uid, Collection } from 'ckeditor5/src/utils';\nimport { escapeRegExp } from 'lodash-es';\n/**\n * Executes findCallback and updates search results list.\n *\n * @param {module:engine/model/range~Range} range The model range to scan for matches.\n * @param {module:engine/model/model~Model} model The model.\n * @param {Function} findCallback The callback that should return `true` if provided text matches the search term.\n * @param {module:utils/collection~Collection} [startResults] An optional collection of find matches that the function should\n * start with. This would be a collection returned by a previous `updateFindResultFromRange()` call.\n * @returns {module:utils/collection~Collection} A collection of objects describing find match.\n *\n * An example structure:\n *\n * ```js\n * {\n *\tid: resultId,\n *\tlabel: foundItem.label,\n *\tmarker\n *\t}\n * ```\n */\n\nexport function updateFindResultFromRange(range, model, findCallback, startResults) {\n  const results = startResults || new Collection();\n  model.change(writer => {\n    [...range].forEach(_ref => {\n      let {\n        type,\n        item\n      } = _ref;\n\n      if (type === 'elementStart') {\n        if (model.schema.checkChild(item, '$text')) {\n          const foundItems = findCallback({\n            item,\n            text: rangeToText(model.createRangeIn(item))\n          });\n\n          if (!foundItems) {\n            return;\n          }\n\n          foundItems.forEach(foundItem => {\n            const resultId = `findResult:${uid()}`;\n            const marker = writer.addMarker(resultId, {\n              usingOperation: false,\n              affectsData: false,\n              range: writer.createRange(writer.createPositionAt(item, foundItem.start), writer.createPositionAt(item, foundItem.end))\n            });\n            const index = findInsertIndex(results, marker);\n            results.add({\n              id: resultId,\n              label: foundItem.label,\n              marker\n            }, index);\n          });\n        }\n      }\n    });\n  });\n  return results;\n}\n/**\n * Returns text representation of a range. The returned text length should be the same as range length.\n * In order to achieve this this function will replace inline elements (text-line) as new line character (\"\\n\").\n *\n * @param {module:engine/model/range~Range} range The model range.\n * @returns {String} The text content of the provided range.\n */\n\nexport function rangeToText(range) {\n  return Array.from(range.getItems()).reduce((rangeText, node) => {\n    // Trim text to a last occurrence of an inline element and update range start.\n    if (!(node.is('text') || node.is('textProxy'))) {\n      // Editor has only one inline element defined in schema: `<softBreak>` which is treated as new line character in blocks.\n      // Special handling might be needed for other inline elements (inline widgets).\n      return `${rangeText}\\n`;\n    }\n\n    return rangeText + node.data;\n  }, '');\n} // Finds the appropriate index in the resultsList Collection.\n\nfunction findInsertIndex(resultsList, markerToInsert) {\n  const result = resultsList.find(_ref2 => {\n    let {\n      marker\n    } = _ref2;\n    return markerToInsert.getStart().isBefore(marker.getStart());\n  });\n  return result ? resultsList.getIndex(result) : resultsList.length;\n} // Maps RegExp match result to find result.\n\n\nfunction regexpMatchToFindResult(matchResult) {\n  const lastGroupIndex = matchResult.length - 1;\n  let startOffset = matchResult.index; // Searches with match all flag have an extra matching group with empty string or white space matched before the word.\n  // If the search term starts with the space already, there is no extra group even with match all flag on.\n\n  if (matchResult.length === 3) {\n    startOffset += matchResult[1].length;\n  }\n\n  return {\n    label: matchResult[lastGroupIndex],\n    start: startOffset,\n    end: startOffset + matchResult[lastGroupIndex].length\n  };\n}\n/**\n * Creates a text matching callback for a specified search term and matching options.\n *\n * @param {String} searchTerm The search term.\n * @param {Object} [options] Matching options.\n * @param {Boolean} [options.matchCase=false] If set to `true` letter casing will be ignored.\n * @param {Boolean} [options.wholeWords=false] If set to `true` only whole words that match `callbackOrText` will be matched.\n * @returns {Function}\n */\n\n\nexport function findByTextCallback(searchTerm, options) {\n  let flags = 'gu';\n\n  if (!options.matchCase) {\n    flags += 'i';\n  }\n\n  let regExpQuery = `(${escapeRegExp(searchTerm)})`;\n\n  if (options.wholeWords) {\n    const nonLetterGroup = '[^a-zA-Z\\u00C0-\\u024F\\u1E00-\\u1EFF]';\n\n    if (!new RegExp('^' + nonLetterGroup).test(searchTerm)) {\n      regExpQuery = `(^|${nonLetterGroup}|_)${regExpQuery}`;\n    }\n\n    if (!new RegExp(nonLetterGroup + '$').test(searchTerm)) {\n      regExpQuery = `${regExpQuery}(?=_|${nonLetterGroup}|$)`;\n    }\n  }\n\n  const regExp = new RegExp(regExpQuery, flags);\n\n  function findCallback(_ref3) {\n    let {\n      text\n    } = _ref3;\n    const matches = [...text.matchAll(regExp)];\n    return matches.map(regexpMatchToFindResult);\n  }\n\n  return findCallback;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-find-and-replace/src/utils.js"],"names":["uid","Collection","escapeRegExp","updateFindResultFromRange","range","model","findCallback","startResults","results","change","writer","forEach","type","item","schema","checkChild","foundItems","text","rangeToText","createRangeIn","foundItem","resultId","marker","addMarker","usingOperation","affectsData","createRange","createPositionAt","start","end","index","findInsertIndex","add","id","label","Array","from","getItems","reduce","rangeText","node","is","data","resultsList","markerToInsert","result","find","getStart","isBefore","getIndex","length","regexpMatchToFindResult","matchResult","lastGroupIndex","startOffset","findByTextCallback","searchTerm","options","flags","matchCase","regExpQuery","wholeWords","nonLetterGroup","RegExp","test","regExp","matches","matchAll","map"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module find-and-replace/utils\n */\n\nimport { uid, Collection } from 'ckeditor5/src/utils';\nimport { escapeRegExp } from 'lodash-es';\n\n/**\n * Executes findCallback and updates search results list.\n *\n * @param {module:engine/model/range~Range} range The model range to scan for matches.\n * @param {module:engine/model/model~Model} model The model.\n * @param {Function} findCallback The callback that should return `true` if provided text matches the search term.\n * @param {module:utils/collection~Collection} [startResults] An optional collection of find matches that the function should\n * start with. This would be a collection returned by a previous `updateFindResultFromRange()` call.\n * @returns {module:utils/collection~Collection} A collection of objects describing find match.\n *\n * An example structure:\n *\n * ```js\n * {\n *\tid: resultId,\n *\tlabel: foundItem.label,\n *\tmarker\n *\t}\n * ```\n */\nexport function updateFindResultFromRange( range, model, findCallback, startResults ) {\n\tconst results = startResults || new Collection();\n\n\tmodel.change( writer => {\n\t\t[ ...range ].forEach( ( { type, item } ) => {\n\t\t\tif ( type === 'elementStart' ) {\n\t\t\t\tif ( model.schema.checkChild( item, '$text' ) ) {\n\t\t\t\t\tconst foundItems = findCallback( {\n\t\t\t\t\t\titem,\n\t\t\t\t\t\ttext: rangeToText( model.createRangeIn( item ) )\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( !foundItems ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tfoundItems.forEach( foundItem => {\n\t\t\t\t\t\tconst resultId = `findResult:${ uid() }`;\n\t\t\t\t\t\tconst marker = writer.addMarker( resultId, {\n\t\t\t\t\t\t\tusingOperation: false,\n\t\t\t\t\t\t\taffectsData: false,\n\t\t\t\t\t\t\trange: writer.createRange(\n\t\t\t\t\t\t\t\twriter.createPositionAt( item, foundItem.start ),\n\t\t\t\t\t\t\t\twriter.createPositionAt( item, foundItem.end )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tconst index = findInsertIndex( results, marker );\n\n\t\t\t\t\t\tresults.add(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid: resultId,\n\t\t\t\t\t\t\t\tlabel: foundItem.label,\n\t\t\t\t\t\t\t\tmarker\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tindex\n\t\t\t\t\t\t);\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n\n\treturn results;\n}\n\n/**\n * Returns text representation of a range. The returned text length should be the same as range length.\n * In order to achieve this this function will replace inline elements (text-line) as new line character (\"\\n\").\n *\n * @param {module:engine/model/range~Range} range The model range.\n * @returns {String} The text content of the provided range.\n */\nexport function rangeToText( range ) {\n\treturn Array.from( range.getItems() ).reduce( ( rangeText, node ) => {\n\t\t// Trim text to a last occurrence of an inline element and update range start.\n\t\tif ( !( node.is( 'text' ) || node.is( 'textProxy' ) ) ) {\n\t\t\t// Editor has only one inline element defined in schema: `<softBreak>` which is treated as new line character in blocks.\n\t\t\t// Special handling might be needed for other inline elements (inline widgets).\n\t\t\treturn `${ rangeText }\\n`;\n\t\t}\n\n\t\treturn rangeText + node.data;\n\t}, '' );\n}\n\n// Finds the appropriate index in the resultsList Collection.\nfunction findInsertIndex( resultsList, markerToInsert ) {\n\tconst result = resultsList.find( ( { marker } ) => {\n\t\treturn markerToInsert.getStart().isBefore( marker.getStart() );\n\t} );\n\n\treturn result ? resultsList.getIndex( result ) : resultsList.length;\n}\n\n// Maps RegExp match result to find result.\nfunction regexpMatchToFindResult( matchResult ) {\n\tconst lastGroupIndex = matchResult.length - 1;\n\n\tlet startOffset = matchResult.index;\n\n\t// Searches with match all flag have an extra matching group with empty string or white space matched before the word.\n\t// If the search term starts with the space already, there is no extra group even with match all flag on.\n\tif ( matchResult.length === 3 ) {\n\t\tstartOffset += matchResult[ 1 ].length;\n\t}\n\n\treturn {\n\t\tlabel: matchResult[ lastGroupIndex ],\n\t\tstart: startOffset,\n\t\tend: startOffset + matchResult[ lastGroupIndex ].length\n\t};\n}\n\n/**\n * Creates a text matching callback for a specified search term and matching options.\n *\n * @param {String} searchTerm The search term.\n * @param {Object} [options] Matching options.\n * @param {Boolean} [options.matchCase=false] If set to `true` letter casing will be ignored.\n * @param {Boolean} [options.wholeWords=false] If set to `true` only whole words that match `callbackOrText` will be matched.\n * @returns {Function}\n */\nexport function findByTextCallback( searchTerm, options ) {\n\tlet flags = 'gu';\n\n\tif ( !options.matchCase ) {\n\t\tflags += 'i';\n\t}\n\n\tlet regExpQuery = `(${ escapeRegExp( searchTerm ) })`;\n\n\tif ( options.wholeWords ) {\n\t\tconst nonLetterGroup = '[^a-zA-Z\\u00C0-\\u024F\\u1E00-\\u1EFF]';\n\n\t\tif ( !new RegExp( '^' + nonLetterGroup ).test( searchTerm ) ) {\n\t\t\tregExpQuery = `(^|${ nonLetterGroup }|_)${ regExpQuery }`;\n\t\t}\n\n\t\tif ( !new RegExp( nonLetterGroup + '$' ).test( searchTerm ) ) {\n\t\t\tregExpQuery = `${ regExpQuery }(?=_|${ nonLetterGroup }|$)`;\n\t\t}\n\t}\n\n\tconst regExp = new RegExp( regExpQuery, flags );\n\n\tfunction findCallback( { text } ) {\n\t\tconst matches = [ ...text.matchAll( regExp ) ];\n\n\t\treturn matches.map( regexpMatchToFindResult );\n\t}\n\n\treturn findCallback;\n}\n"]},"metadata":{},"sourceType":"module"}
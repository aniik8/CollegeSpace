{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module code-block/utils\n */\nimport { first } from 'ckeditor5/src/utils';\n/**\n * Returns code block languages as defined in `config.codeBlock.languages` but processed:\n *\n * * To consider the editor localization, i.e. to display {@link module:code-block/codeblock~CodeBlockLanguageDefinition}\n * in the correct language. There is no way to use {@link module:utils/locale~Locale#t} when the user\n * configuration is defined because the editor does not exist yet.\n * * To make sure each definition has a CSS class associated with it even if not specified\n * in the original configuration.\n *\n * @param {module:core/editor/editor~Editor} editor\n * @returns {Array.<module:code-block/codeblock~CodeBlockLanguageDefinition>}.\n */\n\nexport function getNormalizedAndLocalizedLanguageDefinitions(editor) {\n  const t = editor.t;\n  const languageDefs = editor.config.get('codeBlock.languages');\n\n  for (const def of languageDefs) {\n    if (def.label === 'Plain text') {\n      def.label = t('Plain text');\n    }\n\n    if (def.class === undefined) {\n      def.class = `language-${def.language}`;\n    }\n  }\n\n  return languageDefs;\n}\n/**\n * Returns an object associating certain language definition properties with others. For instance:\n *\n * For:\n *\n *\t\tconst definitions = {\n *\t\t\t{ language: 'php', class: 'language-php', label: 'PHP' },\n *\t\t\t{ language: 'javascript', class: 'js', label: 'JavaScript' },\n *\t\t};\n *\n *\t\tgetPropertyAssociation( definitions, 'class', 'language' );\n *\n * returns:\n *\n *\t\t{\n *\t\t\t'language-php': 'php'\n *\t\t\t'js': 'javascript'\n *\t\t}\n *\n * and\n *\n *\t\tgetPropertyAssociation( definitions, 'language', 'label' );\n *\n * returns:\n *\n *\t\t{\n *\t\t\t'php': 'PHP'\n *\t\t\t'javascript': 'JavaScript'\n *\t\t}\n *\n * @param {Array.<module:code-block/codeblock~CodeBlockLanguageDefinition>}\n * @param {String} key\n * @param {String} value\n * @param {Object.<String,String>}\n */\n\nexport function getPropertyAssociation(languageDefs, key, value) {\n  const association = {};\n\n  for (const def of languageDefs) {\n    if (key === 'class') {\n      // Only the first class is considered.\n      association[def[key].split(' ').shift()] = def[value];\n    } else {\n      association[def[key]] = def[value];\n    }\n  }\n\n  return association;\n}\n/**\n * For a given model text node, it returns white spaces that precede other characters in that node.\n * This corresponds to the indentation part of the code block line.\n *\n * @param {module:engine/model/text~Text} codeLineNodes\n * @returns {String}\n */\n\nexport function getLeadingWhiteSpaces(textNode) {\n  return textNode.data.match(/^(\\s*)/)[0];\n}\n/**\n * For plain text containing the code (a snippet), it returns a document fragment containing\n * view text nodes separated by `<br>` elements (in place of new line characters \"\\n\"), for instance:\n *\n * Input:\n *\n *\t\t\"foo()\\n\n *\t\tbar()\"\n *\n * Output:\n *\n *\t\t<DocumentFragment>\n *\t\t\t\"foo()\"\n *\t\t\t<br/>\n *\t\t\t\"bar()\"\n *\t\t</DocumentFragment>\n *\n * @param {module:engine/view/upcastwriter~UpcastWriter} writer\n * @param {String} text The raw code text to be converted.\n * @returns {module:engine/view/documentfragment~DocumentFragment}\n */\n\nexport function rawSnippetTextToViewDocumentFragment(writer, text) {\n  const fragment = writer.createDocumentFragment();\n  const textLines = text.split('\\n');\n  const nodes = textLines.reduce((nodes, line, lineIndex) => {\n    nodes.push(line);\n\n    if (lineIndex < textLines.length - 1) {\n      nodes.push(writer.createElement('br'));\n    }\n\n    return nodes;\n  }, []);\n  writer.appendChild(nodes, fragment);\n  return fragment;\n}\n/**\n * Returns an array of all model positions within the selection that represent code block lines.\n *\n * If the selection is collapsed, it returns the exact selection anchor position:\n *\n *\t\t<codeBlock>[]foo</codeBlock>        ->     <codeBlock>^foo</codeBlock>\n *\t\t<codeBlock>foo[]bar</codeBlock>     ->     <codeBlock>foo^bar</codeBlock>\n *\n * Otherwise, it returns positions **before** each text node belonging to all code blocks contained by the selection:\n *\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    foo[bar                                   ^foobar\n *\t\t    <softBreak></softBreak>         ->        <softBreak></softBreak>\n *\t\t    baz]qux                                   ^bazqux\n *\t\t</codeBlock>                               </codeBlock>\n *\n * It also works across other non–code blocks:\n *\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    foo[bar                                   ^foobar\n *\t\t</codeBlock>                               </codeBlock>\n *\t\t<paragraph>text</paragraph>         ->     <paragraph>text</paragraph>\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    baz]qux                                   ^bazqux\n *\t\t</codeBlock>                               </codeBlock>\n *\n * **Note:** The positions are in reverse order so they do not get outdated when iterating over them and\n * the writer inserts or removes elements at the same time.\n *\n * **Note:** The position is located after the leading white spaces in the text node.\n *\n * @param {module:engine/model/model~Model} model\n * @returns {Array.<module:engine/model/position~Position>}\n */\n\nexport function getIndentOutdentPositions(model) {\n  const selection = model.document.selection;\n  const positions = []; // When the selection is collapsed, there's only one position we can indent or outdent.\n\n  if (selection.isCollapsed) {\n    positions.push(selection.anchor);\n  } // When the selection is NOT collapsed, collect all positions starting before text nodes\n  // (code lines) in any <codeBlock> within the selection.\n  else {\n    // Walk backward so positions we are about to collect here do not get outdated when\n    // inserting or deleting using the writer.\n    const walker = selection.getFirstRange().getWalker({\n      ignoreElementEnd: true,\n      direction: 'backward'\n    });\n\n    for (const {\n      item\n    } of walker) {\n      if (item.is('$textProxy') && item.parent.is('element', 'codeBlock')) {\n        const leadingWhiteSpaces = getLeadingWhiteSpaces(item.textNode);\n        const {\n          parent,\n          startOffset\n        } = item.textNode; // Make sure the position is after all leading whitespaces in the text node.\n\n        const position = model.createPositionAt(parent, startOffset + leadingWhiteSpaces.length);\n        positions.push(position);\n      }\n    }\n  }\n\n  return positions;\n}\n/**\n * Checks if any of the blocks within the model selection is a code block.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Boolean}\n */\n\nexport function isModelSelectionInCodeBlock(selection) {\n  const firstBlock = first(selection.getSelectedBlocks());\n  return firstBlock && firstBlock.is('element', 'codeBlock');\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-code-block/src/utils.js"],"names":["first","getNormalizedAndLocalizedLanguageDefinitions","editor","t","languageDefs","config","get","def","label","class","undefined","language","getPropertyAssociation","key","value","association","split","shift","getLeadingWhiteSpaces","textNode","data","match","rawSnippetTextToViewDocumentFragment","writer","text","fragment","createDocumentFragment","textLines","nodes","reduce","line","lineIndex","push","length","createElement","appendChild","getIndentOutdentPositions","model","selection","document","positions","isCollapsed","anchor","walker","getFirstRange","getWalker","ignoreElementEnd","direction","item","is","parent","leadingWhiteSpaces","startOffset","position","createPositionAt","isModelSelectionInCodeBlock","firstBlock","getSelectedBlocks"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module code-block/utils\n */\n\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * Returns code block languages as defined in `config.codeBlock.languages` but processed:\n *\n * * To consider the editor localization, i.e. to display {@link module:code-block/codeblock~CodeBlockLanguageDefinition}\n * in the correct language. There is no way to use {@link module:utils/locale~Locale#t} when the user\n * configuration is defined because the editor does not exist yet.\n * * To make sure each definition has a CSS class associated with it even if not specified\n * in the original configuration.\n *\n * @param {module:core/editor/editor~Editor} editor\n * @returns {Array.<module:code-block/codeblock~CodeBlockLanguageDefinition>}.\n */\nexport function getNormalizedAndLocalizedLanguageDefinitions( editor ) {\n\tconst t = editor.t;\n\tconst languageDefs = editor.config.get( 'codeBlock.languages' );\n\n\tfor ( const def of languageDefs ) {\n\t\tif ( def.label === 'Plain text' ) {\n\t\t\tdef.label = t( 'Plain text' );\n\t\t}\n\n\t\tif ( def.class === undefined ) {\n\t\t\tdef.class = `language-${ def.language }`;\n\t\t}\n\t}\n\n\treturn languageDefs;\n}\n\n/**\n * Returns an object associating certain language definition properties with others. For instance:\n *\n * For:\n *\n *\t\tconst definitions = {\n *\t\t\t{ language: 'php', class: 'language-php', label: 'PHP' },\n *\t\t\t{ language: 'javascript', class: 'js', label: 'JavaScript' },\n *\t\t};\n *\n *\t\tgetPropertyAssociation( definitions, 'class', 'language' );\n *\n * returns:\n *\n *\t\t{\n *\t\t\t'language-php': 'php'\n *\t\t\t'js': 'javascript'\n *\t\t}\n *\n * and\n *\n *\t\tgetPropertyAssociation( definitions, 'language', 'label' );\n *\n * returns:\n *\n *\t\t{\n *\t\t\t'php': 'PHP'\n *\t\t\t'javascript': 'JavaScript'\n *\t\t}\n *\n * @param {Array.<module:code-block/codeblock~CodeBlockLanguageDefinition>}\n * @param {String} key\n * @param {String} value\n * @param {Object.<String,String>}\n */\nexport function getPropertyAssociation( languageDefs, key, value ) {\n\tconst association = {};\n\n\tfor ( const def of languageDefs ) {\n\t\tif ( key === 'class' ) {\n\t\t\t// Only the first class is considered.\n\t\t\tassociation[ def[ key ].split( ' ' ).shift() ] = def[ value ];\n\t\t} else {\n\t\t\tassociation[ def[ key ] ] = def[ value ];\n\t\t}\n\t}\n\n\treturn association;\n}\n\n/**\n * For a given model text node, it returns white spaces that precede other characters in that node.\n * This corresponds to the indentation part of the code block line.\n *\n * @param {module:engine/model/text~Text} codeLineNodes\n * @returns {String}\n */\nexport function getLeadingWhiteSpaces( textNode ) {\n\treturn textNode.data.match( /^(\\s*)/ )[ 0 ];\n}\n\n/**\n * For plain text containing the code (a snippet), it returns a document fragment containing\n * view text nodes separated by `<br>` elements (in place of new line characters \"\\n\"), for instance:\n *\n * Input:\n *\n *\t\t\"foo()\\n\n *\t\tbar()\"\n *\n * Output:\n *\n *\t\t<DocumentFragment>\n *\t\t\t\"foo()\"\n *\t\t\t<br/>\n *\t\t\t\"bar()\"\n *\t\t</DocumentFragment>\n *\n * @param {module:engine/view/upcastwriter~UpcastWriter} writer\n * @param {String} text The raw code text to be converted.\n * @returns {module:engine/view/documentfragment~DocumentFragment}\n */\nexport function rawSnippetTextToViewDocumentFragment( writer, text ) {\n\tconst fragment = writer.createDocumentFragment();\n\tconst textLines = text.split( '\\n' );\n\n\tconst nodes = textLines.reduce( ( nodes, line, lineIndex ) => {\n\t\tnodes.push( line );\n\n\t\tif ( lineIndex < textLines.length - 1 ) {\n\t\t\tnodes.push( writer.createElement( 'br' ) );\n\t\t}\n\n\t\treturn nodes;\n\t}, [] );\n\n\twriter.appendChild( nodes, fragment );\n\n\treturn fragment;\n}\n\n/**\n * Returns an array of all model positions within the selection that represent code block lines.\n *\n * If the selection is collapsed, it returns the exact selection anchor position:\n *\n *\t\t<codeBlock>[]foo</codeBlock>        ->     <codeBlock>^foo</codeBlock>\n *\t\t<codeBlock>foo[]bar</codeBlock>     ->     <codeBlock>foo^bar</codeBlock>\n *\n * Otherwise, it returns positions **before** each text node belonging to all code blocks contained by the selection:\n *\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    foo[bar                                   ^foobar\n *\t\t    <softBreak></softBreak>         ->        <softBreak></softBreak>\n *\t\t    baz]qux                                   ^bazqux\n *\t\t</codeBlock>                               </codeBlock>\n *\n * It also works across other non–code blocks:\n *\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    foo[bar                                   ^foobar\n *\t\t</codeBlock>                               </codeBlock>\n *\t\t<paragraph>text</paragraph>         ->     <paragraph>text</paragraph>\n *\t\t<codeBlock>                                <codeBlock>\n *\t\t    baz]qux                                   ^bazqux\n *\t\t</codeBlock>                               </codeBlock>\n *\n * **Note:** The positions are in reverse order so they do not get outdated when iterating over them and\n * the writer inserts or removes elements at the same time.\n *\n * **Note:** The position is located after the leading white spaces in the text node.\n *\n * @param {module:engine/model/model~Model} model\n * @returns {Array.<module:engine/model/position~Position>}\n */\nexport function getIndentOutdentPositions( model ) {\n\tconst selection = model.document.selection;\n\tconst positions = [];\n\n\t// When the selection is collapsed, there's only one position we can indent or outdent.\n\tif ( selection.isCollapsed ) {\n\t\tpositions.push( selection.anchor );\n\t}\n\n\t// When the selection is NOT collapsed, collect all positions starting before text nodes\n\t// (code lines) in any <codeBlock> within the selection.\n\telse {\n\t\t// Walk backward so positions we are about to collect here do not get outdated when\n\t\t// inserting or deleting using the writer.\n\t\tconst walker = selection.getFirstRange().getWalker( {\n\t\t\tignoreElementEnd: true,\n\t\t\tdirection: 'backward'\n\t\t} );\n\n\t\tfor ( const { item } of walker ) {\n\t\t\tif ( item.is( '$textProxy' ) && item.parent.is( 'element', 'codeBlock' ) ) {\n\t\t\t\tconst leadingWhiteSpaces = getLeadingWhiteSpaces( item.textNode );\n\t\t\t\tconst { parent, startOffset } = item.textNode;\n\n\t\t\t\t// Make sure the position is after all leading whitespaces in the text node.\n\t\t\t\tconst position = model.createPositionAt( parent, startOffset + leadingWhiteSpaces.length );\n\n\t\t\t\tpositions.push( position );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn positions;\n}\n\n/**\n * Checks if any of the blocks within the model selection is a code block.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Boolean}\n */\nexport function isModelSelectionInCodeBlock( selection ) {\n\tconst firstBlock = first( selection.getSelectedBlocks() );\n\n\treturn firstBlock && firstBlock.is( 'element', 'codeBlock' );\n}\n"]},"metadata":{},"sourceType":"module"}
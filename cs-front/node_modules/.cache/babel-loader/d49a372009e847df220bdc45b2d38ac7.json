{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/utils/selection\n */\nimport TableWalker from '../tablewalker';\n/**\n * Returns all model table cells that are fully selected (from the outside)\n * within the provided model selection's ranges.\n *\n * To obtain the cells selected from the inside, use\n * {@link module:table/utils/selection~getTableCellsContainingSelection}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\nexport function getSelectedTableCells(selection) {\n  const cells = [];\n\n  for (const range of sortRanges(selection.getRanges())) {\n    const element = range.getContainedElement();\n\n    if (element && element.is('element', 'tableCell')) {\n      cells.push(element);\n    }\n  }\n\n  return cells;\n}\n/**\n * Returns all model table cells that the provided model selection's ranges\n * {@link module:engine/model/range~Range#start} inside.\n *\n * To obtain the cells selected from the outside, use\n * {@link module:table/utils/selection~getSelectedTableCells}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\nexport function getTableCellsContainingSelection(selection) {\n  const cells = [];\n\n  for (const range of selection.getRanges()) {\n    const cellWithSelection = range.start.findAncestor('tableCell');\n\n    if (cellWithSelection) {\n      cells.push(cellWithSelection);\n    }\n  }\n\n  return cells;\n}\n/**\n * Returns all model table cells that are either completely selected\n * by selection ranges or host selection range\n * {@link module:engine/model/range~Range#start start positions} inside them.\n *\n * Combines {@link module:table/utils/selection~getTableCellsContainingSelection} and\n * {@link module:table/utils/selection~getSelectedTableCells}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\nexport function getSelectionAffectedTableCells(selection) {\n  const selectedCells = getSelectedTableCells(selection);\n\n  if (selectedCells.length) {\n    return selectedCells;\n  }\n\n  return getTableCellsContainingSelection(selection);\n}\n/**\n * Returns an object with the `first` and `last` row index contained in the given `tableCells`.\n *\n *\t\tconst selectedTableCells = getSelectedTableCells( editor.model.document.selection );\n *\n *\t\tconst { first, last } = getRowIndexes( selectedTableCells );\n *\n *\t\tconsole.log( `Selected rows: ${ first } to ${ last }` );\n *\n * @param {Array.<module:engine/model/element~Element>} tableCells\n * @returns {Object} Returns an object with the `first` and `last` table row indexes.\n */\n\nexport function getRowIndexes(tableCells) {\n  const indexes = tableCells.map(cell => cell.parent.index);\n  return getFirstLastIndexesObject(indexes);\n}\n/**\n * Returns an object with the `first` and `last` column index contained in the given `tableCells`.\n *\n *\t\tconst selectedTableCells = getSelectedTableCells( editor.model.document.selection );\n *\n *\t\tconst { first, last } = getColumnIndexes( selectedTableCells );\n *\n *\t\tconsole.log( `Selected columns: ${ first } to ${ last }` );\n *\n * @param {Array.<module:engine/model/element~Element>} tableCells\n * @returns {Object} Returns an object with the `first` and `last` table column indexes.\n */\n\nexport function getColumnIndexes(tableCells) {\n  const table = tableCells[0].findAncestor('table');\n  const tableMap = [...new TableWalker(table)];\n  const indexes = tableMap.filter(entry => tableCells.includes(entry.cell)).map(entry => entry.column);\n  return getFirstLastIndexesObject(indexes);\n}\n/**\n * Checks if the selection contains cells that do not exceed rectangular selection.\n *\n * In a table below:\n *\n *\t\t┌───┬───┬───┬───┐\n *\t\t│ a │ b │ c │ d │\n *\t\t├───┴───┼───┤   │\n *\t\t│ e     │ f │   │\n *\t\t│       ├───┼───┤\n *\t\t│       │ g │ h │\n *\t\t└───────┴───┴───┘\n *\n * Valid selections are these which create a solid rectangle (without gaps), such as:\n *   - a, b (two horizontal cells)\n *   - c, f (two vertical cells)\n *   - a, b, e (cell \"e\" spans over four cells)\n *   - c, d, f (cell d spans over a cell in the row below)\n *\n * While an invalid selection would be:\n *   - a, c (the unselected cell \"b\" creates a gap)\n *   - f, g, h (cell \"d\" spans over a cell from the row of \"f\" cell - thus creates a gap)\n *\n * @param {Array.<module:engine/model/element~Element>} selectedTableCells\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean}\n */\n\nexport function isSelectionRectangular(selectedTableCells, tableUtils) {\n  if (selectedTableCells.length < 2 || !areCellInTheSameTableSection(selectedTableCells)) {\n    return false;\n  } // A valid selection is a fully occupied rectangle composed of table cells.\n  // Below we will calculate the area of a selected table cells and the area of valid selection.\n  // The area of a valid selection is defined by top-left and bottom-right cells.\n\n\n  const rows = new Set();\n  const columns = new Set();\n  let areaOfSelectedCells = 0;\n\n  for (const tableCell of selectedTableCells) {\n    const {\n      row,\n      column\n    } = tableUtils.getCellLocation(tableCell);\n    const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n    const colspan = parseInt(tableCell.getAttribute('colspan') || 1); // Record row & column indexes of current cell.\n\n    rows.add(row);\n    columns.add(column); // For cells that spans over multiple rows add also the last row that this cell spans over.\n\n    if (rowspan > 1) {\n      rows.add(row + rowspan - 1);\n    } // For cells that spans over multiple columns add also the last column that this cell spans over.\n\n\n    if (colspan > 1) {\n      columns.add(column + colspan - 1);\n    }\n\n    areaOfSelectedCells += rowspan * colspan;\n  } // We can only merge table cells that are in adjacent rows...\n\n\n  const areaOfValidSelection = getBiggestRectangleArea(rows, columns);\n  return areaOfValidSelection == areaOfSelectedCells;\n}\n/**\n * Returns array of sorted ranges.\n *\n * @param {Iterable.<module:engine/model/range~Range>} ranges\n * @return {Array.<module:engine/model/range~Range>}\n */\n\nexport function sortRanges(ranges) {\n  return Array.from(ranges).sort(compareRangeOrder);\n} // Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.\n\nfunction getFirstLastIndexesObject(indexes) {\n  const allIndexesSorted = indexes.sort((indexA, indexB) => indexA - indexB);\n  const first = allIndexesSorted[0];\n  const last = allIndexesSorted[allIndexesSorted.length - 1];\n  return {\n    first,\n    last\n  };\n}\n\nfunction compareRangeOrder(rangeA, rangeB) {\n  // Since table cell ranges are disjoint, it's enough to check their start positions.\n  const posA = rangeA.start;\n  const posB = rangeB.start; // Checking for equal position (returning 0) is not needed because this would be either:\n  // a. Intersecting range (not allowed by model)\n  // b. Collapsed range on the same position (allowed by model but should not happen).\n\n  return posA.isBefore(posB) ? -1 : 1;\n} // Calculates the area of a maximum rectangle that can span over the provided row & column indexes.\n//\n// @param {Array.<Number>} rows\n// @param {Array.<Number>} columns\n// @returns {Number}\n\n\nfunction getBiggestRectangleArea(rows, columns) {\n  const rowsIndexes = Array.from(rows.values());\n  const columnIndexes = Array.from(columns.values());\n  const lastRow = Math.max(...rowsIndexes);\n  const firstRow = Math.min(...rowsIndexes);\n  const lastColumn = Math.max(...columnIndexes);\n  const firstColumn = Math.min(...columnIndexes);\n  return (lastRow - firstRow + 1) * (lastColumn - firstColumn + 1);\n} // Checks if the selection does not mix a header (column or row) with other cells.\n//\n// For instance, in the table below valid selections consist of cells with the same letter only.\n// So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.\n//\n//\t\t header columns\n//\t\t  ↓   ↓\n//\t\t┌───┬───┬───┬───┐\n//\t\t│ a │ a │ b │ b │  ← header row\n//\t\t├───┼───┼───┼───┤\n//\t\t│ c │ c │ d │ d │\n//\t\t├───┼───┼───┼───┤\n//\t\t│ c │ c │ d │ d │\n//\t\t└───┴───┴───┴───┘\n\n\nfunction areCellInTheSameTableSection(tableCells) {\n  const table = tableCells[0].findAncestor('table');\n  const rowIndexes = getRowIndexes(tableCells);\n  const headingRows = parseInt(table.getAttribute('headingRows') || 0); // Calculating row indexes is a bit cheaper so if this check fails we can't merge.\n\n  if (!areIndexesInSameSection(rowIndexes, headingRows)) {\n    return false;\n  }\n\n  const headingColumns = parseInt(table.getAttribute('headingColumns') || 0);\n  const columnIndexes = getColumnIndexes(tableCells); // Similarly cells must be in same column section.\n\n  return areIndexesInSameSection(columnIndexes, headingColumns);\n} // Unified check if table rows/columns indexes are in the same heading/body section.\n\n\nfunction areIndexesInSameSection(_ref, headingSectionSize) {\n  let {\n    first,\n    last\n  } = _ref;\n  const firstCellIsInHeading = first < headingSectionSize;\n  const lastCellIsInHeading = last < headingSectionSize;\n  return firstCellIsInHeading === lastCellIsInHeading;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/utils/selection.js"],"names":["TableWalker","getSelectedTableCells","selection","cells","range","sortRanges","getRanges","element","getContainedElement","is","push","getTableCellsContainingSelection","cellWithSelection","start","findAncestor","getSelectionAffectedTableCells","selectedCells","length","getRowIndexes","tableCells","indexes","map","cell","parent","index","getFirstLastIndexesObject","getColumnIndexes","table","tableMap","filter","entry","includes","column","isSelectionRectangular","selectedTableCells","tableUtils","areCellInTheSameTableSection","rows","Set","columns","areaOfSelectedCells","tableCell","row","getCellLocation","rowspan","parseInt","getAttribute","colspan","add","areaOfValidSelection","getBiggestRectangleArea","ranges","Array","from","sort","compareRangeOrder","allIndexesSorted","indexA","indexB","first","last","rangeA","rangeB","posA","posB","isBefore","rowsIndexes","values","columnIndexes","lastRow","Math","max","firstRow","min","lastColumn","firstColumn","rowIndexes","headingRows","areIndexesInSameSection","headingColumns","headingSectionSize","firstCellIsInHeading","lastCellIsInHeading"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/utils/selection\n */\n\nimport TableWalker from '../tablewalker';\n\n/**\n * Returns all model table cells that are fully selected (from the outside)\n * within the provided model selection's ranges.\n *\n * To obtain the cells selected from the inside, use\n * {@link module:table/utils/selection~getTableCellsContainingSelection}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\nexport function getSelectedTableCells( selection ) {\n\tconst cells = [];\n\n\tfor ( const range of sortRanges( selection.getRanges() ) ) {\n\t\tconst element = range.getContainedElement();\n\n\t\tif ( element && element.is( 'element', 'tableCell' ) ) {\n\t\t\tcells.push( element );\n\t\t}\n\t}\n\n\treturn cells;\n}\n\n/**\n * Returns all model table cells that the provided model selection's ranges\n * {@link module:engine/model/range~Range#start} inside.\n *\n * To obtain the cells selected from the outside, use\n * {@link module:table/utils/selection~getSelectedTableCells}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\nexport function getTableCellsContainingSelection( selection ) {\n\tconst cells = [];\n\n\tfor ( const range of selection.getRanges() ) {\n\t\tconst cellWithSelection = range.start.findAncestor( 'tableCell' );\n\n\t\tif ( cellWithSelection ) {\n\t\t\tcells.push( cellWithSelection );\n\t\t}\n\t}\n\n\treturn cells;\n}\n\n/**\n * Returns all model table cells that are either completely selected\n * by selection ranges or host selection range\n * {@link module:engine/model/range~Range#start start positions} inside them.\n *\n * Combines {@link module:table/utils/selection~getTableCellsContainingSelection} and\n * {@link module:table/utils/selection~getSelectedTableCells}.\n *\n * @param {module:engine/model/selection~Selection} selection\n * @returns {Array.<module:engine/model/element~Element>}\n */\nexport function getSelectionAffectedTableCells( selection ) {\n\tconst selectedCells = getSelectedTableCells( selection );\n\n\tif ( selectedCells.length ) {\n\t\treturn selectedCells;\n\t}\n\n\treturn getTableCellsContainingSelection( selection );\n}\n\n/**\n * Returns an object with the `first` and `last` row index contained in the given `tableCells`.\n *\n *\t\tconst selectedTableCells = getSelectedTableCells( editor.model.document.selection );\n *\n *\t\tconst { first, last } = getRowIndexes( selectedTableCells );\n *\n *\t\tconsole.log( `Selected rows: ${ first } to ${ last }` );\n *\n * @param {Array.<module:engine/model/element~Element>} tableCells\n * @returns {Object} Returns an object with the `first` and `last` table row indexes.\n */\nexport function getRowIndexes( tableCells ) {\n\tconst indexes = tableCells.map( cell => cell.parent.index );\n\n\treturn getFirstLastIndexesObject( indexes );\n}\n\n/**\n * Returns an object with the `first` and `last` column index contained in the given `tableCells`.\n *\n *\t\tconst selectedTableCells = getSelectedTableCells( editor.model.document.selection );\n *\n *\t\tconst { first, last } = getColumnIndexes( selectedTableCells );\n *\n *\t\tconsole.log( `Selected columns: ${ first } to ${ last }` );\n *\n * @param {Array.<module:engine/model/element~Element>} tableCells\n * @returns {Object} Returns an object with the `first` and `last` table column indexes.\n */\nexport function getColumnIndexes( tableCells ) {\n\tconst table = tableCells[ 0 ].findAncestor( 'table' );\n\tconst tableMap = [ ...new TableWalker( table ) ];\n\n\tconst indexes = tableMap\n\t\t.filter( entry => tableCells.includes( entry.cell ) )\n\t\t.map( entry => entry.column );\n\n\treturn getFirstLastIndexesObject( indexes );\n}\n\n/**\n * Checks if the selection contains cells that do not exceed rectangular selection.\n *\n * In a table below:\n *\n *\t\t┌───┬───┬───┬───┐\n *\t\t│ a │ b │ c │ d │\n *\t\t├───┴───┼───┤   │\n *\t\t│ e     │ f │   │\n *\t\t│       ├───┼───┤\n *\t\t│       │ g │ h │\n *\t\t└───────┴───┴───┘\n *\n * Valid selections are these which create a solid rectangle (without gaps), such as:\n *   - a, b (two horizontal cells)\n *   - c, f (two vertical cells)\n *   - a, b, e (cell \"e\" spans over four cells)\n *   - c, d, f (cell d spans over a cell in the row below)\n *\n * While an invalid selection would be:\n *   - a, c (the unselected cell \"b\" creates a gap)\n *   - f, g, h (cell \"d\" spans over a cell from the row of \"f\" cell - thus creates a gap)\n *\n * @param {Array.<module:engine/model/element~Element>} selectedTableCells\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean}\n */\nexport function isSelectionRectangular( selectedTableCells, tableUtils ) {\n\tif ( selectedTableCells.length < 2 || !areCellInTheSameTableSection( selectedTableCells ) ) {\n\t\treturn false;\n\t}\n\n\t// A valid selection is a fully occupied rectangle composed of table cells.\n\t// Below we will calculate the area of a selected table cells and the area of valid selection.\n\t// The area of a valid selection is defined by top-left and bottom-right cells.\n\tconst rows = new Set();\n\tconst columns = new Set();\n\n\tlet areaOfSelectedCells = 0;\n\n\tfor ( const tableCell of selectedTableCells ) {\n\t\tconst { row, column } = tableUtils.getCellLocation( tableCell );\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\t// Record row & column indexes of current cell.\n\t\trows.add( row );\n\t\tcolumns.add( column );\n\n\t\t// For cells that spans over multiple rows add also the last row that this cell spans over.\n\t\tif ( rowspan > 1 ) {\n\t\t\trows.add( row + rowspan - 1 );\n\t\t}\n\n\t\t// For cells that spans over multiple columns add also the last column that this cell spans over.\n\t\tif ( colspan > 1 ) {\n\t\t\tcolumns.add( column + colspan - 1 );\n\t\t}\n\n\t\tareaOfSelectedCells += ( rowspan * colspan );\n\t}\n\n\t// We can only merge table cells that are in adjacent rows...\n\tconst areaOfValidSelection = getBiggestRectangleArea( rows, columns );\n\n\treturn areaOfValidSelection == areaOfSelectedCells;\n}\n\n/**\n * Returns array of sorted ranges.\n *\n * @param {Iterable.<module:engine/model/range~Range>} ranges\n * @return {Array.<module:engine/model/range~Range>}\n */\nexport function sortRanges( ranges ) {\n\treturn Array.from( ranges ).sort( compareRangeOrder );\n}\n\n// Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.\nfunction getFirstLastIndexesObject( indexes ) {\n\tconst allIndexesSorted = indexes.sort( ( indexA, indexB ) => indexA - indexB );\n\n\tconst first = allIndexesSorted[ 0 ];\n\tconst last = allIndexesSorted[ allIndexesSorted.length - 1 ];\n\n\treturn { first, last };\n}\n\nfunction compareRangeOrder( rangeA, rangeB ) {\n\t// Since table cell ranges are disjoint, it's enough to check their start positions.\n\tconst posA = rangeA.start;\n\tconst posB = rangeB.start;\n\n\t// Checking for equal position (returning 0) is not needed because this would be either:\n\t// a. Intersecting range (not allowed by model)\n\t// b. Collapsed range on the same position (allowed by model but should not happen).\n\treturn posA.isBefore( posB ) ? -1 : 1;\n}\n\n// Calculates the area of a maximum rectangle that can span over the provided row & column indexes.\n//\n// @param {Array.<Number>} rows\n// @param {Array.<Number>} columns\n// @returns {Number}\nfunction getBiggestRectangleArea( rows, columns ) {\n\tconst rowsIndexes = Array.from( rows.values() );\n\tconst columnIndexes = Array.from( columns.values() );\n\n\tconst lastRow = Math.max( ...rowsIndexes );\n\tconst firstRow = Math.min( ...rowsIndexes );\n\tconst lastColumn = Math.max( ...columnIndexes );\n\tconst firstColumn = Math.min( ...columnIndexes );\n\n\treturn ( lastRow - firstRow + 1 ) * ( lastColumn - firstColumn + 1 );\n}\n\n// Checks if the selection does not mix a header (column or row) with other cells.\n//\n// For instance, in the table below valid selections consist of cells with the same letter only.\n// So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.\n//\n//\t\t header columns\n//\t\t  ↓   ↓\n//\t\t┌───┬───┬───┬───┐\n//\t\t│ a │ a │ b │ b │  ← header row\n//\t\t├───┼───┼───┼───┤\n//\t\t│ c │ c │ d │ d │\n//\t\t├───┼───┼───┼───┤\n//\t\t│ c │ c │ d │ d │\n//\t\t└───┴───┴───┴───┘\nfunction areCellInTheSameTableSection( tableCells ) {\n\tconst table = tableCells[ 0 ].findAncestor( 'table' );\n\n\tconst rowIndexes = getRowIndexes( tableCells );\n\tconst headingRows = parseInt( table.getAttribute( 'headingRows' ) || 0 );\n\n\t// Calculating row indexes is a bit cheaper so if this check fails we can't merge.\n\tif ( !areIndexesInSameSection( rowIndexes, headingRows ) ) {\n\t\treturn false;\n\t}\n\n\tconst headingColumns = parseInt( table.getAttribute( 'headingColumns' ) || 0 );\n\tconst columnIndexes = getColumnIndexes( tableCells );\n\n\t// Similarly cells must be in same column section.\n\treturn areIndexesInSameSection( columnIndexes, headingColumns );\n}\n\n// Unified check if table rows/columns indexes are in the same heading/body section.\nfunction areIndexesInSameSection( { first, last }, headingSectionSize ) {\n\tconst firstCellIsInHeading = first < headingSectionSize;\n\tconst lastCellIsInHeading = last < headingSectionSize;\n\n\treturn firstCellIsInHeading === lastCellIsInHeading;\n}\n"]},"metadata":{},"sourceType":"module"}
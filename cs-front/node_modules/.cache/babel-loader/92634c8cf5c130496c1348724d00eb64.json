{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablemouse\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport TableSelection from './tableselection';\nimport MouseEventsObserver from './tablemouse/mouseeventsobserver';\nimport { getTableCellsContainingSelection } from './utils/selection';\n/**\n * This plugin enables a table cells' selection with the mouse.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableMouse extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableMouse';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [TableSelection];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor; // Currently the MouseObserver only handles `mousedown` and `mouseup` events.\n    // TODO move to the engine?\n\n    editor.editing.view.addObserver(MouseEventsObserver);\n\n    this._enableShiftClickSelection();\n\n    this._enableMouseDragSelection();\n  }\n  /**\n   * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held\n   * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.\n   *\n   * @private\n   */\n\n\n  _enableShiftClickSelection() {\n    const editor = this.editor;\n    let blockSelectionChange = false;\n    const tableSelection = editor.plugins.get(TableSelection);\n    this.listenTo(editor.editing.view.document, 'mousedown', (evt, domEventData) => {\n      if (!this.isEnabled || !tableSelection.isEnabled) {\n        return;\n      }\n\n      if (!domEventData.domEvent.shiftKey) {\n        return;\n      }\n\n      const anchorCell = tableSelection.getAnchorCell() || getTableCellsContainingSelection(editor.model.document.selection)[0];\n\n      if (!anchorCell) {\n        return;\n      }\n\n      const targetCell = this._getModelTableCellFromDomEvent(domEventData);\n\n      if (targetCell && haveSameTableParent(anchorCell, targetCell)) {\n        blockSelectionChange = true;\n        tableSelection.setCellSelection(anchorCell, targetCell);\n        domEventData.preventDefault();\n      }\n    });\n    this.listenTo(editor.editing.view.document, 'mouseup', () => {\n      blockSelectionChange = false;\n    }); // We need to ignore a `selectionChange` event that is fired after we render our new table cells selection.\n    // When downcasting table cells selection to the view, we put the view selection in the last selected cell\n    // in a place that may not be natively a \"correct\" location. This is â€“ we put it directly in the `<td>` element.\n    // All browsers fire the native `selectionchange` event.\n    // However, all browsers except Safari return the selection in the exact place where we put it\n    // (even though it's visually normalized). Safari returns `<td><p>^foo` that makes our selection observer\n    // fire our `selectionChange` event (because the view selection that we set in the first step differs from the DOM selection).\n    // Since `selectionChange` is fired, we automatically update the model selection that moves it that paragraph.\n    // This breaks our dear cells selection.\n    //\n    // Theoretically this issue concerns only Safari that is the only browser that do normalize the selection.\n    // However, to avoid code branching and to have a good coverage for this event blocker, I enabled it for all browsers.\n    //\n    // Note: I'm keeping the `blockSelectionChange` state separately for shift+click and mouse drag (exact same logic)\n    // so I don't have to try to analyze whether they don't overlap in some weird cases. Probably they don't.\n    // But I have other things to do, like writing this comment.\n\n    this.listenTo(editor.editing.view.document, 'selectionChange', evt => {\n      if (blockSelectionChange) {\n        // @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );\n        evt.stop();\n      }\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Enables making cells selection by dragging.\n   *\n   * The selection is made only on mousemove. Mouse tracking is started on mousedown.\n   * However, the cells selection is enabled only after the mouse cursor left the anchor cell.\n   * Thanks to that normal text selection within one cell works just fine. However, you can still select\n   * just one cell by leaving the anchor cell and moving back to it.\n   *\n   * @private\n   */\n\n\n  _enableMouseDragSelection() {\n    const editor = this.editor;\n    let anchorCell, targetCell;\n    let beganCellSelection = false;\n    let blockSelectionChange = false;\n    const tableSelection = editor.plugins.get(TableSelection);\n    this.listenTo(editor.editing.view.document, 'mousedown', (evt, domEventData) => {\n      if (!this.isEnabled || !tableSelection.isEnabled) {\n        return;\n      } // Make sure to not conflict with the shift+click listener and any other possible handler.\n\n\n      if (domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey) {\n        return;\n      }\n\n      anchorCell = this._getModelTableCellFromDomEvent(domEventData);\n    });\n    this.listenTo(editor.editing.view.document, 'mousemove', (evt, domEventData) => {\n      if (!domEventData.domEvent.buttons) {\n        return;\n      }\n\n      if (!anchorCell) {\n        return;\n      }\n\n      const newTargetCell = this._getModelTableCellFromDomEvent(domEventData);\n\n      if (newTargetCell && haveSameTableParent(anchorCell, newTargetCell)) {\n        targetCell = newTargetCell; // Switch to the cell selection mode after the mouse cursor left the anchor cell.\n        // Switch off only on mouseup (makes selecting a single cell possible).\n\n        if (!beganCellSelection && targetCell != anchorCell) {\n          beganCellSelection = true;\n        }\n      } // Yep, not making a cell selection yet. See method docs.\n\n\n      if (!beganCellSelection) {\n        return;\n      }\n\n      blockSelectionChange = true;\n      tableSelection.setCellSelection(anchorCell, targetCell);\n      domEventData.preventDefault();\n    });\n    this.listenTo(editor.editing.view.document, 'mouseup', () => {\n      beganCellSelection = false;\n      blockSelectionChange = false;\n      anchorCell = null;\n      targetCell = null;\n    }); // See the explanation in `_enableShiftClickSelection()`.\n\n    this.listenTo(editor.editing.view.document, 'selectionChange', evt => {\n      if (blockSelectionChange) {\n        // @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );\n        evt.stop();\n      }\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Returns the model table cell element based on the target element of the passed DOM event.\n   *\n   * @private\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   * @returns {module:engine/model/element~Element|undefined} Returns the table cell or `undefined`.\n   */\n\n\n  _getModelTableCellFromDomEvent(domEventData) {\n    // Note: Work with positions (not element mapping) because the target element can be an attribute or other non-mapped element.\n    const viewTargetElement = domEventData.target;\n    const viewPosition = this.editor.editing.view.createPositionAt(viewTargetElement, 0);\n    const modelPosition = this.editor.editing.mapper.toModelPosition(viewPosition);\n    const modelElement = modelPosition.parent;\n    return modelElement.findAncestor('tableCell', {\n      includeSelf: true\n    });\n  }\n\n}\n\nfunction haveSameTableParent(cellA, cellB) {\n  return cellA.parent.parent == cellB.parent.parent;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tablemouse.js"],"names":["Plugin","TableSelection","MouseEventsObserver","getTableCellsContainingSelection","TableMouse","pluginName","requires","init","editor","editing","view","addObserver","_enableShiftClickSelection","_enableMouseDragSelection","blockSelectionChange","tableSelection","plugins","get","listenTo","document","evt","domEventData","isEnabled","domEvent","shiftKey","anchorCell","getAnchorCell","model","selection","targetCell","_getModelTableCellFromDomEvent","haveSameTableParent","setCellSelection","preventDefault","stop","priority","beganCellSelection","ctrlKey","altKey","buttons","newTargetCell","viewTargetElement","target","viewPosition","createPositionAt","modelPosition","mapper","toModelPosition","modelElement","parent","findAncestor","includeSelf","cellA","cellB"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablemouse\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\n\nimport TableSelection from './tableselection';\nimport MouseEventsObserver from './tablemouse/mouseeventsobserver';\n\nimport { getTableCellsContainingSelection } from './utils/selection';\n\n/**\n * This plugin enables a table cells' selection with the mouse.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableMouse extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableMouse';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ TableSelection ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\n\t\t// Currently the MouseObserver only handles `mousedown` and `mouseup` events.\n\t\t// TODO move to the engine?\n\t\teditor.editing.view.addObserver( MouseEventsObserver );\n\n\t\tthis._enableShiftClickSelection();\n\t\tthis._enableMouseDragSelection();\n\t}\n\n\t/**\n\t * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held\n\t * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.\n\t *\n\t * @private\n\t */\n\t_enableShiftClickSelection() {\n\t\tconst editor = this.editor;\n\t\tlet blockSelectionChange = false;\n\n\t\tconst tableSelection = editor.plugins.get( TableSelection );\n\n\t\tthis.listenTo( editor.editing.view.document, 'mousedown', ( evt, domEventData ) => {\n\t\t\tif ( !this.isEnabled || !tableSelection.isEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !domEventData.domEvent.shiftKey ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst anchorCell = tableSelection.getAnchorCell() || getTableCellsContainingSelection( editor.model.document.selection )[ 0 ];\n\n\t\t\tif ( !anchorCell ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst targetCell = this._getModelTableCellFromDomEvent( domEventData );\n\n\t\t\tif ( targetCell && haveSameTableParent( anchorCell, targetCell ) ) {\n\t\t\t\tblockSelectionChange = true;\n\t\t\t\ttableSelection.setCellSelection( anchorCell, targetCell );\n\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t}\n\t\t} );\n\n\t\tthis.listenTo( editor.editing.view.document, 'mouseup', () => {\n\t\t\tblockSelectionChange = false;\n\t\t} );\n\n\t\t// We need to ignore a `selectionChange` event that is fired after we render our new table cells selection.\n\t\t// When downcasting table cells selection to the view, we put the view selection in the last selected cell\n\t\t// in a place that may not be natively a \"correct\" location. This is â€“ we put it directly in the `<td>` element.\n\t\t// All browsers fire the native `selectionchange` event.\n\t\t// However, all browsers except Safari return the selection in the exact place where we put it\n\t\t// (even though it's visually normalized). Safari returns `<td><p>^foo` that makes our selection observer\n\t\t// fire our `selectionChange` event (because the view selection that we set in the first step differs from the DOM selection).\n\t\t// Since `selectionChange` is fired, we automatically update the model selection that moves it that paragraph.\n\t\t// This breaks our dear cells selection.\n\t\t//\n\t\t// Theoretically this issue concerns only Safari that is the only browser that do normalize the selection.\n\t\t// However, to avoid code branching and to have a good coverage for this event blocker, I enabled it for all browsers.\n\t\t//\n\t\t// Note: I'm keeping the `blockSelectionChange` state separately for shift+click and mouse drag (exact same logic)\n\t\t// so I don't have to try to analyze whether they don't overlap in some weird cases. Probably they don't.\n\t\t// But I have other things to do, like writing this comment.\n\t\tthis.listenTo( editor.editing.view.document, 'selectionChange', evt => {\n\t\t\tif ( blockSelectionChange ) {\n\t\t\t\t// @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );\n\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Enables making cells selection by dragging.\n\t *\n\t * The selection is made only on mousemove. Mouse tracking is started on mousedown.\n\t * However, the cells selection is enabled only after the mouse cursor left the anchor cell.\n\t * Thanks to that normal text selection within one cell works just fine. However, you can still select\n\t * just one cell by leaving the anchor cell and moving back to it.\n\t *\n\t * @private\n\t */\n\t_enableMouseDragSelection() {\n\t\tconst editor = this.editor;\n\t\tlet anchorCell, targetCell;\n\t\tlet beganCellSelection = false;\n\t\tlet blockSelectionChange = false;\n\n\t\tconst tableSelection = editor.plugins.get( TableSelection );\n\n\t\tthis.listenTo( editor.editing.view.document, 'mousedown', ( evt, domEventData ) => {\n\t\t\tif ( !this.isEnabled || !tableSelection.isEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure to not conflict with the shift+click listener and any other possible handler.\n\t\t\tif ( domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tanchorCell = this._getModelTableCellFromDomEvent( domEventData );\n\t\t} );\n\n\t\tthis.listenTo( editor.editing.view.document, 'mousemove', ( evt, domEventData ) => {\n\t\t\tif ( !domEventData.domEvent.buttons ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !anchorCell ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newTargetCell = this._getModelTableCellFromDomEvent( domEventData );\n\n\t\t\tif ( newTargetCell && haveSameTableParent( anchorCell, newTargetCell ) ) {\n\t\t\t\ttargetCell = newTargetCell;\n\n\t\t\t\t// Switch to the cell selection mode after the mouse cursor left the anchor cell.\n\t\t\t\t// Switch off only on mouseup (makes selecting a single cell possible).\n\t\t\t\tif ( !beganCellSelection && targetCell != anchorCell ) {\n\t\t\t\t\tbeganCellSelection = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Yep, not making a cell selection yet. See method docs.\n\t\t\tif ( !beganCellSelection ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tblockSelectionChange = true;\n\t\t\ttableSelection.setCellSelection( anchorCell, targetCell );\n\n\t\t\tdomEventData.preventDefault();\n\t\t} );\n\n\t\tthis.listenTo( editor.editing.view.document, 'mouseup', () => {\n\t\t\tbeganCellSelection = false;\n\t\t\tblockSelectionChange = false;\n\t\t\tanchorCell = null;\n\t\t\ttargetCell = null;\n\t\t} );\n\n\t\t// See the explanation in `_enableShiftClickSelection()`.\n\t\tthis.listenTo( editor.editing.view.document, 'selectionChange', evt => {\n\t\t\tif ( blockSelectionChange ) {\n\t\t\t\t// @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );\n\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Returns the model table cell element based on the target element of the passed DOM event.\n\t *\n\t * @private\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t * @returns {module:engine/model/element~Element|undefined} Returns the table cell or `undefined`.\n\t */\n\t_getModelTableCellFromDomEvent( domEventData ) {\n\t\t// Note: Work with positions (not element mapping) because the target element can be an attribute or other non-mapped element.\n\t\tconst viewTargetElement = domEventData.target;\n\t\tconst viewPosition = this.editor.editing.view.createPositionAt( viewTargetElement, 0 );\n\t\tconst modelPosition = this.editor.editing.mapper.toModelPosition( viewPosition );\n\t\tconst modelElement = modelPosition.parent;\n\n\t\treturn modelElement.findAncestor( 'tableCell', { includeSelf: true } );\n\t}\n}\n\nfunction haveSameTableParent( cellA, cellB ) {\n\treturn cellA.parent.parent == cellB.parent.parent;\n}\n"]},"metadata":{},"sourceType":"module"}
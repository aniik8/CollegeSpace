{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableselection\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\nimport TableWalker from './tablewalker';\nimport TableUtils from './tableutils';\nimport { cropTableToDimensions, adjustLastRowIndex, adjustLastColumnIndex } from './utils/structure';\nimport { getColumnIndexes, getRowIndexes, getSelectedTableCells, isSelectionRectangular } from './utils/selection';\nimport '../theme/tableselection.css';\n/**\n * This plugin enables the advanced table cells, rows and columns selection.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableSelection extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableSelection';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [TableUtils];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const model = editor.model;\n    this.listenTo(model, 'deleteContent', (evt, args) => this._handleDeleteContent(evt, args), {\n      priority: 'high'\n    });\n\n    this._defineSelectionConverter();\n\n    this._enablePluginDisabling(); // sic!\n\n  }\n  /**\n   * Returns the currently selected table cells or `null` if it is not a table cells selection.\n   *\n   * @returns {Array.<module:engine/model/element~Element>|null}\n   */\n\n\n  getSelectedTableCells() {\n    const selection = this.editor.model.document.selection;\n    const selectedCells = getSelectedTableCells(selection);\n\n    if (selectedCells.length == 0) {\n      return null;\n    } // This should never happen, but let's know if it ever happens.\n    // @if CK_DEBUG //\t/* istanbul ignore next */\n    // @if CK_DEBUG //\tif ( selectedCells.length != selection.rangeCount ) {\n    // @if CK_DEBUG //\t\tconsole.warn( 'Mixed selection warning. The selection contains table cells and some other ranges.' );\n    // @if CK_DEBUG //\t}\n\n\n    return selectedCells;\n  }\n  /**\n   * Returns the selected table fragment as a document fragment.\n   *\n   * @returns {module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  getSelectionAsFragment() {\n    const selectedCells = this.getSelectedTableCells();\n\n    if (!selectedCells) {\n      return null;\n    }\n\n    return this.editor.model.change(writer => {\n      const documentFragment = writer.createDocumentFragment();\n      const tableUtils = this.editor.plugins.get('TableUtils');\n      const {\n        first: firstColumn,\n        last: lastColumn\n      } = getColumnIndexes(selectedCells);\n      const {\n        first: firstRow,\n        last: lastRow\n      } = getRowIndexes(selectedCells);\n      const sourceTable = selectedCells[0].findAncestor('table');\n      let adjustedLastRow = lastRow;\n      let adjustedLastColumn = lastColumn; // If the selection is rectangular there could be a case of all cells in the last row/column spanned over\n      // next row/column so the real lastRow/lastColumn should be updated.\n\n      if (isSelectionRectangular(selectedCells, tableUtils)) {\n        const dimensions = {\n          firstColumn,\n          lastColumn,\n          firstRow,\n          lastRow\n        };\n        adjustedLastRow = adjustLastRowIndex(sourceTable, dimensions);\n        adjustedLastColumn = adjustLastColumnIndex(sourceTable, dimensions);\n      }\n\n      const cropDimensions = {\n        startRow: firstRow,\n        startColumn: firstColumn,\n        endRow: adjustedLastRow,\n        endColumn: adjustedLastColumn\n      };\n      const table = cropTableToDimensions(sourceTable, cropDimensions, writer);\n      writer.insert(table, documentFragment, 0);\n      return documentFragment;\n    });\n  }\n  /**\n   * Sets the model selection based on given anchor and target cells (can be the same cell).\n   * Takes care of setting the backward flag.\n   *\n   *\t\tconst modelRoot = editor.model.document.getRoot();\n   *\t\tconst firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );\n   *\t\tconst lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );\n   *\n   *\t\tconst tableSelection = editor.plugins.get( 'TableSelection' );\n   *\t\ttableSelection.setCellSelection( firstCell, lastCell );\n   *\n   * @param {module:engine/model/element~Element} anchorCell\n   * @param {module:engine/model/element~Element} targetCell\n   */\n\n\n  setCellSelection(anchorCell, targetCell) {\n    const cellsToSelect = this._getCellsToSelect(anchorCell, targetCell);\n\n    this.editor.model.change(writer => {\n      writer.setSelection(cellsToSelect.cells.map(cell => writer.createRangeOn(cell)), {\n        backward: cellsToSelect.backward\n      });\n    });\n  }\n  /**\n   * Returns the focus cell from the current selection.\n   *\n   * @returns {module:engine/model/element~Element}\n   */\n\n\n  getFocusCell() {\n    const selection = this.editor.model.document.selection;\n    const focusCellRange = [...selection.getRanges()].pop();\n    const element = focusCellRange.getContainedElement();\n\n    if (element && element.is('element', 'tableCell')) {\n      return element;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the anchor cell from the current selection.\n   *\n   * @returns {module:engine/model/element~Element} anchorCell\n   */\n\n\n  getAnchorCell() {\n    const selection = this.editor.model.document.selection;\n    const anchorCellRange = first(selection.getRanges());\n    const element = anchorCellRange.getContainedElement();\n\n    if (element && element.is('element', 'tableCell')) {\n      return element;\n    }\n\n    return null;\n  }\n  /**\n   * Defines a selection converter which marks the selected cells with a specific class.\n   *\n   * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the\n   * selection is backward or not, the last cell will usually be close to the \"focus\" end of the selection\n   * (a selection has anchor and focus).\n   *\n   * The real DOM selection is then hidden with CSS.\n   *\n   * @private\n   */\n\n\n  _defineSelectionConverter() {\n    const editor = this.editor;\n    const highlighted = new Set();\n    editor.conversion.for('editingDowncast').add(dispatcher => dispatcher.on('selection', (evt, data, conversionApi) => {\n      const viewWriter = conversionApi.writer;\n      clearHighlightedTableCells(viewWriter);\n      const selectedCells = this.getSelectedTableCells();\n\n      if (!selectedCells) {\n        return;\n      }\n\n      for (const tableCell of selectedCells) {\n        const viewElement = conversionApi.mapper.toViewElement(tableCell);\n        viewWriter.addClass('ck-editor__editable_selected', viewElement);\n        highlighted.add(viewElement);\n      }\n\n      const lastViewCell = conversionApi.mapper.toViewElement(selectedCells[selectedCells.length - 1]);\n      viewWriter.setSelection(lastViewCell, 0);\n    }, {\n      priority: 'lowest'\n    }));\n\n    function clearHighlightedTableCells(writer) {\n      for (const previouslyHighlighted of highlighted) {\n        writer.removeClass('ck-editor__editable_selected', previouslyHighlighted);\n      }\n\n      highlighted.clear();\n    }\n  }\n  /**\n   * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,\n   * it collapses the multi-cell selection to a regular selection placed inside a table cell.\n   *\n   * This listener helps features that disable the table selection plugin bring the selection\n   * to a clear state they can work with (for instance, because they don't support multiple cell selection).\n   */\n\n\n  _enablePluginDisabling() {\n    const editor = this.editor;\n    this.on('change:isEnabled', () => {\n      if (!this.isEnabled) {\n        const selectedCells = this.getSelectedTableCells();\n\n        if (!selectedCells) {\n          return;\n        }\n\n        editor.model.change(writer => {\n          const position = writer.createPositionAt(selectedCells[0], 0);\n          const range = editor.model.schema.getNearestSelectionRange(position);\n          writer.setSelection(range);\n        });\n      }\n    });\n  }\n  /**\n   * Overrides the default `model.deleteContent()` behavior over a selected table fragment.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} event\n   * @param {Array.<*>} args Delete content method arguments.\n   */\n\n\n  _handleDeleteContent(event, args) {\n    const [selection, options] = args;\n    const model = this.editor.model;\n    const isBackward = !options || options.direction == 'backward';\n    const selectedTableCells = getSelectedTableCells(selection);\n\n    if (!selectedTableCells.length) {\n      return;\n    }\n\n    event.stop();\n    model.change(writer => {\n      const tableCellToSelect = selectedTableCells[isBackward ? selectedTableCells.length - 1 : 0];\n      model.change(writer => {\n        for (const tableCell of selectedTableCells) {\n          model.deleteContent(writer.createSelection(tableCell, 'in'));\n        }\n      });\n      const rangeToSelect = model.schema.getNearestSelectionRange(writer.createPositionAt(tableCellToSelect, 0)); // Note: we ignore the case where rangeToSelect may be null because deleteContent() will always (unless someone broke it)\n      // create an empty paragraph to accommodate the selection.\n\n      if (selection.is('documentSelection')) {\n        writer.setSelection(rangeToSelect);\n      } else {\n        selection.setTo(rangeToSelect);\n      }\n    });\n  }\n  /**\n   * Returns an array of table cells that should be selected based on the\n   * given anchor cell and target (focus) cell.\n   *\n   * The cells are returned in a reverse direction if the selection is backward.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} anchorCell\n   * @param {module:engine/model/element~Element} targetCell\n   * @returns {Array.<module:engine/model/element~Element>}\n   */\n\n\n  _getCellsToSelect(anchorCell, targetCell) {\n    const tableUtils = this.editor.plugins.get('TableUtils');\n    const startLocation = tableUtils.getCellLocation(anchorCell);\n    const endLocation = tableUtils.getCellLocation(targetCell);\n    const startRow = Math.min(startLocation.row, endLocation.row);\n    const endRow = Math.max(startLocation.row, endLocation.row);\n    const startColumn = Math.min(startLocation.column, endLocation.column);\n    const endColumn = Math.max(startLocation.column, endLocation.column); // 2-dimensional array of the selected cells to ease flipping the order of cells for backward selections.\n\n    const selectionMap = new Array(endRow - startRow + 1).fill(null).map(() => []);\n    const walkerOptions = {\n      startRow,\n      endRow,\n      startColumn,\n      endColumn\n    };\n\n    for (const {\n      row,\n      cell\n    } of new TableWalker(anchorCell.findAncestor('table'), walkerOptions)) {\n      selectionMap[row - startRow].push(cell);\n    }\n\n    const flipVertically = endLocation.row < startLocation.row;\n    const flipHorizontally = endLocation.column < startLocation.column;\n\n    if (flipVertically) {\n      selectionMap.reverse();\n    }\n\n    if (flipHorizontally) {\n      selectionMap.forEach(row => row.reverse());\n    }\n\n    return {\n      cells: selectionMap.flat(),\n      backward: flipVertically || flipHorizontally\n    };\n  }\n\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tableselection.js"],"names":["Plugin","first","TableWalker","TableUtils","cropTableToDimensions","adjustLastRowIndex","adjustLastColumnIndex","getColumnIndexes","getRowIndexes","getSelectedTableCells","isSelectionRectangular","TableSelection","pluginName","requires","init","editor","model","listenTo","evt","args","_handleDeleteContent","priority","_defineSelectionConverter","_enablePluginDisabling","selection","document","selectedCells","length","getSelectionAsFragment","change","writer","documentFragment","createDocumentFragment","tableUtils","plugins","get","firstColumn","last","lastColumn","firstRow","lastRow","sourceTable","findAncestor","adjustedLastRow","adjustedLastColumn","dimensions","cropDimensions","startRow","startColumn","endRow","endColumn","table","insert","setCellSelection","anchorCell","targetCell","cellsToSelect","_getCellsToSelect","setSelection","cells","map","cell","createRangeOn","backward","getFocusCell","focusCellRange","getRanges","pop","element","getContainedElement","is","getAnchorCell","anchorCellRange","highlighted","Set","conversion","for","add","dispatcher","on","data","conversionApi","viewWriter","clearHighlightedTableCells","tableCell","viewElement","mapper","toViewElement","addClass","lastViewCell","previouslyHighlighted","removeClass","clear","isEnabled","position","createPositionAt","range","schema","getNearestSelectionRange","event","options","isBackward","direction","selectedTableCells","stop","tableCellToSelect","deleteContent","createSelection","rangeToSelect","setTo","startLocation","getCellLocation","endLocation","Math","min","row","max","column","selectionMap","Array","fill","walkerOptions","push","flipVertically","flipHorizontally","reverse","forEach","flat"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableselection\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { first } from 'ckeditor5/src/utils';\n\nimport TableWalker from './tablewalker';\nimport TableUtils from './tableutils';\n\nimport { cropTableToDimensions, adjustLastRowIndex, adjustLastColumnIndex } from './utils/structure';\nimport { getColumnIndexes, getRowIndexes, getSelectedTableCells, isSelectionRectangular } from './utils/selection';\n\nimport '../theme/tableselection.css';\n\n/**\n * This plugin enables the advanced table cells, rows and columns selection.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableSelection extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableSelection';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ TableUtils ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\tthis.listenTo( model, 'deleteContent', ( evt, args ) => this._handleDeleteContent( evt, args ), { priority: 'high' } );\n\n\t\tthis._defineSelectionConverter();\n\t\tthis._enablePluginDisabling(); // sic!\n\t}\n\n\t/**\n\t * Returns the currently selected table cells or `null` if it is not a table cells selection.\n\t *\n\t * @returns {Array.<module:engine/model/element~Element>|null}\n\t */\n\tgetSelectedTableCells() {\n\t\tconst selection = this.editor.model.document.selection;\n\n\t\tconst selectedCells = getSelectedTableCells( selection );\n\n\t\tif ( selectedCells.length == 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// This should never happen, but let's know if it ever happens.\n\t\t// @if CK_DEBUG //\t/* istanbul ignore next */\n\t\t// @if CK_DEBUG //\tif ( selectedCells.length != selection.rangeCount ) {\n\t\t// @if CK_DEBUG //\t\tconsole.warn( 'Mixed selection warning. The selection contains table cells and some other ranges.' );\n\t\t// @if CK_DEBUG //\t}\n\n\t\treturn selectedCells;\n\t}\n\n\t/**\n\t * Returns the selected table fragment as a document fragment.\n\t *\n\t * @returns {module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetSelectionAsFragment() {\n\t\tconst selectedCells = this.getSelectedTableCells();\n\n\t\tif ( !selectedCells ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.editor.model.change( writer => {\n\t\t\tconst documentFragment = writer.createDocumentFragment();\n\t\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\n\t\t\tconst { first: firstColumn, last: lastColumn } = getColumnIndexes( selectedCells );\n\t\t\tconst { first: firstRow, last: lastRow } = getRowIndexes( selectedCells );\n\n\t\t\tconst sourceTable = selectedCells[ 0 ].findAncestor( 'table' );\n\n\t\t\tlet adjustedLastRow = lastRow;\n\t\t\tlet adjustedLastColumn = lastColumn;\n\n\t\t\t// If the selection is rectangular there could be a case of all cells in the last row/column spanned over\n\t\t\t// next row/column so the real lastRow/lastColumn should be updated.\n\t\t\tif ( isSelectionRectangular( selectedCells, tableUtils ) ) {\n\t\t\t\tconst dimensions = {\n\t\t\t\t\tfirstColumn,\n\t\t\t\t\tlastColumn,\n\t\t\t\t\tfirstRow,\n\t\t\t\t\tlastRow\n\t\t\t\t};\n\n\t\t\t\tadjustedLastRow = adjustLastRowIndex( sourceTable, dimensions );\n\t\t\t\tadjustedLastColumn = adjustLastColumnIndex( sourceTable, dimensions );\n\t\t\t}\n\n\t\t\tconst cropDimensions = {\n\t\t\t\tstartRow: firstRow,\n\t\t\t\tstartColumn: firstColumn,\n\t\t\t\tendRow: adjustedLastRow,\n\t\t\t\tendColumn: adjustedLastColumn\n\t\t\t};\n\n\t\t\tconst table = cropTableToDimensions( sourceTable, cropDimensions, writer );\n\n\t\t\twriter.insert( table, documentFragment, 0 );\n\n\t\t\treturn documentFragment;\n\t\t} );\n\t}\n\n\t/**\n\t * Sets the model selection based on given anchor and target cells (can be the same cell).\n\t * Takes care of setting the backward flag.\n\t *\n\t *\t\tconst modelRoot = editor.model.document.getRoot();\n\t *\t\tconst firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );\n\t *\t\tconst lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );\n\t *\n\t *\t\tconst tableSelection = editor.plugins.get( 'TableSelection' );\n\t *\t\ttableSelection.setCellSelection( firstCell, lastCell );\n\t *\n\t * @param {module:engine/model/element~Element} anchorCell\n\t * @param {module:engine/model/element~Element} targetCell\n\t */\n\tsetCellSelection( anchorCell, targetCell ) {\n\t\tconst cellsToSelect = this._getCellsToSelect( anchorCell, targetCell );\n\n\t\tthis.editor.model.change( writer => {\n\t\t\twriter.setSelection(\n\t\t\t\tcellsToSelect.cells.map( cell => writer.createRangeOn( cell ) ),\n\t\t\t\t{ backward: cellsToSelect.backward }\n\t\t\t);\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the focus cell from the current selection.\n\t *\n\t * @returns {module:engine/model/element~Element}\n\t */\n\tgetFocusCell() {\n\t\tconst selection = this.editor.model.document.selection;\n\t\tconst focusCellRange = [ ...selection.getRanges() ].pop();\n\t\tconst element = focusCellRange.getContainedElement();\n\n\t\tif ( element && element.is( 'element', 'tableCell' ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the anchor cell from the current selection.\n\t *\n\t * @returns {module:engine/model/element~Element} anchorCell\n\t */\n\tgetAnchorCell() {\n\t\tconst selection = this.editor.model.document.selection;\n\t\tconst anchorCellRange = first( selection.getRanges() );\n\t\tconst element = anchorCellRange.getContainedElement();\n\n\t\tif ( element && element.is( 'element', 'tableCell' ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Defines a selection converter which marks the selected cells with a specific class.\n\t *\n\t * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the\n\t * selection is backward or not, the last cell will usually be close to the \"focus\" end of the selection\n\t * (a selection has anchor and focus).\n\t *\n\t * The real DOM selection is then hidden with CSS.\n\t *\n\t * @private\n\t */\n\t_defineSelectionConverter() {\n\t\tconst editor = this.editor;\n\t\tconst highlighted = new Set();\n\n\t\teditor.conversion.for( 'editingDowncast' ).add( dispatcher => dispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst viewWriter = conversionApi.writer;\n\n\t\t\tclearHighlightedTableCells( viewWriter );\n\n\t\t\tconst selectedCells = this.getSelectedTableCells();\n\n\t\t\tif ( !selectedCells ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( const tableCell of selectedCells ) {\n\t\t\t\tconst viewElement = conversionApi.mapper.toViewElement( tableCell );\n\n\t\t\t\tviewWriter.addClass( 'ck-editor__editable_selected', viewElement );\n\t\t\t\thighlighted.add( viewElement );\n\t\t\t}\n\n\t\t\tconst lastViewCell = conversionApi.mapper.toViewElement( selectedCells[ selectedCells.length - 1 ] );\n\t\t\tviewWriter.setSelection( lastViewCell, 0 );\n\t\t}, { priority: 'lowest' } ) );\n\n\t\tfunction clearHighlightedTableCells( writer ) {\n\t\t\tfor ( const previouslyHighlighted of highlighted ) {\n\t\t\t\twriter.removeClass( 'ck-editor__editable_selected', previouslyHighlighted );\n\t\t\t}\n\n\t\t\thighlighted.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,\n\t * it collapses the multi-cell selection to a regular selection placed inside a table cell.\n\t *\n\t * This listener helps features that disable the table selection plugin bring the selection\n\t * to a clear state they can work with (for instance, because they don't support multiple cell selection).\n\t */\n\t_enablePluginDisabling() {\n\t\tconst editor = this.editor;\n\n\t\tthis.on( 'change:isEnabled', () => {\n\t\t\tif ( !this.isEnabled ) {\n\t\t\t\tconst selectedCells = this.getSelectedTableCells();\n\n\t\t\t\tif ( !selectedCells ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\tconst position = writer.createPositionAt( selectedCells[ 0 ], 0 );\n\t\t\t\t\tconst range = editor.model.schema.getNearestSelectionRange( position );\n\n\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Overrides the default `model.deleteContent()` behavior over a selected table fragment.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} event\n\t * @param {Array.<*>} args Delete content method arguments.\n\t */\n\t_handleDeleteContent( event, args ) {\n\t\tconst [ selection, options ] = args;\n\t\tconst model = this.editor.model;\n\t\tconst isBackward = !options || options.direction == 'backward';\n\t\tconst selectedTableCells = getSelectedTableCells( selection );\n\n\t\tif ( !selectedTableCells.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.stop();\n\n\t\tmodel.change( writer => {\n\t\t\tconst tableCellToSelect = selectedTableCells[ isBackward ? selectedTableCells.length - 1 : 0 ];\n\n\t\t\tmodel.change( writer => {\n\t\t\t\tfor ( const tableCell of selectedTableCells ) {\n\t\t\t\t\tmodel.deleteContent( writer.createSelection( tableCell, 'in' ) );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tconst rangeToSelect = model.schema.getNearestSelectionRange( writer.createPositionAt( tableCellToSelect, 0 ) );\n\n\t\t\t// Note: we ignore the case where rangeToSelect may be null because deleteContent() will always (unless someone broke it)\n\t\t\t// create an empty paragraph to accommodate the selection.\n\n\t\t\tif ( selection.is( 'documentSelection' ) ) {\n\t\t\t\twriter.setSelection( rangeToSelect );\n\t\t\t} else {\n\t\t\t\tselection.setTo( rangeToSelect );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns an array of table cells that should be selected based on the\n\t * given anchor cell and target (focus) cell.\n\t *\n\t * The cells are returned in a reverse direction if the selection is backward.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} anchorCell\n\t * @param {module:engine/model/element~Element} targetCell\n\t * @returns {Array.<module:engine/model/element~Element>}\n\t */\n\t_getCellsToSelect( anchorCell, targetCell ) {\n\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\t\tconst startLocation = tableUtils.getCellLocation( anchorCell );\n\t\tconst endLocation = tableUtils.getCellLocation( targetCell );\n\n\t\tconst startRow = Math.min( startLocation.row, endLocation.row );\n\t\tconst endRow = Math.max( startLocation.row, endLocation.row );\n\n\t\tconst startColumn = Math.min( startLocation.column, endLocation.column );\n\t\tconst endColumn = Math.max( startLocation.column, endLocation.column );\n\n\t\t// 2-dimensional array of the selected cells to ease flipping the order of cells for backward selections.\n\t\tconst selectionMap = new Array( endRow - startRow + 1 ).fill( null ).map( () => [] );\n\n\t\tconst walkerOptions = {\n\t\t\tstartRow,\n\t\t\tendRow,\n\t\t\tstartColumn,\n\t\t\tendColumn\n\t\t};\n\n\t\tfor ( const { row, cell } of new TableWalker( anchorCell.findAncestor( 'table' ), walkerOptions ) ) {\n\t\t\tselectionMap[ row - startRow ].push( cell );\n\t\t}\n\n\t\tconst flipVertically = endLocation.row < startLocation.row;\n\t\tconst flipHorizontally = endLocation.column < startLocation.column;\n\n\t\tif ( flipVertically ) {\n\t\t\tselectionMap.reverse();\n\t\t}\n\n\t\tif ( flipHorizontally ) {\n\t\t\tselectionMap.forEach( row => row.reverse() );\n\t\t}\n\n\t\treturn {\n\t\t\tcells: selectionMap.flat(),\n\t\t\tbackward: flipVertically || flipHorizontally\n\t\t};\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}
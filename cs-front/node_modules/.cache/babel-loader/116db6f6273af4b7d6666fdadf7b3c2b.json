{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-layout-post-fixer\n */\nimport TableWalker from './../tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from '../utils/common';\n/**\n * Injects a table layout post-fixer into the model.\n *\n * The role of the table layout post-fixer is to ensure that the table rows have the correct structure\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct structure means that:\n *\n * * All table rows have the same size.\n * * None of the table cells extend vertically beyond their section (either header or body).\n * * A table cell has always at least one element as a child.\n *\n * If the table structure is not correct, the post-fixer will automatically correct it in two steps:\n *\n * 1. It will clip table cells that extend beyond their section.\n * 2. It will add empty table cells to the rows that are narrower than the widest table row.\n *\n * ## Clipping overlapping table cells\n *\n * Such situation may occur when pasting a table (or a part of a table) to the editor from external sources.\n *\n * For example, see the following table which has a cell (FOO) with the rowspan attribute (2):\n *\n *\t\t<table headingRows=\"1\">\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell rowspan=\"2\"><paragraph>FOO</paragraph></tableCell>\n *\t\t\t\t<tableCell colspan=\"2\"><paragraph>BAR</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph>BAZ</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>XYZ</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * It will be rendered in the view as:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * In the above example the table will be rendered as a table with two rows: one in the header and second one in the body.\n * The table cell (FOO) cannot span over multiple rows as it would extend from the header to the body section.\n * The `rowspan` attribute must be changed to (1). The value (1) is the default value of the `rowspan` attribute\n * so the `rowspan` attribute will be removed from the model.\n *\n * The table cell with BAZ in the content will be in the first column of the table.\n *\n * ## Adding missing table cells\n *\n * The table post-fixer will insert empty table cells to equalize table row sizes (the number of columns).\n * The size of a table row is calculated by counting column spans of table cells, both horizontal (from the same row) and\n * vertical (from the rows above).\n *\n * In the above example, the table row in the body section of the table is narrower then the row from the header: it has two cells\n * with the default colspan (1). The header row has one cell with colspan (1) and the second with colspan (2).\n * The table cell (FOO) does not extend beyond the head section (and as such will be fixed in the first step of this post-fixer).\n * The post-fixer will add a missing table cell to the row in the body section of the table.\n *\n * The table from the above example will be fixed and rendered to the view as below:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * ## Collaboration and undo - Expectations vs post-fixer results\n *\n * The table post-fixer only ensures proper structure without a deeper analysis of the nature of the change. As such, it might lead\n * to a structure which was not intended by the user. In particular, it will also fix undo steps (in conjunction with collaboration)\n * in which the editor content might not return to the original state.\n *\n * This will usually happen when one or more users change the size of the table.\n *\n * As an example see the table below:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * and the user actions:\n *\n * 1. Both users have a table with two rows and two columns.\n * 2. User A adds a column at the end of the table. This will insert empty table cells to two rows.\n * 3. User B adds a row at the end of the table. This will insert a row with two empty table cells.\n * 4. Both users will have a table as below:\n *\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * The last row is shorter then others so the table post-fixer will add an empty row to the last row:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by the post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * Unfortunately undo does not know the nature of the changes and depending on which user applies the post-fixer changes, undoing them\n * might lead to a broken table. If User B undoes inserting the column to the table, the undo engine will undo only the operations of\n * inserting empty cells to rows from the initial table state (row 1 and 2) but the cell in the post-fixed row will remain:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * After undo, the table post-fixer will detect that two rows are shorter than others and will fix the table to:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n * @param {module:engine/model/model~Model} model\n */\n\nexport default function injectTableLayoutPostFixer(model) {\n  model.document.registerPostFixer(writer => tableLayoutPostFixer(writer, model));\n} // The table layout post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction tableLayoutPostFixer(writer, model) {\n  const changes = model.document.differ.getChanges();\n  let wasFixed = false; // Do not analyze the same table more then once - may happen for multiple changes in the same table.\n\n  const analyzedTables = new Set();\n\n  for (const entry of changes) {\n    let table;\n\n    if (entry.name == 'table' && entry.type == 'insert') {\n      table = entry.position.nodeAfter;\n    } // Fix table on adding/removing table cells and rows.\n\n\n    if (entry.name == 'tableRow' || entry.name == 'tableCell') {\n      table = entry.position.findAncestor('table');\n    } // Fix table on any table's attribute change - including attributes of table cells.\n\n\n    if (isTableAttributeEntry(entry)) {\n      table = entry.range.start.findAncestor('table');\n    }\n\n    if (table && !analyzedTables.has(table)) {\n      // Step 1: correct rowspans of table cells if necessary.\n      // The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.\n      wasFixed = fixTableCellsRowspan(table, writer) || wasFixed; // Step 2: fix table rows sizes.\n\n      wasFixed = fixTableRowsSizes(table, writer) || wasFixed;\n      analyzedTables.add(table);\n    }\n  }\n\n  return wasFixed;\n} // Fixes the invalid value of the `rowspan` attribute because a table cell cannot vertically extend beyond the table section it belongs to.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns `true` if the table was fixed.\n\n\nfunction fixTableCellsRowspan(table, writer) {\n  let wasFixed = false;\n  const cellsToTrim = findCellsToTrim(table);\n\n  if (cellsToTrim.length) {\n    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: trimming cells row-spans (${ cellsToTrim.length }).` );\n    wasFixed = true;\n\n    for (const data of cellsToTrim) {\n      updateNumericAttribute('rowspan', data.rowspan, data.cell, writer, 1);\n    }\n  }\n\n  return wasFixed;\n} // Makes all table rows in a table the same size.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns `true` if the table was fixed.\n\n\nfunction fixTableRowsSizes(table, writer) {\n  let wasFixed = false;\n  const childrenLengths = getChildrenLengths(table);\n  const rowsToRemove = []; // Find empty rows.\n\n  for (const [rowIndex, size] of childrenLengths.entries()) {\n    // Ignore all non-row models.\n    if (!size && table.getChild(rowIndex).is('element', 'tableRow')) {\n      rowsToRemove.push(rowIndex);\n    }\n  } // Remove empty rows.\n\n\n  if (rowsToRemove.length) {\n    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: remove empty rows (${ rowsToRemove.length }).` );\n    wasFixed = true;\n\n    for (const rowIndex of rowsToRemove.reverse()) {\n      writer.remove(table.getChild(rowIndex));\n      childrenLengths.splice(rowIndex, 1);\n    }\n  } // Filter out everything that's not a table row.\n\n\n  const rowsLengths = childrenLengths.filter((row, rowIndex) => table.getChild(rowIndex).is('element', 'tableRow')); // Verify if all the rows have the same number of columns.\n\n  const tableSize = rowsLengths[0];\n  const isValid = rowsLengths.every(length => length === tableSize);\n\n  if (!isValid) {\n    // @if CK_DEBUG_TABLE // console.log( 'Post-fixing table: adding missing cells.' );\n    // Find the maximum number of columns.\n    const maxColumns = rowsLengths.reduce((prev, current) => current > prev ? current : prev, 0);\n\n    for (const [rowIndex, size] of rowsLengths.entries()) {\n      const columnsToInsert = maxColumns - size;\n\n      if (columnsToInsert) {\n        for (let i = 0; i < columnsToInsert; i++) {\n          createEmptyTableCell(writer, writer.createPositionAt(table.getChild(rowIndex), 'end'));\n        }\n\n        wasFixed = true;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Searches for table cells that extend beyond the table section to which they belong to. It will return an array of objects\n// that stores table cells to be trimmed and the correct value of the `rowspan` attribute to set.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<{{cell, rowspan}}>}\n\n\nfunction findCellsToTrim(table) {\n  const headingRows = parseInt(table.getAttribute('headingRows') || 0);\n  const maxRows = Array.from(table.getChildren()).reduce((count, row) => row.is('element', 'tableRow') ? count + 1 : count, 0);\n  const cellsToTrim = [];\n\n  for (const {\n    row,\n    cell,\n    cellHeight\n  } of new TableWalker(table)) {\n    // Skip cells that do not expand over its row.\n    if (cellHeight < 2) {\n      continue;\n    }\n\n    const isInHeader = row < headingRows; // Row limit is either end of header section or whole table as table body is after the header.\n\n    const rowLimit = isInHeader ? headingRows : maxRows; // If table cell expands over its limit reduce it height to proper value.\n\n    if (row + cellHeight > rowLimit) {\n      const newRowspan = rowLimit - row;\n      cellsToTrim.push({\n        cell,\n        rowspan: newRowspan\n      });\n    }\n  }\n\n  return cellsToTrim;\n} // Returns an array with lengths of rows assigned to the corresponding row index.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<Number>}\n\n\nfunction getChildrenLengths(table) {\n  // TableWalker will not provide items for the empty rows, we need to pre-fill this array.\n  const lengths = new Array(table.childCount).fill(0);\n\n  for (const {\n    rowIndex\n  } of new TableWalker(table, {\n    includeAllSlots: true\n  })) {\n    lengths[rowIndex]++;\n  }\n\n  return lengths;\n} // Checks if the differ entry for an attribute change is one of the table's attributes.\n//\n// @param entry\n// @returns {Boolean}\n\n\nfunction isTableAttributeEntry(entry) {\n  const isAttributeType = entry.type === 'attribute';\n  const key = entry.attributeKey;\n  return isAttributeType && (key === 'headingRows' || key === 'colspan' || key === 'rowspan');\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js"],"names":["TableWalker","createEmptyTableCell","updateNumericAttribute","injectTableLayoutPostFixer","model","document","registerPostFixer","writer","tableLayoutPostFixer","changes","differ","getChanges","wasFixed","analyzedTables","Set","entry","table","name","type","position","nodeAfter","findAncestor","isTableAttributeEntry","range","start","has","fixTableCellsRowspan","fixTableRowsSizes","add","cellsToTrim","findCellsToTrim","length","data","rowspan","cell","childrenLengths","getChildrenLengths","rowsToRemove","rowIndex","size","entries","getChild","is","push","reverse","remove","splice","rowsLengths","filter","row","tableSize","isValid","every","maxColumns","reduce","prev","current","columnsToInsert","i","createPositionAt","headingRows","parseInt","getAttribute","maxRows","Array","from","getChildren","count","cellHeight","isInHeader","rowLimit","newRowspan","lengths","childCount","fill","includeAllSlots","isAttributeType","key","attributeKey"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,WAAP,MAAwB,kBAAxB;AACA,SAASC,oBAAT,EAA+BC,sBAA/B,QAA6D,iBAA7D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,0BAAT,CAAqCC,KAArC,EAA6C;AAC3DA,EAAAA,KAAK,CAACC,QAAN,CAAeC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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-layout-post-fixer\n */\n\nimport TableWalker from './../tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from '../utils/common';\n\n/**\n * Injects a table layout post-fixer into the model.\n *\n * The role of the table layout post-fixer is to ensure that the table rows have the correct structure\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct structure means that:\n *\n * * All table rows have the same size.\n * * None of the table cells extend vertically beyond their section (either header or body).\n * * A table cell has always at least one element as a child.\n *\n * If the table structure is not correct, the post-fixer will automatically correct it in two steps:\n *\n * 1. It will clip table cells that extend beyond their section.\n * 2. It will add empty table cells to the rows that are narrower than the widest table row.\n *\n * ## Clipping overlapping table cells\n *\n * Such situation may occur when pasting a table (or a part of a table) to the editor from external sources.\n *\n * For example, see the following table which has a cell (FOO) with the rowspan attribute (2):\n *\n *\t\t<table headingRows=\"1\">\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell rowspan=\"2\"><paragraph>FOO</paragraph></tableCell>\n *\t\t\t\t<tableCell colspan=\"2\"><paragraph>BAR</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph>BAZ</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>XYZ</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * It will be rendered in the view as:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * In the above example the table will be rendered as a table with two rows: one in the header and second one in the body.\n * The table cell (FOO) cannot span over multiple rows as it would extend from the header to the body section.\n * The `rowspan` attribute must be changed to (1). The value (1) is the default value of the `rowspan` attribute\n * so the `rowspan` attribute will be removed from the model.\n *\n * The table cell with BAZ in the content will be in the first column of the table.\n *\n * ## Adding missing table cells\n *\n * The table post-fixer will insert empty table cells to equalize table row sizes (the number of columns).\n * The size of a table row is calculated by counting column spans of table cells, both horizontal (from the same row) and\n * vertical (from the rows above).\n *\n * In the above example, the table row in the body section of the table is narrower then the row from the header: it has two cells\n * with the default colspan (1). The header row has one cell with colspan (1) and the second with colspan (2).\n * The table cell (FOO) does not extend beyond the head section (and as such will be fixed in the first step of this post-fixer).\n * The post-fixer will add a missing table cell to the row in the body section of the table.\n *\n * The table from the above example will be fixed and rendered to the view as below:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * ## Collaboration and undo - Expectations vs post-fixer results\n *\n * The table post-fixer only ensures proper structure without a deeper analysis of the nature of the change. As such, it might lead\n * to a structure which was not intended by the user. In particular, it will also fix undo steps (in conjunction with collaboration)\n * in which the editor content might not return to the original state.\n *\n * This will usually happen when one or more users change the size of the table.\n *\n * As an example see the table below:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * and the user actions:\n *\n * 1. Both users have a table with two rows and two columns.\n * 2. User A adds a column at the end of the table. This will insert empty table cells to two rows.\n * 3. User B adds a row at the end of the table. This will insert a row with two empty table cells.\n * 4. Both users will have a table as below:\n *\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * The last row is shorter then others so the table post-fixer will add an empty row to the last row:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by the post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * Unfortunately undo does not know the nature of the changes and depending on which user applies the post-fixer changes, undoing them\n * might lead to a broken table. If User B undoes inserting the column to the table, the undo engine will undo only the operations of\n * inserting empty cells to rows from the initial table state (row 1 and 2) but the cell in the post-fixed row will remain:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * After undo, the table post-fixer will detect that two rows are shorter than others and will fix the table to:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableLayoutPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => tableLayoutPostFixer( writer, model ) );\n}\n\n// The table layout post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction tableLayoutPostFixer( writer, model ) {\n\tconst changes = model.document.differ.getChanges();\n\n\tlet wasFixed = false;\n\n\t// Do not analyze the same table more then once - may happen for multiple changes in the same table.\n\tconst analyzedTables = new Set();\n\n\tfor ( const entry of changes ) {\n\t\tlet table;\n\n\t\tif ( entry.name == 'table' && entry.type == 'insert' ) {\n\t\t\ttable = entry.position.nodeAfter;\n\t\t}\n\n\t\t// Fix table on adding/removing table cells and rows.\n\t\tif ( entry.name == 'tableRow' || entry.name == 'tableCell' ) {\n\t\t\ttable = entry.position.findAncestor( 'table' );\n\t\t}\n\n\t\t// Fix table on any table's attribute change - including attributes of table cells.\n\t\tif ( isTableAttributeEntry( entry ) ) {\n\t\t\ttable = entry.range.start.findAncestor( 'table' );\n\t\t}\n\n\t\tif ( table && !analyzedTables.has( table ) ) {\n\t\t\t// Step 1: correct rowspans of table cells if necessary.\n\t\t\t// The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.\n\t\t\twasFixed = fixTableCellsRowspan( table, writer ) || wasFixed;\n\t\t\t// Step 2: fix table rows sizes.\n\t\t\twasFixed = fixTableRowsSizes( table, writer ) || wasFixed;\n\n\t\t\tanalyzedTables.add( table );\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Fixes the invalid value of the `rowspan` attribute because a table cell cannot vertically extend beyond the table section it belongs to.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns `true` if the table was fixed.\nfunction fixTableCellsRowspan( table, writer ) {\n\tlet wasFixed = false;\n\n\tconst cellsToTrim = findCellsToTrim( table );\n\n\tif ( cellsToTrim.length ) {\n\t\t// @if CK_DEBUG_TABLE // console.log( `Post-fixing table: trimming cells row-spans (${ cellsToTrim.length }).` );\n\n\t\twasFixed = true;\n\n\t\tfor ( const data of cellsToTrim ) {\n\t\t\tupdateNumericAttribute( 'rowspan', data.rowspan, data.cell, writer, 1 );\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Makes all table rows in a table the same size.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns `true` if the table was fixed.\nfunction fixTableRowsSizes( table, writer ) {\n\tlet wasFixed = false;\n\n\tconst childrenLengths = getChildrenLengths( table );\n\tconst rowsToRemove = [];\n\n\t// Find empty rows.\n\tfor ( const [ rowIndex, size ] of childrenLengths.entries() ) {\n\t\t// Ignore all non-row models.\n\t\tif ( !size && table.getChild( rowIndex ).is( 'element', 'tableRow' ) ) {\n\t\t\trowsToRemove.push( rowIndex );\n\t\t}\n\t}\n\n\t// Remove empty rows.\n\tif ( rowsToRemove.length ) {\n\t\t// @if CK_DEBUG_TABLE // console.log( `Post-fixing table: remove empty rows (${ rowsToRemove.length }).` );\n\n\t\twasFixed = true;\n\n\t\tfor ( const rowIndex of rowsToRemove.reverse() ) {\n\t\t\twriter.remove( table.getChild( rowIndex ) );\n\t\t\tchildrenLengths.splice( rowIndex, 1 );\n\t\t}\n\t}\n\n\t// Filter out everything that's not a table row.\n\tconst rowsLengths = childrenLengths.filter( ( row, rowIndex ) => table.getChild( rowIndex ).is( 'element', 'tableRow' ) );\n\n\t// Verify if all the rows have the same number of columns.\n\tconst tableSize = rowsLengths[ 0 ];\n\tconst isValid = rowsLengths.every( length => length === tableSize );\n\n\tif ( !isValid ) {\n\t\t// @if CK_DEBUG_TABLE // console.log( 'Post-fixing table: adding missing cells.' );\n\n\t\t// Find the maximum number of columns.\n\t\tconst maxColumns = rowsLengths.reduce( ( prev, current ) => current > prev ? current : prev, 0 );\n\n\t\tfor ( const [ rowIndex, size ] of rowsLengths.entries() ) {\n\t\t\tconst columnsToInsert = maxColumns - size;\n\n\t\t\tif ( columnsToInsert ) {\n\t\t\t\tfor ( let i = 0; i < columnsToInsert; i++ ) {\n\t\t\t\t\tcreateEmptyTableCell( writer, writer.createPositionAt( table.getChild( rowIndex ), 'end' ) );\n\t\t\t\t}\n\n\t\t\t\twasFixed = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Searches for table cells that extend beyond the table section to which they belong to. It will return an array of objects\n// that stores table cells to be trimmed and the correct value of the `rowspan` attribute to set.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<{{cell, rowspan}}>}\nfunction findCellsToTrim( table ) {\n\tconst headingRows = parseInt( table.getAttribute( 'headingRows' ) || 0 );\n\tconst maxRows = Array.from( table.getChildren() )\n\t\t.reduce( ( count, row ) => row.is( 'element', 'tableRow' ) ? count + 1 : count, 0 );\n\n\tconst cellsToTrim = [];\n\n\tfor ( const { row, cell, cellHeight } of new TableWalker( table ) ) {\n\t\t// Skip cells that do not expand over its row.\n\t\tif ( cellHeight < 2 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst isInHeader = row < headingRows;\n\n\t\t// Row limit is either end of header section or whole table as table body is after the header.\n\t\tconst rowLimit = isInHeader ? headingRows : maxRows;\n\n\t\t// If table cell expands over its limit reduce it height to proper value.\n\t\tif ( row + cellHeight > rowLimit ) {\n\t\t\tconst newRowspan = rowLimit - row;\n\n\t\t\tcellsToTrim.push( { cell, rowspan: newRowspan } );\n\t\t}\n\t}\n\n\treturn cellsToTrim;\n}\n\n// Returns an array with lengths of rows assigned to the corresponding row index.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<Number>}\nfunction getChildrenLengths( table ) {\n\t// TableWalker will not provide items for the empty rows, we need to pre-fill this array.\n\tconst lengths = new Array( table.childCount ).fill( 0 );\n\n\tfor ( const { rowIndex } of new TableWalker( table, { includeAllSlots: true } ) ) {\n\t\tlengths[ rowIndex ]++;\n\t}\n\n\treturn lengths;\n}\n\n// Checks if the differ entry for an attribute change is one of the table's attributes.\n//\n// @param entry\n// @returns {Boolean}\nfunction isTableAttributeEntry( entry ) {\n\tconst isAttributeType = entry.type === 'attribute';\n\tconst key = entry.attributeKey;\n\n\treturn isAttributeType && ( key === 'headingRows' || key === 'colspan' || key === 'rowspan' );\n}\n"]},"metadata":{},"sourceType":"module"}
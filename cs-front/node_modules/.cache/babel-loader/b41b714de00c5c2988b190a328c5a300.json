{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module code-block/codeblockediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ShiftEnter } from 'ckeditor5/src/enter';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport CodeBlockCommand from './codeblockcommand';\nimport IndentCodeBlockCommand from './indentcodeblockcommand';\nimport OutdentCodeBlockCommand from './outdentcodeblockcommand';\nimport { getNormalizedAndLocalizedLanguageDefinitions, getLeadingWhiteSpaces, rawSnippetTextToViewDocumentFragment } from './utils';\nimport { modelToViewCodeBlockInsertion, modelToDataViewSoftBreakInsertion, dataViewToModelCodeBlockInsertion, dataViewToModelTextNewlinesInsertion } from './converters';\nconst DEFAULT_ELEMENT = 'paragraph';\n/**\n * The editing part of the code block feature.\n *\n * Introduces the `'codeBlock'` command and the `'codeBlock'` model element.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class CodeBlockEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'CodeBlockEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [ShiftEnter];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    editor.config.define('codeBlock', {\n      languages: [{\n        language: 'plaintext',\n        label: 'Plain text'\n      }, {\n        language: 'c',\n        label: 'C'\n      }, {\n        language: 'cs',\n        label: 'C#'\n      }, {\n        language: 'cpp',\n        label: 'C++'\n      }, {\n        language: 'css',\n        label: 'CSS'\n      }, {\n        language: 'diff',\n        label: 'Diff'\n      }, {\n        language: 'html',\n        label: 'HTML'\n      }, {\n        language: 'java',\n        label: 'Java'\n      }, {\n        language: 'javascript',\n        label: 'JavaScript'\n      }, {\n        language: 'php',\n        label: 'PHP'\n      }, {\n        language: 'python',\n        label: 'Python'\n      }, {\n        language: 'ruby',\n        label: 'Ruby'\n      }, {\n        language: 'typescript',\n        label: 'TypeScript'\n      }, {\n        language: 'xml',\n        label: 'XML'\n      }],\n      // A single tab.\n      indentSequence: '\\t'\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n    const model = editor.model;\n    const view = editor.editing.view;\n    const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor); // The main command.\n\n    editor.commands.add('codeBlock', new CodeBlockCommand(editor)); // Commands that change the indentation.\n\n    editor.commands.add('indentCodeBlock', new IndentCodeBlockCommand(editor));\n    editor.commands.add('outdentCodeBlock', new OutdentCodeBlockCommand(editor));\n\n    const getCommandExecuter = commandName => {\n      return (data, cancel) => {\n        const command = this.editor.commands.get(commandName);\n\n        if (command.isEnabled) {\n          this.editor.execute(commandName);\n          cancel();\n        }\n      };\n    };\n\n    editor.keystrokes.set('Tab', getCommandExecuter('indentCodeBlock'));\n    editor.keystrokes.set('Shift+Tab', getCommandExecuter('outdentCodeBlock'));\n    schema.register('codeBlock', {\n      allowWhere: '$block',\n      allowChildren: '$text',\n      isBlock: true,\n      allowAttributes: ['language']\n    }); // Disallow all attributes on $text inside `codeBlock`.\n\n    schema.addAttributeCheck(context => {\n      if (context.endsWith('codeBlock $text')) {\n        return false;\n      }\n    }); // Disallow object elements inside `codeBlock`. See #9567.\n\n    editor.model.schema.addChildCheck((context, childDefinition) => {\n      if (context.endsWith('codeBlock') && childDefinition.isObject) {\n        return false;\n      }\n    }); // Conversion.\n\n    editor.editing.downcastDispatcher.on('insert:codeBlock', modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs, true));\n    editor.data.downcastDispatcher.on('insert:codeBlock', modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs));\n    editor.data.downcastDispatcher.on('insert:softBreak', modelToDataViewSoftBreakInsertion(model), {\n      priority: 'high'\n    });\n    editor.data.upcastDispatcher.on('element:code', dataViewToModelCodeBlockInsertion(view, normalizedLanguagesDefs));\n    editor.data.upcastDispatcher.on('text', dataViewToModelTextNewlinesInsertion()); // Intercept the clipboard input (paste) when the selection is anchored in the code block and force the clipboard\n    // data to be pasted as a single plain text. Otherwise, the code lines will split the code block and\n    // \"spill out\" as separate paragraphs.\n\n    this.listenTo(editor.editing.view.document, 'clipboardInput', (evt, data) => {\n      let insertionRange = model.createRange(model.document.selection.anchor); // Use target ranges in case this is a drop.\n\n      if (data.targetRanges) {\n        insertionRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);\n      }\n\n      if (!insertionRange.start.parent.is('element', 'codeBlock')) {\n        return;\n      }\n\n      const text = data.dataTransfer.getData('text/plain');\n      const writer = new UpcastWriter(editor.editing.view.document); // Pass the view fragment to the default clipboardInput handler.\n\n      data.content = rawSnippetTextToViewDocumentFragment(writer, text);\n    }); // Make sure multi–line selection is always wrapped in a code block when `getSelectedContent()`\n    // is used (e.g. clipboard copy). Otherwise, only the raw text will be copied to the clipboard and,\n    // upon next paste, this bare text will not be inserted as a code block, which is not the best UX.\n    // Similarly, when the selection in a single line, the selected content should be an inline code\n    // so it can be pasted later on and retain it's preformatted nature.\n\n    this.listenTo(model, 'getSelectedContent', (evt, _ref) => {\n      let [selection] = _ref;\n      const anchor = selection.anchor;\n\n      if (selection.isCollapsed || !anchor.parent.is('element', 'codeBlock') || !anchor.hasSameParentAs(selection.focus)) {\n        return;\n      }\n\n      model.change(writer => {\n        const docFragment = evt.return; // fo[o<softBreak></softBreak>b]ar  ->   <codeBlock language=\"...\">[o<softBreak></softBreak>b]<codeBlock>\n\n        if (docFragment.childCount > 1 || selection.containsEntireContent(anchor.parent)) {\n          const codeBlock = writer.createElement('codeBlock', anchor.parent.getAttributes());\n          writer.append(docFragment, codeBlock);\n          const newDocumentFragment = writer.createDocumentFragment();\n          writer.append(codeBlock, newDocumentFragment);\n          evt.return = newDocumentFragment;\n        } // \"f[oo]\"                          ->   <$text code=\"true\">oo</text>\n        else {\n          const textNode = docFragment.getChild(0);\n\n          if (schema.checkAttribute(textNode, 'code')) {\n            writer.setAttribute('code', true, textNode);\n          }\n        }\n      });\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  afterInit() {\n    const editor = this.editor;\n    const commands = editor.commands;\n    const indent = commands.get('indent');\n    const outdent = commands.get('outdent');\n\n    if (indent) {\n      indent.registerChildCommand(commands.get('indentCodeBlock'));\n    }\n\n    if (outdent) {\n      outdent.registerChildCommand(commands.get('outdentCodeBlock'));\n    } // Customize the response to the <kbd>Enter</kbd> and <kbd>Shift</kbd>+<kbd>Enter</kbd>\n    // key press when the selection is in the code block. Upon enter key press we can either\n    // leave the block if it's \"two or three enters\" in a row or create a new code block line, preserving\n    // previous line's indentation.\n\n\n    this.listenTo(editor.editing.view.document, 'enter', (evt, data) => {\n      const positionParent = editor.model.document.selection.getLastPosition().parent;\n\n      if (!positionParent.is('element', 'codeBlock')) {\n        return;\n      }\n\n      if (!leaveBlockStartOnEnter(editor, data.isSoft) && !leaveBlockEndOnEnter(editor, data.isSoft)) {\n        breakLineOnEnter(editor);\n      }\n\n      data.preventDefault();\n      evt.stop();\n    }, {\n      context: 'pre'\n    });\n  }\n\n} // Normally, when the Enter (or Shift+Enter) key is pressed, a soft line break is to be added to the\n// code block. Let's try to follow the indentation of the previous line when possible, for instance:\n//\n//\t\t// Before pressing enter (or shift enter)\n//\t\t<codeBlock>\n//\t\t\"    foo()\"[]                   // Indent of 4 spaces.\n//\t\t</codeBlock>\n//\n//\t\t// After pressing:\n//\t\t<codeBlock>\n//\t\t\"    foo()\"                 // Indent of 4 spaces.\n//\t\t<softBreak></softBreak>     // A new soft break created by pressing enter.\n//\t\t\"    \"[]                    // Retain the indent of 4 spaces.\n//\t\t</codeBlock>\n//\n// @param {module:core/editor/editor~Editor} editor\n\nfunction breakLineOnEnter(editor) {\n  const model = editor.model;\n  const modelDoc = model.document;\n  const lastSelectionPosition = modelDoc.selection.getLastPosition();\n  const node = lastSelectionPosition.nodeBefore || lastSelectionPosition.textNode;\n  let leadingWhiteSpaces; // Figure out the indentation (white space chars) at the beginning of the line.\n\n  if (node && node.is('$text')) {\n    leadingWhiteSpaces = getLeadingWhiteSpaces(node);\n  } // Keeping everything in a change block for a single undo step.\n\n\n  editor.model.change(writer => {\n    editor.execute('shiftEnter'); // If the line before being broken in two had some indentation, let's retain it\n    // in the new line.\n\n    if (leadingWhiteSpaces) {\n      writer.insertText(leadingWhiteSpaces, modelDoc.selection.anchor);\n    }\n  });\n} // Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the beginning\n// of the code block:\n//\n//\t\t// Before:\n//\t\t<codeBlock>[]<softBreak></softBreak>foo</codeBlock>\n//\n//\t\t// After pressing:\n//\t\t<paragraph>[]</paragraph><codeBlock>foo</codeBlock>\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Boolean} isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.\n// @returns {Boolean} `true` when selection left the block. `false` if stayed.\n\n\nfunction leaveBlockStartOnEnter(editor, isSoftEnter) {\n  const model = editor.model;\n  const modelDoc = model.document;\n  const view = editor.editing.view;\n  const lastSelectionPosition = modelDoc.selection.getLastPosition();\n  const nodeAfter = lastSelectionPosition.nodeAfter;\n\n  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart) {\n    return false;\n  }\n\n  if (!isSoftBreakNode(nodeAfter)) {\n    return false;\n  } // We're doing everything in a single change block to have a single undo step.\n\n\n  editor.model.change(writer => {\n    // \"Clone\" the <codeBlock> in the standard way.\n    editor.execute('enter'); // The cloned block exists now before the original code block.\n\n    const newBlock = modelDoc.selection.anchor.parent.previousSibling; // Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).\n\n    writer.rename(newBlock, DEFAULT_ELEMENT);\n    writer.setSelection(newBlock, 'in');\n    editor.model.schema.removeDisallowedAttributes([newBlock], writer); // Remove the <softBreak> that originally followed the selection position.\n\n    writer.remove(nodeAfter);\n  }); // Eye candy.\n\n  view.scrollToTheSelection();\n  return true;\n} // Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the end\n// of the code block:\n//\n//\t\t// Before:\n//\t\t<codeBlock>foo[]</codeBlock>\n//\n//\t\t// After first press:\n//\t\t<codeBlock>foo<softBreak></softBreak>[]</codeBlock>\n//\n//\t\t// After second press:\n//\t\t<codeBlock>foo</codeBlock><paragraph>[]</paragraph>\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Boolean} isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.\n// @returns {Boolean} `true` when selection left the block. `false` if stayed.\n\n\nfunction leaveBlockEndOnEnter(editor, isSoftEnter) {\n  const model = editor.model;\n  const modelDoc = model.document;\n  const view = editor.editing.view;\n  const lastSelectionPosition = modelDoc.selection.getLastPosition();\n  const nodeBefore = lastSelectionPosition.nodeBefore;\n  let emptyLineRangeToRemoveOnEnter;\n\n  if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling) {\n    return false;\n  } // When the position is directly preceded by two soft breaks\n  //\n  //\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>[]</codeBlock>\n  //\n  // it creates the following range that will be cleaned up before leaving:\n  //\n  //\t\t<codeBlock>foo[<softBreak></softBreak><softBreak></softBreak>]</codeBlock>\n  //\n\n\n  if (isSoftBreakNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling)) {\n    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling), model.createPositionAfter(nodeBefore));\n  } // When there's some text before the position that is\n  // preceded by two soft breaks and made purely of white–space characters\n  //\n  //\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>    []</codeBlock>\n  //\n  // it creates the following range to clean up before leaving:\n  //\n  //\t\t<codeBlock>foo[<softBreak></softBreak><softBreak></softBreak>    ]</codeBlock>\n  //\n  else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling)) {\n    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));\n  } // When there's some text before the position that is made purely of white–space characters\n  // and is preceded by some other text made purely of white–space characters\n  //\n  //\t\t<codeBlock>foo<softBreak></softBreak>    <softBreak></softBreak>    []</codeBlock>\n  //\n  // it creates the following range to clean up before leaving:\n  //\n  //\t\t<codeBlock>foo[<softBreak></softBreak>    <softBreak></softBreak>    ]</codeBlock>\n  //\n  else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isEmptyishTextNode(nodeBefore.previousSibling.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling.previousSibling)) {\n    emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));\n  } // Not leaving the block in the following cases:\n  //\n  //\t\t<codeBlock>    []</codeBlock>\n  //\t\t<codeBlock>  a []</codeBlock>\n  //\t\t<codeBlock>foo<softBreak></softBreak>[]</codeBlock>\n  //\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>bar[]</codeBlock>\n  //\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak> a []</codeBlock>\n  //\n  else {\n    return false;\n  } // We're doing everything in a single change block to have a single undo step.\n\n\n  editor.model.change(writer => {\n    // Remove the last <softBreak>s and all white space characters that followed them.\n    writer.remove(emptyLineRangeToRemoveOnEnter); // \"Clone\" the <codeBlock> in the standard way.\n\n    editor.execute('enter');\n    const newBlock = modelDoc.selection.anchor.parent; // Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).\n\n    writer.rename(newBlock, DEFAULT_ELEMENT);\n    editor.model.schema.removeDisallowedAttributes([newBlock], writer);\n  }); // Eye candy.\n\n  view.scrollToTheSelection();\n  return true;\n}\n\nfunction isEmptyishTextNode(node) {\n  return node && node.is('$text') && !node.data.match(/\\S/);\n}\n\nfunction isSoftBreakNode(node) {\n  return node && node.is('element', 'softBreak');\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-code-block/src/codeblockediting.js"],"names":["Plugin","ShiftEnter","UpcastWriter","CodeBlockCommand","IndentCodeBlockCommand","OutdentCodeBlockCommand","getNormalizedAndLocalizedLanguageDefinitions","getLeadingWhiteSpaces","rawSnippetTextToViewDocumentFragment","modelToViewCodeBlockInsertion","modelToDataViewSoftBreakInsertion","dataViewToModelCodeBlockInsertion","dataViewToModelTextNewlinesInsertion","DEFAULT_ELEMENT","CodeBlockEditing","pluginName","requires","constructor","editor","config","define","languages","language","label","indentSequence","init","schema","model","view","editing","normalizedLanguagesDefs","commands","add","getCommandExecuter","commandName","data","cancel","command","get","isEnabled","execute","keystrokes","set","register","allowWhere","allowChildren","isBlock","allowAttributes","addAttributeCheck","context","endsWith","addChildCheck","childDefinition","isObject","downcastDispatcher","on","priority","upcastDispatcher","listenTo","document","evt","insertionRange","createRange","selection","anchor","targetRanges","mapper","toModelRange","start","parent","is","text","dataTransfer","getData","writer","content","isCollapsed","hasSameParentAs","focus","change","docFragment","return","childCount","containsEntireContent","codeBlock","createElement","getAttributes","append","newDocumentFragment","createDocumentFragment","textNode","getChild","checkAttribute","setAttribute","afterInit","indent","outdent","registerChildCommand","positionParent","getLastPosition","leaveBlockStartOnEnter","isSoft","leaveBlockEndOnEnter","breakLineOnEnter","preventDefault","stop","modelDoc","lastSelectionPosition","node","nodeBefore","leadingWhiteSpaces","insertText","isSoftEnter","nodeAfter","isAtStart","isSoftBreakNode","newBlock","previousSibling","rename","setSelection","removeDisallowedAttributes","remove","scrollToTheSelection","emptyLineRangeToRemoveOnEnter","isAtEnd","createPositionBefore","createPositionAfter","isEmptyishTextNode","match"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module code-block/codeblockediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ShiftEnter } from 'ckeditor5/src/enter';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\n\nimport CodeBlockCommand from './codeblockcommand';\nimport IndentCodeBlockCommand from './indentcodeblockcommand';\nimport OutdentCodeBlockCommand from './outdentcodeblockcommand';\nimport {\n\tgetNormalizedAndLocalizedLanguageDefinitions,\n\tgetLeadingWhiteSpaces,\n\trawSnippetTextToViewDocumentFragment\n} from './utils';\nimport {\n\tmodelToViewCodeBlockInsertion,\n\tmodelToDataViewSoftBreakInsertion,\n\tdataViewToModelCodeBlockInsertion,\n\tdataViewToModelTextNewlinesInsertion\n} from './converters';\n\nconst DEFAULT_ELEMENT = 'paragraph';\n\n/**\n * The editing part of the code block feature.\n *\n * Introduces the `'codeBlock'` command and the `'codeBlock'` model element.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class CodeBlockEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'CodeBlockEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ShiftEnter ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\teditor.config.define( 'codeBlock', {\n\t\t\tlanguages: [\n\t\t\t\t{ language: 'plaintext', label: 'Plain text' },\n\t\t\t\t{ language: 'c', label: 'C' },\n\t\t\t\t{ language: 'cs', label: 'C#' },\n\t\t\t\t{ language: 'cpp', label: 'C++' },\n\t\t\t\t{ language: 'css', label: 'CSS' },\n\t\t\t\t{ language: 'diff', label: 'Diff' },\n\t\t\t\t{ language: 'html', label: 'HTML' },\n\t\t\t\t{ language: 'java', label: 'Java' },\n\t\t\t\t{ language: 'javascript', label: 'JavaScript' },\n\t\t\t\t{ language: 'php', label: 'PHP' },\n\t\t\t\t{ language: 'python', label: 'Python' },\n\t\t\t\t{ language: 'ruby', label: 'Ruby' },\n\t\t\t\t{ language: 'typescript', label: 'TypeScript' },\n\t\t\t\t{ language: 'xml', label: 'XML' }\n\t\t\t],\n\n\t\t\t// A single tab.\n\t\t\tindentSequence: '\\t'\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\t\tconst model = editor.model;\n\t\tconst view = editor.editing.view;\n\n\t\tconst normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions( editor );\n\n\t\t// The main command.\n\t\teditor.commands.add( 'codeBlock', new CodeBlockCommand( editor ) );\n\n\t\t// Commands that change the indentation.\n\t\teditor.commands.add( 'indentCodeBlock', new IndentCodeBlockCommand( editor ) );\n\t\teditor.commands.add( 'outdentCodeBlock', new OutdentCodeBlockCommand( editor ) );\n\n\t\tconst getCommandExecuter = commandName => {\n\t\t\treturn ( data, cancel ) => {\n\t\t\t\tconst command = this.editor.commands.get( commandName );\n\n\t\t\t\tif ( command.isEnabled ) {\n\t\t\t\t\tthis.editor.execute( commandName );\n\t\t\t\t\tcancel();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\teditor.keystrokes.set( 'Tab', getCommandExecuter( 'indentCodeBlock' ) );\n\t\teditor.keystrokes.set( 'Shift+Tab', getCommandExecuter( 'outdentCodeBlock' ) );\n\n\t\tschema.register( 'codeBlock', {\n\t\t\tallowWhere: '$block',\n\t\t\tallowChildren: '$text',\n\t\t\tisBlock: true,\n\t\t\tallowAttributes: [ 'language' ]\n\t\t} );\n\n\t\t// Disallow all attributes on $text inside `codeBlock`.\n\t\tschema.addAttributeCheck( context => {\n\t\t\tif ( context.endsWith( 'codeBlock $text' ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} );\n\n\t\t// Disallow object elements inside `codeBlock`. See #9567.\n\t\teditor.model.schema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( context.endsWith( 'codeBlock' ) && childDefinition.isObject ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} );\n\n\t\t// Conversion.\n\t\teditor.editing.downcastDispatcher.on( 'insert:codeBlock', modelToViewCodeBlockInsertion( model, normalizedLanguagesDefs, true ) );\n\t\teditor.data.downcastDispatcher.on( 'insert:codeBlock', modelToViewCodeBlockInsertion( model, normalizedLanguagesDefs ) );\n\t\teditor.data.downcastDispatcher.on( 'insert:softBreak', modelToDataViewSoftBreakInsertion( model ), { priority: 'high' } );\n\n\t\teditor.data.upcastDispatcher.on( 'element:code', dataViewToModelCodeBlockInsertion( view, normalizedLanguagesDefs ) );\n\t\teditor.data.upcastDispatcher.on( 'text', dataViewToModelTextNewlinesInsertion() );\n\n\t\t// Intercept the clipboard input (paste) when the selection is anchored in the code block and force the clipboard\n\t\t// data to be pasted as a single plain text. Otherwise, the code lines will split the code block and\n\t\t// \"spill out\" as separate paragraphs.\n\t\tthis.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {\n\t\t\tlet insertionRange = model.createRange( model.document.selection.anchor );\n\n\t\t\t// Use target ranges in case this is a drop.\n\t\t\tif ( data.targetRanges ) {\n\t\t\t\tinsertionRange = editor.editing.mapper.toModelRange( data.targetRanges[ 0 ] );\n\t\t\t}\n\n\t\t\tif ( !insertionRange.start.parent.is( 'element', 'codeBlock' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst text = data.dataTransfer.getData( 'text/plain' );\n\t\t\tconst writer = new UpcastWriter( editor.editing.view.document );\n\n\t\t\t// Pass the view fragment to the default clipboardInput handler.\n\t\t\tdata.content = rawSnippetTextToViewDocumentFragment( writer, text );\n\t\t} );\n\n\t\t// Make sure multi–line selection is always wrapped in a code block when `getSelectedContent()`\n\t\t// is used (e.g. clipboard copy). Otherwise, only the raw text will be copied to the clipboard and,\n\t\t// upon next paste, this bare text will not be inserted as a code block, which is not the best UX.\n\t\t// Similarly, when the selection in a single line, the selected content should be an inline code\n\t\t// so it can be pasted later on and retain it's preformatted nature.\n\t\tthis.listenTo( model, 'getSelectedContent', ( evt, [ selection ] ) => {\n\t\t\tconst anchor = selection.anchor;\n\n\t\t\tif ( selection.isCollapsed || !anchor.parent.is( 'element', 'codeBlock' ) || !anchor.hasSameParentAs( selection.focus ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmodel.change( writer => {\n\t\t\t\tconst docFragment = evt.return;\n\n\t\t\t\t// fo[o<softBreak></softBreak>b]ar  ->   <codeBlock language=\"...\">[o<softBreak></softBreak>b]<codeBlock>\n\t\t\t\tif ( docFragment.childCount > 1 || selection.containsEntireContent( anchor.parent ) ) {\n\t\t\t\t\tconst codeBlock = writer.createElement( 'codeBlock', anchor.parent.getAttributes() );\n\t\t\t\t\twriter.append( docFragment, codeBlock );\n\n\t\t\t\t\tconst newDocumentFragment = writer.createDocumentFragment();\n\t\t\t\t\twriter.append( codeBlock, newDocumentFragment );\n\n\t\t\t\t\tevt.return = newDocumentFragment;\n\t\t\t\t}\n\n\t\t\t\t// \"f[oo]\"                          ->   <$text code=\"true\">oo</text>\n\t\t\t\telse {\n\t\t\t\t\tconst textNode = docFragment.getChild( 0 );\n\n\t\t\t\t\tif ( schema.checkAttribute( textNode, 'code' ) ) {\n\t\t\t\t\t\twriter.setAttribute( 'code', true, textNode );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tafterInit() {\n\t\tconst editor = this.editor;\n\t\tconst commands = editor.commands;\n\t\tconst indent = commands.get( 'indent' );\n\t\tconst outdent = commands.get( 'outdent' );\n\n\t\tif ( indent ) {\n\t\t\tindent.registerChildCommand( commands.get( 'indentCodeBlock' ) );\n\t\t}\n\n\t\tif ( outdent ) {\n\t\t\toutdent.registerChildCommand( commands.get( 'outdentCodeBlock' ) );\n\t\t}\n\n\t\t// Customize the response to the <kbd>Enter</kbd> and <kbd>Shift</kbd>+<kbd>Enter</kbd>\n\t\t// key press when the selection is in the code block. Upon enter key press we can either\n\t\t// leave the block if it's \"two or three enters\" in a row or create a new code block line, preserving\n\t\t// previous line's indentation.\n\t\tthis.listenTo( editor.editing.view.document, 'enter', ( evt, data ) => {\n\t\t\tconst positionParent = editor.model.document.selection.getLastPosition().parent;\n\n\t\t\tif ( !positionParent.is( 'element', 'codeBlock' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !leaveBlockStartOnEnter( editor, data.isSoft ) && !leaveBlockEndOnEnter( editor, data.isSoft ) ) {\n\t\t\t\tbreakLineOnEnter( editor );\n\t\t\t}\n\n\t\t\tdata.preventDefault();\n\t\t\tevt.stop();\n\t\t}, { context: 'pre' } );\n\t}\n}\n\n// Normally, when the Enter (or Shift+Enter) key is pressed, a soft line break is to be added to the\n// code block. Let's try to follow the indentation of the previous line when possible, for instance:\n//\n//\t\t// Before pressing enter (or shift enter)\n//\t\t<codeBlock>\n//\t\t\"    foo()\"[]                   // Indent of 4 spaces.\n//\t\t</codeBlock>\n//\n//\t\t// After pressing:\n//\t\t<codeBlock>\n//\t\t\"    foo()\"                 // Indent of 4 spaces.\n//\t\t<softBreak></softBreak>     // A new soft break created by pressing enter.\n//\t\t\"    \"[]                    // Retain the indent of 4 spaces.\n//\t\t</codeBlock>\n//\n// @param {module:core/editor/editor~Editor} editor\nfunction breakLineOnEnter( editor ) {\n\tconst model = editor.model;\n\tconst modelDoc = model.document;\n\tconst lastSelectionPosition = modelDoc.selection.getLastPosition();\n\tconst node = lastSelectionPosition.nodeBefore || lastSelectionPosition.textNode;\n\tlet leadingWhiteSpaces;\n\n\t// Figure out the indentation (white space chars) at the beginning of the line.\n\tif ( node && node.is( '$text' ) ) {\n\t\tleadingWhiteSpaces = getLeadingWhiteSpaces( node );\n\t}\n\n\t// Keeping everything in a change block for a single undo step.\n\teditor.model.change( writer => {\n\t\teditor.execute( 'shiftEnter' );\n\n\t\t// If the line before being broken in two had some indentation, let's retain it\n\t\t// in the new line.\n\t\tif ( leadingWhiteSpaces ) {\n\t\t\twriter.insertText( leadingWhiteSpaces, modelDoc.selection.anchor );\n\t\t}\n\t} );\n}\n\n// Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the beginning\n// of the code block:\n//\n//\t\t// Before:\n//\t\t<codeBlock>[]<softBreak></softBreak>foo</codeBlock>\n//\n//\t\t// After pressing:\n//\t\t<paragraph>[]</paragraph><codeBlock>foo</codeBlock>\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Boolean} isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.\n// @returns {Boolean} `true` when selection left the block. `false` if stayed.\nfunction leaveBlockStartOnEnter( editor, isSoftEnter ) {\n\tconst model = editor.model;\n\tconst modelDoc = model.document;\n\tconst view = editor.editing.view;\n\tconst lastSelectionPosition = modelDoc.selection.getLastPosition();\n\tconst nodeAfter = lastSelectionPosition.nodeAfter;\n\n\tif ( isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart ) {\n\t\treturn false;\n\t}\n\n\tif ( !isSoftBreakNode( nodeAfter ) ) {\n\t\treturn false;\n\t}\n\n\t// We're doing everything in a single change block to have a single undo step.\n\teditor.model.change( writer => {\n\t\t// \"Clone\" the <codeBlock> in the standard way.\n\t\teditor.execute( 'enter' );\n\n\t\t// The cloned block exists now before the original code block.\n\t\tconst newBlock = modelDoc.selection.anchor.parent.previousSibling;\n\n\t\t// Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).\n\t\twriter.rename( newBlock, DEFAULT_ELEMENT );\n\t\twriter.setSelection( newBlock, 'in' );\n\t\teditor.model.schema.removeDisallowedAttributes( [ newBlock ], writer );\n\n\t\t// Remove the <softBreak> that originally followed the selection position.\n\t\twriter.remove( nodeAfter );\n\t} );\n\n\t// Eye candy.\n\tview.scrollToTheSelection();\n\n\treturn true;\n}\n\n// Leave the code block when Enter (but NOT Shift+Enter) has been pressed twice at the end\n// of the code block:\n//\n//\t\t// Before:\n//\t\t<codeBlock>foo[]</codeBlock>\n//\n//\t\t// After first press:\n//\t\t<codeBlock>foo<softBreak></softBreak>[]</codeBlock>\n//\n//\t\t// After second press:\n//\t\t<codeBlock>foo</codeBlock><paragraph>[]</paragraph>\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Boolean} isSoftEnter When `true`, enter was pressed along with <kbd>Shift</kbd>.\n// @returns {Boolean} `true` when selection left the block. `false` if stayed.\nfunction leaveBlockEndOnEnter( editor, isSoftEnter ) {\n\tconst model = editor.model;\n\tconst modelDoc = model.document;\n\tconst view = editor.editing.view;\n\tconst lastSelectionPosition = modelDoc.selection.getLastPosition();\n\tconst nodeBefore = lastSelectionPosition.nodeBefore;\n\n\tlet emptyLineRangeToRemoveOnEnter;\n\n\tif ( isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling ) {\n\t\treturn false;\n\t}\n\n\t// When the position is directly preceded by two soft breaks\n\t//\n\t//\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>[]</codeBlock>\n\t//\n\t// it creates the following range that will be cleaned up before leaving:\n\t//\n\t//\t\t<codeBlock>foo[<softBreak></softBreak><softBreak></softBreak>]</codeBlock>\n\t//\n\tif ( isSoftBreakNode( nodeBefore ) && isSoftBreakNode( nodeBefore.previousSibling ) ) {\n\t\temptyLineRangeToRemoveOnEnter = model.createRange(\n\t\t\tmodel.createPositionBefore( nodeBefore.previousSibling ), model.createPositionAfter( nodeBefore )\n\t\t);\n\t}\n\n\t// When there's some text before the position that is\n\t// preceded by two soft breaks and made purely of white–space characters\n\t//\n\t//\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>    []</codeBlock>\n\t//\n\t// it creates the following range to clean up before leaving:\n\t//\n\t//\t\t<codeBlock>foo[<softBreak></softBreak><softBreak></softBreak>    ]</codeBlock>\n\t//\n\telse if (\n\t\tisEmptyishTextNode( nodeBefore ) &&\n\t\tisSoftBreakNode( nodeBefore.previousSibling ) &&\n\t\tisSoftBreakNode( nodeBefore.previousSibling.previousSibling )\n\t) {\n\t\temptyLineRangeToRemoveOnEnter = model.createRange(\n\t\t\tmodel.createPositionBefore( nodeBefore.previousSibling.previousSibling ), model.createPositionAfter( nodeBefore )\n\t\t);\n\t}\n\n\t// When there's some text before the position that is made purely of white–space characters\n\t// and is preceded by some other text made purely of white–space characters\n\t//\n\t//\t\t<codeBlock>foo<softBreak></softBreak>    <softBreak></softBreak>    []</codeBlock>\n\t//\n\t// it creates the following range to clean up before leaving:\n\t//\n\t//\t\t<codeBlock>foo[<softBreak></softBreak>    <softBreak></softBreak>    ]</codeBlock>\n\t//\n\telse if (\n\t\tisEmptyishTextNode( nodeBefore ) &&\n\t\tisSoftBreakNode( nodeBefore.previousSibling ) &&\n\t\tisEmptyishTextNode( nodeBefore.previousSibling.previousSibling ) &&\n\t\tisSoftBreakNode( nodeBefore.previousSibling.previousSibling.previousSibling )\n\t) {\n\t\temptyLineRangeToRemoveOnEnter = model.createRange(\n\t\t\tmodel.createPositionBefore( nodeBefore.previousSibling.previousSibling.previousSibling ),\n\t\t\tmodel.createPositionAfter( nodeBefore )\n\t\t);\n\t}\n\n\t// Not leaving the block in the following cases:\n\t//\n\t//\t\t<codeBlock>    []</codeBlock>\n\t//\t\t<codeBlock>  a []</codeBlock>\n\t//\t\t<codeBlock>foo<softBreak></softBreak>[]</codeBlock>\n\t//\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak>bar[]</codeBlock>\n\t//\t\t<codeBlock>foo<softBreak></softBreak><softBreak></softBreak> a []</codeBlock>\n\t//\n\telse {\n\t\treturn false;\n\t}\n\n\t// We're doing everything in a single change block to have a single undo step.\n\teditor.model.change( writer => {\n\t\t// Remove the last <softBreak>s and all white space characters that followed them.\n\t\twriter.remove( emptyLineRangeToRemoveOnEnter );\n\n\t\t// \"Clone\" the <codeBlock> in the standard way.\n\t\teditor.execute( 'enter' );\n\n\t\tconst newBlock = modelDoc.selection.anchor.parent;\n\n\t\t// Make the cloned <codeBlock> a regular <paragraph> (with clean attributes, so no language).\n\t\twriter.rename( newBlock, DEFAULT_ELEMENT );\n\t\teditor.model.schema.removeDisallowedAttributes( [ newBlock ], writer );\n\t} );\n\n\t// Eye candy.\n\tview.scrollToTheSelection();\n\n\treturn true;\n}\n\nfunction isEmptyishTextNode( node ) {\n\treturn node && node.is( '$text' ) && !node.data.match( /\\S/ );\n}\n\nfunction isSoftBreakNode( node ) {\n\treturn node && node.is( 'element', 'softBreak' );\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\nimport { CKEditorError } from 'ckeditor5/src/utils';\nimport { Plugin } from 'ckeditor5/src/core';\nimport TableWalker from './tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './utils/common';\nimport { removeEmptyColumns, removeEmptyRows } from './utils/structure';\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableUtils extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableUtils';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    this.decorate('insertColumns');\n    this.decorate('insertRows');\n  }\n  /**\n   * Returns the table cell location as an object with table row and table column indexes.\n   *\n   * For instance, in the table below:\n   *\n   *\t\t    0   1   2   3\n   *\t\t  +---+---+---+---+\n   *\t\t0 | a     | b | c |\n   *\t\t  +       +   +---+\n   *\t\t1 |       |   | d |\n   *\t\t  +---+---+   +---+\n   *\t\t2 | e     |   | f |\n   *\t\t  +---+---+---+---+\n   *\n   * the method will return:\n   *\n   *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n   *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n   *\t\t// will return { row: 0, column: 0 }\n   *\n   *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n   *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n   *\t\t// will return { row: 1, column: 3 }\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @returns {Object} Returns a `{row, column}` object.\n   */\n\n\n  getCellLocation(tableCell) {\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowIndex = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      row: rowIndex\n    });\n\n    for (const {\n      cell,\n      row,\n      column\n    } of tableWalker) {\n      if (cell === tableCell) {\n        return {\n          row,\n          column\n        };\n      }\n    }\n  }\n  /**\n   * Creates an empty table with a proper structure. The table needs to be inserted into the model,\n   * for example, by using the {@link module:engine/model/model~Model#insertContent} function.\n   *\n   *\t\tmodel.change( ( writer ) => {\n   *\t\t\t// Create a table of 2 rows and 7 columns:\n   *\t\t\tconst table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );\n   *\n   *\t\t\t// Insert a table to the model at the best position taking the current selection:\n   *\t\t\tmodel.insertContent( table );\n   *\t\t}\n   *\n   * @param {module:engine/model/writer~Writer} writer The model writer.\n   * @param {Object} options\n   * @param {Number} [options.rows=2] The number of rows to create.\n   * @param {Number} [options.columns=2] The number of columns to create.\n   * @param {Number} [options.headingRows=0] The number of heading rows.\n   * @param {Number} [options.headingColumns=0] The number of heading columns.\n   * @returns {module:engine/model/element~Element} The created table element.\n   */\n\n\n  createTable(writer, options) {\n    const table = writer.createElement('table');\n    const rows = parseInt(options.rows) || 2;\n    const columns = parseInt(options.columns) || 2;\n    createEmptyRows(writer, table, 0, rows, columns);\n\n    if (options.headingRows) {\n      updateNumericAttribute('headingRows', Math.min(options.headingRows, rows), table, writer, 0);\n    }\n\n    if (options.headingColumns) {\n      updateNumericAttribute('headingColumns', Math.min(options.headingColumns, columns), table, writer, 0);\n    }\n\n    return table;\n  }\n  /**\n   * Inserts rows into a table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n   *\n   * Assuming the table on the left, the above code will transform it to the table on the right:\n   *\n   *\t\trow index\n   *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n   *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n   *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n   *\t\t    |   | d | e |                      |   |   |   |\n   *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n   *\t\t    |   | f | g |                      |   |   |   |\n   *\t\t  3 +---+---+---+                      +   +---+---+ 3\n   *\t\t                                       |   | d | e |\n   *\t\t                                       +   +---+---+ 4\n   *\t\t                                       +   + f | g |\n   *\t\t                                       +---+---+---+ 5\n   *\n   * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n   * @param {Object} options\n   * @param {Number} [options.at=0] The row index at which the rows will be inserted.\n   * @param {Number} [options.rows=1] The number of rows to insert.\n   * @param {Boolean|undefined} [options.copyStructureFromAbove] The flag for copying row structure. Note that\n   * the row structure will not be copied if this option is not provided.\n   */\n\n\n  insertRows(table) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const model = this.editor.model;\n    const insertAt = options.at || 0;\n    const rowsToInsert = options.rows || 1;\n    const isCopyStructure = options.copyStructureFromAbove !== undefined;\n    const copyStructureFrom = options.copyStructureFromAbove ? insertAt - 1 : insertAt;\n    const rows = this.getRows(table);\n    const columns = this.getColumns(table);\n\n    if (insertAt > rows) {\n      /**\n       * The `options.at` points at a row position that does not exist.\n       *\n       * @error tableutils-insertrows-insert-out-of-range\n       */\n      throw new CKEditorError('tableutils-insertrows-insert-out-of-range', this, {\n        options\n      });\n    }\n\n    model.change(writer => {\n      const headingRows = table.getAttribute('headingRows') || 0; // Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\n      if (headingRows > insertAt) {\n        updateNumericAttribute('headingRows', headingRows + rowsToInsert, table, writer, 0);\n      } // Inserting at the end or at the beginning of a table doesn't require to calculate anything special.\n\n\n      if (!isCopyStructure && (insertAt === 0 || insertAt === rows)) {\n        createEmptyRows(writer, table, insertAt, rowsToInsert, columns);\n        return;\n      } // Iterate over all the rows above the inserted rows in order to check for the row-spanned cells.\n\n\n      const walkerEndRow = isCopyStructure ? Math.max(insertAt, copyStructureFrom) : insertAt;\n      const tableIterator = new TableWalker(table, {\n        endRow: walkerEndRow\n      }); // Store spans of the reference row to reproduce it's structure. This array is column number indexed.\n\n      const rowColSpansMap = new Array(columns).fill(1);\n\n      for (const {\n        row,\n        column,\n        cellHeight,\n        cellWidth,\n        cell\n      } of tableIterator) {\n        const lastCellRow = row + cellHeight - 1;\n        const isOverlappingInsertedRow = row < insertAt && insertAt <= lastCellRow;\n        const isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow; // If the cell is row-spanned and overlaps the inserted row, then reserve space for it in the row map.\n\n        if (isOverlappingInsertedRow) {\n          // This cell overlaps the inserted rows so we need to expand it further.\n          writer.setAttribute('rowspan', cellHeight + rowsToInsert, cell); // Mark this cell with negative number to indicate how many cells should be skipped when adding the new cells.\n\n          rowColSpansMap[column] = -cellWidth;\n        } // Store the colspan from reference row.\n        else if (isCopyStructure && isReferenceRow) {\n          rowColSpansMap[column] = cellWidth;\n        }\n      }\n\n      for (let rowIndex = 0; rowIndex < rowsToInsert; rowIndex++) {\n        const tableRow = writer.createElement('tableRow');\n        writer.insert(tableRow, table, insertAt);\n\n        for (let cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++) {\n          const colspan = rowColSpansMap[cellIndex];\n          const insertPosition = writer.createPositionAt(tableRow, 'end'); // Insert the empty cell only if this slot is not row-spanned from any other cell.\n\n          if (colspan > 0) {\n            createEmptyTableCell(writer, insertPosition, colspan > 1 ? {\n              colspan\n            } : null);\n          } // Skip the col-spanned slots, there won't be any cells.\n\n\n          cellIndex += Math.abs(colspan) - 1;\n        }\n      }\n    });\n  }\n  /**\n   * Inserts columns into a table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n   *\n   * Assuming the table on the left, the above code will transform it to the table on the right:\n   *\n   *\t\t0   1   2   3                   0   1   2   3   4   5\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t| a     | b |                   | a             | b |\n   *\t\t+       +---+                   +               +---+\n   *\t\t|       | c |                   |               | c |\n   *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n   *\t\t| d | e | f |                   | d |   |   | e | f |\n   *\t\t+---+   +---+                   +---+---+---+   +---+\n   *\t\t| g |   | h |                   | g |   |   |   | h |\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t| i         |                   | i                 |\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n   *\n   * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n   * @param {Object} options\n   * @param {Number} [options.at=0] The column index at which the columns will be inserted.\n   * @param {Number} [options.columns=1] The number of columns to insert.\n   */\n\n\n  insertColumns(table) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const model = this.editor.model;\n    const insertAt = options.at || 0;\n    const columnsToInsert = options.columns || 1;\n    model.change(writer => {\n      const headingColumns = table.getAttribute('headingColumns'); // Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\n      if (insertAt < headingColumns) {\n        writer.setAttribute('headingColumns', headingColumns + columnsToInsert, table);\n      }\n\n      const tableColumns = this.getColumns(table); // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\n      if (insertAt === 0 || tableColumns === insertAt) {\n        for (const tableRow of table.getChildren()) {\n          // Ignore non-row elements inside the table (e.g. caption).\n          if (!tableRow.is('element', 'tableRow')) {\n            continue;\n          }\n\n          createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt ? 'end' : 0));\n        }\n\n        return;\n      }\n\n      const tableWalker = new TableWalker(table, {\n        column: insertAt,\n        includeAllSlots: true\n      });\n\n      for (const tableSlot of tableWalker) {\n        const {\n          row,\n          cell,\n          cellAnchorColumn,\n          cellAnchorRow,\n          cellWidth,\n          cellHeight\n        } = tableSlot; // When iterating over column the table walker outputs either:\n        // - cells at given column index (cell \"e\" from method docs),\n        // - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeAllSlots: true`),\n        // - or a cell from the same row which spans over this column (cell \"a\").\n\n        if (cellAnchorColumn < insertAt) {\n          // If cell is anchored in previous column, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n          // For such cells expand them by a number of columns inserted.\n          writer.setAttribute('colspan', cellWidth + columnsToInsert, cell); // This cell will overlap cells in rows below so skip them (because of `includeAllSlots` option) - (cell \"a\")\n\n          const lastCellRow = cellAnchorRow + cellHeight - 1;\n\n          for (let i = row; i <= lastCellRow; i++) {\n            tableWalker.skipRow(i);\n          }\n        } else {\n          // It's either cell at this column index or spanned cell by a row-spanned cell from row above.\n          // In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n          createCells(columnsToInsert, writer, tableSlot.getPositionBefore());\n        }\n      }\n    });\n  }\n  /**\n   * Removes rows from the given `table`.\n   *\n   * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows\n   * and table headings values.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );\n   *\n   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:\n   *\n   *\t\trow index\n   *\t\t    ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐\n   *\t\t  0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0\n   *\t\t    │   ├───┼───┤                        │   ├───┼───┤\n   *\t\t  1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1\n   *\t\t    │   │   ├───┤        will give:      ├───┼───┼───┤\n   *\t\t  2 │   │   │ f │                        │ h │ i │ j │ 2\n   *\t\t    │   │   ├───┤                        └───┴───┴───┘\n   *\t\t  3 │   │   │ g │\n   *\t\t    ├───┼───┼───┤\n   *\t\t  4 │ h │ i │ j │\n   *\t\t    └───┴───┴───┘\n   *\n   * @param {module:engine/model/element~Element} table\n   * @param {Object} options\n   * @param {Number} options.at The row index at which the removing rows will start.\n   * @param {Number} [options.rows=1] The number of rows to remove.\n   */\n\n\n  removeRows(table, options) {\n    const model = this.editor.model;\n    const rowsToRemove = options.rows || 1;\n    const rowCount = this.getRows(table);\n    const first = options.at;\n    const last = first + rowsToRemove - 1;\n\n    if (last > rowCount - 1) {\n      /**\n       * The `options.at` param must point at existing row and `options.rows` must not exceed the rows in the table.\n       *\n       * @error tableutils-removerows-row-index-out-of-range\n       */\n      throw new CKEditorError('tableutils-removerows-row-index-out-of-range', this, {\n        table,\n        options\n      });\n    }\n\n    model.change(writer => {\n      // Removing rows from the table require that most calculations to be done prior to changing table structure.\n      // Preparations must be done in the same enqueueChange callback to use the current table structure.\n      // 1. Preparation - get row-spanned cells that have to be modified after removing rows.\n      const {\n        cellsToMove,\n        cellsToTrim\n      } = getCellsToMoveAndTrimOnRemoveRow(table, first, last); // 2. Execution\n      // 2a. Move cells from removed rows that extends over a removed section - must be done before removing rows.\n      // This will fill any gaps in a rows below that previously were empty because of row-spanned cells.\n\n      if (cellsToMove.size) {\n        const rowAfterRemovedSection = last + 1;\n        moveCellsToRow(table, rowAfterRemovedSection, cellsToMove, writer);\n      } // 2b. Remove all required rows.\n\n\n      for (let i = last; i >= first; i--) {\n        writer.remove(table.getChild(i));\n      } // 2c. Update cells from rows above that overlap removed section. Similar to step 2 but does not involve moving cells.\n\n\n      for (const {\n        rowspan,\n        cell\n      } of cellsToTrim) {\n        updateNumericAttribute('rowspan', rowspan, cell, writer);\n      } // 2d. Adjust heading rows if removed rows were in a heading section.\n\n\n      updateHeadingRows(table, first, last, writer); // 2e. Remove empty columns (without anchored cells) if there are any.\n\n      if (!removeEmptyColumns(table, this)) {\n        // If there wasn't any empty columns then we still need to check if this wasn't called\n        // because of cleaning empty rows and we only removed one of them.\n        removeEmptyRows(table, this);\n      }\n    });\n  }\n  /**\n   * Removes columns from the given `table`.\n   *\n   * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns\n   * and table headings values.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );\n   *\n   * Executing the above code in the context of the table on the left will transform its structure as presented on the right:\n   *\n   *\t\t  0   1   2   3   4                       0   1   2\n   *\t\t┌───────────────┬───┐                   ┌───────┬───┐\n   *\t\t│ a             │ b │                   │ a     │ b │\n   *\t\t│               ├───┤                   │       ├───┤\n   *\t\t│               │ c │                   │       │ c │\n   *\t\t├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤\n   *\t\t│ d │ e │ f │ g │ h │                   │ d │ g │ h │\n   *\t\t├───┼───┼───┤   ├───┤                   ├───┤   ├───┤\n   *\t\t│ i │ j │ k │   │ l │                   │ i │   │ l │\n   *\t\t├───┴───┴───┴───┴───┤                   ├───┴───┴───┤\n   *\t\t│ m                 │                   │ m         │\n   *\t\t└───────────────────┘                   └───────────┘\n   *\t\t      ^---- remove from here, `at` = 1, `columns` = 2\n   *\n   * @param {module:engine/model/element~Element} table\n   * @param {Object} options\n   * @param {Number} options.at The row index at which the removing columns will start.\n   * @param {Number} [options.columns=1] The number of columns to remove.\n   */\n\n\n  removeColumns(table, options) {\n    const model = this.editor.model;\n    const first = options.at;\n    const columnsToRemove = options.columns || 1;\n    const last = options.at + columnsToRemove - 1;\n    model.change(writer => {\n      adjustHeadingColumns(table, {\n        first,\n        last\n      }, writer);\n\n      for (let removedColumnIndex = last; removedColumnIndex >= first; removedColumnIndex--) {\n        for (const {\n          cell,\n          column,\n          cellWidth\n        } of [...new TableWalker(table)]) {\n          // If colspaned cell overlaps removed column decrease its span.\n          if (column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex) {\n            updateNumericAttribute('colspan', cellWidth - 1, cell, writer);\n          } else if (column === removedColumnIndex) {\n            // The cell in removed column has colspan of 1.\n            writer.remove(cell);\n          }\n        }\n      } // Remove empty rows that could appear after removing columns.\n\n\n      if (!removeEmptyRows(table, this)) {\n        // If there wasn't any empty rows then we still need to check if this wasn't called\n        // because of cleaning empty columns and we only removed one of them.\n        removeEmptyColumns(table, this);\n      }\n    });\n  }\n  /**\n   * Divides a table cell vertically into several ones.\n   *\n   * The cell will be visually split into more cells by updating colspans of other cells in a column\n   * and inserting cells (columns) after that cell.\n   *\n   * In the table below, if cell \"a\" is split into 3 cells:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * it will result in the table below:\n   *\n   *\t\t+---+---+---+---+---+\n   *\t\t| a |   |   | b | c |\n   *\t\t+---+---+---+---+---+\n   *\t\t| d         | e | f |\n   *\t\t+---+---+---+---+---+\n   *\n   * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n   *\n   * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n   * will be left to the original cell:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a         |\n   *\t\t+---+---+---+\n   *\t\t| b | c | d |\n   *\t\t+---+---+---+\n   *\n   * Splitting cell \"a\" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a     |   |\n   *\t\t+---+---+---+\n   *\t\t| b | c | d |\n   *\t\t+---+---+---+\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @param {Number} numberOfCells\n   */\n\n\n  splitCellVertically(tableCell) {\n    let numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    const model = this.editor.model;\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n    const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n    model.change(writer => {\n      // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n      if (colspan > 1) {\n        // Get spans of new (inserted) cells and span to update of split cell.\n        const {\n          newCellsSpan,\n          updatedSpan\n        } = breakSpanEvenly(colspan, numberOfCells);\n        updateNumericAttribute('colspan', updatedSpan, tableCell, writer); // Each inserted cell will have the same attributes:\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n\n        if (newCellsSpan > 1) {\n          newCellsAttributes.colspan = newCellsSpan;\n        } // Copy rowspan of split cell.\n\n\n        if (rowspan > 1) {\n          newCellsAttributes.rowspan = rowspan;\n        }\n\n        const cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);\n      } // Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\n\n      if (colspan < numberOfCells) {\n        const cellsToInsert = numberOfCells - colspan; // First step: expand cells on the same column as split cell.\n\n        const tableMap = [...new TableWalker(table)]; // Get the column index of split cell.\n\n        const {\n          column: splitCellColumn\n        } = tableMap.find(_ref => {\n          let {\n            cell\n          } = _ref;\n          return cell === tableCell;\n        }); // Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\n        const cellsToUpdate = tableMap.filter(_ref2 => {\n          let {\n            cell,\n            cellWidth,\n            column\n          } = _ref2;\n          const isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n          const spansOverColumn = column < splitCellColumn && column + cellWidth > splitCellColumn;\n          return isOnSameColumn || spansOverColumn;\n        }); // Expand cells vertically.\n\n        for (const {\n          cell,\n          cellWidth\n        } of cellsToUpdate) {\n          writer.setAttribute('colspan', cellWidth + cellsToInsert, cell);\n        } // Second step: create columns after split cell.\n        // Each inserted cell will have the same attributes:\n\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n        // Copy rowspan of split cell.\n\n        if (rowspan > 1) {\n          newCellsAttributes.rowspan = rowspan;\n        }\n\n        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);\n        const headingColumns = table.getAttribute('headingColumns') || 0; // Update heading section if split cell is in heading section.\n\n        if (headingColumns > splitCellColumn) {\n          updateNumericAttribute('headingColumns', headingColumns + cellsToInsert, table, writer);\n        }\n      }\n    });\n  }\n  /**\n   * Divides a table cell horizontally into several ones.\n   *\n   * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n   * below.\n   *\n   * If in the table below cell \"b\" is split into 3 cells:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * It will result in the table below:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+   +\n   *\t\t|   |   |   |\n   *\t\t+   +---+   +\n   *\t\t|   |   |   |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n   *\n   * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n   * will be left to the original cell:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+---+\n   *\t\t|   | d | e |\n   *\t\t+   +---+---+\n   *\t\t|   | f | g |\n   *\t\t+   +---+---+\n   *\t\t|   | h | i |\n   *\t\t+---+---+---+\n   *\n   * Splitting cell \"a\" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+---+\n   *\t\t|   | d | e |\n   *\t\t+---+---+---+\n   *\t\t|   | f | g |\n   *\t\t+---+---+---+\n   *\t\t|   | h | i |\n   *\t\t+---+---+---+\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @param {Number} numberOfCells\n   */\n\n\n  splitCellHorizontally(tableCell) {\n    let numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    const model = this.editor.model;\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const splitCellRow = table.getChildIndex(tableRow);\n    const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n    const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n    model.change(writer => {\n      // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n      if (rowspan > 1) {\n        // Cache table map before updating table.\n        const tableMap = [...new TableWalker(table, {\n          startRow: splitCellRow,\n          endRow: splitCellRow + rowspan - 1,\n          includeAllSlots: true\n        })]; // Get spans of new (inserted) cells and span to update of split cell.\n\n        const {\n          newCellsSpan,\n          updatedSpan\n        } = breakSpanEvenly(rowspan, numberOfCells);\n        updateNumericAttribute('rowspan', updatedSpan, tableCell, writer);\n        const {\n          column: cellColumn\n        } = tableMap.find(_ref3 => {\n          let {\n            cell\n          } = _ref3;\n          return cell === tableCell;\n        }); // Each inserted cell will have the same attributes:\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n\n        if (newCellsSpan > 1) {\n          newCellsAttributes.rowspan = newCellsSpan;\n        } // Copy colspan of split cell.\n\n\n        if (colspan > 1) {\n          newCellsAttributes.colspan = colspan;\n        }\n\n        for (const tableSlot of tableMap) {\n          const {\n            column,\n            row\n          } = tableSlot; // As both newly created cells and the split cell might have rowspan,\n          // the insertion of new cells must go to appropriate rows:\n          //\n          // 1. It's a row after split cell + it's height.\n\n          const isAfterSplitCell = row >= splitCellRow + updatedSpan; // 2. Is on the same column.\n\n          const isOnSameColumn = column === cellColumn; // 3. And it's row index is after previous cell height.\n\n          const isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;\n\n          if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {\n            createCells(1, writer, tableSlot.getPositionBefore(), newCellsAttributes);\n          }\n        }\n      } // Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\n\n      if (rowspan < numberOfCells) {\n        // We already split the cell in check one so here we split to the remaining number of cells only.\n        const cellsToInsert = numberOfCells - rowspan; // This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\n        const tableMap = [...new TableWalker(table, {\n          startRow: 0,\n          endRow: splitCellRow\n        })]; // First step: expand cells.\n\n        for (const {\n          cell,\n          cellHeight,\n          row\n        } of tableMap) {\n          // Expand rowspan of cells that are either:\n          // - on the same row as current cell,\n          // - or are below split cell row and overlaps that row.\n          if (cell !== tableCell && row + cellHeight > splitCellRow) {\n            const rowspanToSet = cellHeight + cellsToInsert;\n            writer.setAttribute('rowspan', rowspanToSet, cell);\n          }\n        } // Second step: create rows with single cell below split cell.\n\n\n        const newCellsAttributes = {}; // Copy colspan of split cell.\n\n        if (colspan > 1) {\n          newCellsAttributes.colspan = colspan;\n        }\n\n        createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes); // Update heading section if split cell is in heading section.\n\n        const headingRows = table.getAttribute('headingRows') || 0;\n\n        if (headingRows > splitCellRow) {\n          updateNumericAttribute('headingRows', headingRows + cellsToInsert, table, writer);\n        }\n      }\n    });\n  }\n  /**\n   * Returns the number of columns for a given table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n   *\n   * @param {module:engine/model/element~Element} table The table to analyze.\n   * @returns {Number}\n   */\n\n\n  getColumns(table) {\n    // Analyze first row only as all the rows should have the same width.\n    // Using the first row without checking if it's a tableRow because we expect\n    // that table will have only tableRow model elements at the beginning.\n    const row = table.getChild(0);\n    return [...row.getChildren()].reduce((columns, row) => {\n      const columnWidth = parseInt(row.getAttribute('colspan') || 1);\n      return columns + columnWidth;\n    }, 0);\n  }\n  /**\n   * Returns the number of rows for a given table. Any other element present in the table model is omitted.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).getRows( table );\n   *\n   * @param {module:engine/model/element~Element} table The table to analyze.\n   * @returns {Number}\n   */\n\n\n  getRows(table) {\n    // Rowspan not included due to #6427.\n    return Array.from(table.getChildren()).reduce((rowCount, child) => child.is('element', 'tableRow') ? rowCount + 1 : rowCount, 0);\n  }\n\n} // Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt The row index of row insertion.\n// @param {Number} rows The number of rows to create.\n// @param {Number} tableCellToInsert The number of cells to insert in each row.\n\nfunction createEmptyRows(writer, table, insertAt, rows, tableCellToInsert) {\n  let attributes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n  for (let i = 0; i < rows; i++) {\n    const tableRow = writer.createElement('tableRow');\n    writer.insert(tableRow, table, insertAt);\n    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, 'end'), attributes);\n  }\n} // Creates cells at a given position.\n//\n// @param {Number} columns The number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\n\n\nfunction createCells(cells, writer, insertPosition) {\n  let attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  for (let i = 0; i < cells; i++) {\n    createEmptyTableCell(writer, insertPosition, attributes);\n  }\n} // Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span The span value do break.\n// @param {Number} numberOfCells The number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\n\n\nfunction breakSpanEvenly(span, numberOfCells) {\n  if (span < numberOfCells) {\n    return {\n      newCellsSpan: 1,\n      updatedSpan: 1\n    };\n  }\n\n  const newCellsSpan = Math.floor(span / numberOfCells);\n  const updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;\n  return {\n    newCellsSpan,\n    updatedSpan\n  };\n} // Updates heading columns attribute if removing a row from head section.\n\n\nfunction adjustHeadingColumns(table, removedColumnIndexes, writer) {\n  const headingColumns = table.getAttribute('headingColumns') || 0;\n\n  if (headingColumns && removedColumnIndexes.first < headingColumns) {\n    const headingsRemoved = Math.min(headingColumns - 1\n    /* Other numbers are 0-based */\n    , removedColumnIndexes.last) - removedColumnIndexes.first + 1;\n    writer.setAttribute('headingColumns', headingColumns - headingsRemoved, table);\n  }\n} // Calculates a new heading rows value for removing rows from heading section.\n\n\nfunction updateHeadingRows(table, first, last, writer) {\n  const headingRows = table.getAttribute('headingRows') || 0;\n\n  if (first < headingRows) {\n    const newRows = last < headingRows ? headingRows - (last - first + 1) : first;\n    updateNumericAttribute('headingRows', newRows, table, writer, 0);\n  }\n} // Finds cells that will be:\n// - trimmed - Cells that are \"above\" removed rows sections and overlap the removed section - their rowspan must be trimmed.\n// - moved - Cells from removed rows section might stick out of. These cells are moved to the next row after a removed section.\n//\n// Sample table with overlapping & sticking out cells:\n//\n//      +----+----+----+----+----+\n//      | 00 | 01 | 02 | 03 | 04 |\n//      +----+    +    +    +    +\n//      | 10 |    |    |    |    |\n//      +----+----+    +    +    +\n//      | 20 | 21 |    |    |    | <-- removed row\n//      +    +    +----+    +    +\n//      |    |    | 32 |    |    | <-- removed row\n//      +----+    +    +----+    +\n//      | 40 |    |    | 43 |    |\n//      +----+----+----+----+----+\n//\n// In a table above:\n// - cells to trim: '02', '03' & '04'.\n// - cells to move: '21' & '32'.\n\n\nfunction getCellsToMoveAndTrimOnRemoveRow(table, first, last) {\n  const cellsToMove = new Map();\n  const cellsToTrim = [];\n\n  for (const {\n    row,\n    column,\n    cellHeight,\n    cell\n  } of new TableWalker(table, {\n    endRow: last\n  })) {\n    const lastRowOfCell = row + cellHeight - 1;\n    const isCellStickingOutFromRemovedRows = row >= first && row <= last && lastRowOfCell > last;\n\n    if (isCellStickingOutFromRemovedRows) {\n      const rowspanInRemovedSection = last - row + 1;\n      const rowSpanToSet = cellHeight - rowspanInRemovedSection;\n      cellsToMove.set(column, {\n        cell,\n        rowspan: rowSpanToSet\n      });\n    }\n\n    const isCellOverlappingRemovedRows = row < first && lastRowOfCell >= first;\n\n    if (isCellOverlappingRemovedRows) {\n      let rowspanAdjustment; // Cell fully covers removed section - trim it by removed rows count.\n\n      if (lastRowOfCell >= last) {\n        rowspanAdjustment = last - first + 1;\n      } // Cell partially overlaps removed section - calculate cell's span that is in removed section.\n      else {\n        rowspanAdjustment = lastRowOfCell - first + 1;\n      }\n\n      cellsToTrim.push({\n        cell,\n        rowspan: cellHeight - rowspanAdjustment\n      });\n    }\n  }\n\n  return {\n    cellsToMove,\n    cellsToTrim\n  };\n}\n\nfunction moveCellsToRow(table, targetRowIndex, cellsToMove, writer) {\n  const tableWalker = new TableWalker(table, {\n    includeAllSlots: true,\n    row: targetRowIndex\n  });\n  const tableRowMap = [...tableWalker];\n  const row = table.getChild(targetRowIndex);\n  let previousCell;\n\n  for (const {\n    column,\n    cell,\n    isAnchor\n  } of tableRowMap) {\n    if (cellsToMove.has(column)) {\n      const {\n        cell: cellToMove,\n        rowspan\n      } = cellsToMove.get(column);\n      const targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(row, 0);\n      writer.move(writer.createRangeOn(cellToMove), targetPosition);\n      updateNumericAttribute('rowspan', rowspan, cellToMove, writer);\n      previousCell = cellToMove;\n    } else if (isAnchor) {\n      // If cell is spanned then `cell` holds reference to overlapping cell. See ckeditor/ckeditor5#6502.\n      previousCell = cell;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js"],"names":["CKEditorError","Plugin","TableWalker","createEmptyTableCell","updateNumericAttribute","removeEmptyColumns","removeEmptyRows","TableUtils","pluginName","init","decorate","getCellLocation","tableCell","tableRow","parent","table","rowIndex","getChildIndex","tableWalker","row","cell","column","createTable","writer","options","createElement","rows","parseInt","columns","createEmptyRows","headingRows","Math","min","headingColumns","insertRows","model","editor","insertAt","at","rowsToInsert","isCopyStructure","copyStructureFromAbove","undefined","copyStructureFrom","getRows","getColumns","change","getAttribute","walkerEndRow","max","tableIterator","endRow","rowColSpansMap","Array","fill","cellHeight","cellWidth","lastCellRow","isOverlappingInsertedRow","isReferenceRow","setAttribute","insert","cellIndex","length","colspan","insertPosition","createPositionAt","abs","insertColumns","columnsToInsert","tableColumns","getChildren","is","createCells","includeAllSlots","tableSlot","cellAnchorColumn","cellAnchorRow","i","skipRow","getPositionBefore","removeRows","rowsToRemove","rowCount","first","last","cellsToMove","cellsToTrim","getCellsToMoveAndTrimOnRemoveRow","size","rowAfterRemovedSection","moveCellsToRow","remove","getChild","rowspan","updateHeadingRows","removeColumns","columnsToRemove","adjustHeadingColumns","removedColumnIndex","splitCellVertically","numberOfCells","newCellsSpan","updatedSpan","breakSpanEvenly","newCellsAttributes","cellsToInsert","createPositionAfter","tableMap","splitCellColumn","find","cellsToUpdate","filter","isOnSameColumn","spansOverColumn","splitCellHorizontally","splitCellRow","startRow","cellColumn","isAfterSplitCell","isInEvenlySplitRow","rowspanToSet","reduce","columnWidth","from","child","tableCellToInsert","attributes","cells","span","floor","removedColumnIndexes","headingsRemoved","newRows","Map","lastRowOfCell","isCellStickingOutFromRemovedRows","rowspanInRemovedSection","rowSpanToSet","set","isCellOverlappingRemovedRows","rowspanAdjustment","push","targetRowIndex","tableRowMap","previousCell","isAnchor","has","cellToMove","get","targetPosition","move","createRangeOn"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\n\nimport { CKEditorError } from 'ckeditor5/src/utils';\nimport { Plugin } from 'ckeditor5/src/core';\n\nimport TableWalker from './tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './utils/common';\nimport { removeEmptyColumns, removeEmptyRows } from './utils/structure';\n\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableUtils extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableUtils';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tthis.decorate( 'insertColumns' );\n\t\tthis.decorate( 'insertRows' );\n\t}\n\n\t/**\n\t * Returns the table cell location as an object with table row and table column indexes.\n\t *\n\t * For instance, in the table below:\n\t *\n\t *\t\t    0   1   2   3\n\t *\t\t  +---+---+---+---+\n\t *\t\t0 | a     | b | c |\n\t *\t\t  +       +   +---+\n\t *\t\t1 |       |   | d |\n\t *\t\t  +---+---+   +---+\n\t *\t\t2 | e     |   | f |\n\t *\t\t  +---+---+---+---+\n\t *\n\t * the method will return:\n\t *\n\t *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n\t *\t\t// will return { row: 0, column: 0 }\n\t *\n\t *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n\t *\t\t// will return { row: 1, column: 3 }\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @returns {Object} Returns a `{row, column}` object.\n\t */\n\tgetCellLocation( tableCell ) {\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { row: rowIndex } );\n\n\t\tfor ( const { cell, row, column } of tableWalker ) {\n\t\t\tif ( cell === tableCell ) {\n\t\t\t\treturn { row, column };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an empty table with a proper structure. The table needs to be inserted into the model,\n\t * for example, by using the {@link module:engine/model/model~Model#insertContent} function.\n\t *\n\t *\t\tmodel.change( ( writer ) => {\n\t *\t\t\t// Create a table of 2 rows and 7 columns:\n\t *\t\t\tconst table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );\n\t *\n\t *\t\t\t// Insert a table to the model at the best position taking the current selection:\n\t *\t\t\tmodel.insertContent( table );\n\t *\t\t}\n\t *\n\t * @param {module:engine/model/writer~Writer} writer The model writer.\n\t * @param {Object} options\n\t * @param {Number} [options.rows=2] The number of rows to create.\n\t * @param {Number} [options.columns=2] The number of columns to create.\n\t * @param {Number} [options.headingRows=0] The number of heading rows.\n\t * @param {Number} [options.headingColumns=0] The number of heading columns.\n\t * @returns {module:engine/model/element~Element} The created table element.\n\t */\n\tcreateTable( writer, options ) {\n\t\tconst table = writer.createElement( 'table' );\n\n\t\tconst rows = parseInt( options.rows ) || 2;\n\t\tconst columns = parseInt( options.columns ) || 2;\n\n\t\tcreateEmptyRows( writer, table, 0, rows, columns );\n\n\t\tif ( options.headingRows ) {\n\t\t\tupdateNumericAttribute( 'headingRows', Math.min( options.headingRows, rows ), table, writer, 0 );\n\t\t}\n\n\t\tif ( options.headingColumns ) {\n\t\t\tupdateNumericAttribute( 'headingColumns', Math.min( options.headingColumns, columns ), table, writer, 0 );\n\t\t}\n\n\t\treturn table;\n\t}\n\n\t/**\n\t * Inserts rows into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\trow index\n\t *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n\t *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n\t *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n\t *\t\t    |   | d | e |                      |   |   |   |\n\t *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n\t *\t\t    |   | f | g |                      |   |   |   |\n\t *\t\t  3 +---+---+---+                      +   +---+---+ 3\n\t *\t\t                                       |   | d | e |\n\t *\t\t                                       +   +---+---+ 4\n\t *\t\t                                       +   + f | g |\n\t *\t\t                                       +---+---+---+ 5\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] The row index at which the rows will be inserted.\n\t * @param {Number} [options.rows=1] The number of rows to insert.\n\t * @param {Boolean|undefined} [options.copyStructureFromAbove] The flag for copying row structure. Note that\n\t * the row structure will not be copied if this option is not provided.\n\t */\n\tinsertRows( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst rowsToInsert = options.rows || 1;\n\t\tconst isCopyStructure = options.copyStructureFromAbove !== undefined;\n\t\tconst copyStructureFrom = options.copyStructureFromAbove ? insertAt - 1 : insertAt;\n\n\t\tconst rows = this.getRows( table );\n\t\tconst columns = this.getColumns( table );\n\n\t\tif ( insertAt > rows ) {\n\t\t\t/**\n\t\t\t * The `options.at` points at a row position that does not exist.\n\t\t\t *\n\t\t\t * @error tableutils-insertrows-insert-out-of-range\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'tableutils-insertrows-insert-out-of-range',\n\t\t\t\tthis,\n\t\t\t\t{ options }\n\t\t\t);\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t// Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\t\t\tif ( headingRows > insertAt ) {\n\t\t\t\tupdateNumericAttribute( 'headingRows', headingRows + rowsToInsert, table, writer, 0 );\n\t\t\t}\n\n\t\t\t// Inserting at the end or at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( !isCopyStructure && ( insertAt === 0 || insertAt === rows ) ) {\n\t\t\t\tcreateEmptyRows( writer, table, insertAt, rowsToInsert, columns );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate over all the rows above the inserted rows in order to check for the row-spanned cells.\n\t\t\tconst walkerEndRow = isCopyStructure ? Math.max( insertAt, copyStructureFrom ) : insertAt;\n\t\t\tconst tableIterator = new TableWalker( table, { endRow: walkerEndRow } );\n\n\t\t\t// Store spans of the reference row to reproduce it's structure. This array is column number indexed.\n\t\t\tconst rowColSpansMap = new Array( columns ).fill( 1 );\n\n\t\t\tfor ( const { row, column, cellHeight, cellWidth, cell } of tableIterator ) {\n\t\t\t\tconst lastCellRow = row + cellHeight - 1;\n\n\t\t\t\tconst isOverlappingInsertedRow = row < insertAt && insertAt <= lastCellRow;\n\t\t\t\tconst isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow;\n\n\t\t\t\t// If the cell is row-spanned and overlaps the inserted row, then reserve space for it in the row map.\n\t\t\t\tif ( isOverlappingInsertedRow ) {\n\t\t\t\t\t// This cell overlaps the inserted rows so we need to expand it further.\n\t\t\t\t\twriter.setAttribute( 'rowspan', cellHeight + rowsToInsert, cell );\n\n\t\t\t\t\t// Mark this cell with negative number to indicate how many cells should be skipped when adding the new cells.\n\t\t\t\t\trowColSpansMap[ column ] = -cellWidth;\n\t\t\t\t}\n\t\t\t\t// Store the colspan from reference row.\n\t\t\t\telse if ( isCopyStructure && isReferenceRow ) {\n\t\t\t\t\trowColSpansMap[ column ] = cellWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( let rowIndex = 0; rowIndex < rowsToInsert; rowIndex++ ) {\n\t\t\t\tconst tableRow = writer.createElement( 'tableRow' );\n\n\t\t\t\twriter.insert( tableRow, table, insertAt );\n\n\t\t\t\tfor ( let cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++ ) {\n\t\t\t\t\tconst colspan = rowColSpansMap[ cellIndex ];\n\t\t\t\t\tconst insertPosition = writer.createPositionAt( tableRow, 'end' );\n\n\t\t\t\t\t// Insert the empty cell only if this slot is not row-spanned from any other cell.\n\t\t\t\t\tif ( colspan > 0 ) {\n\t\t\t\t\t\tcreateEmptyTableCell( writer, insertPosition, colspan > 1 ? { colspan } : null );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip the col-spanned slots, there won't be any cells.\n\t\t\t\t\tcellIndex += Math.abs( colspan ) - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Inserts columns into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\t0   1   2   3                   0   1   2   3   4   5\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| a     | b |                   | a             | b |\n\t *\t\t+       +---+                   +               +---+\n\t *\t\t|       | c |                   |               | c |\n\t *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n\t *\t\t| d | e | f |                   | d |   |   | e | f |\n\t *\t\t+---+   +---+                   +---+---+---+   +---+\n\t *\t\t| g |   | h |                   | g |   |   |   | h |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| i         |                   | i                 |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] The column index at which the columns will be inserted.\n\t * @param {Number} [options.columns=1] The number of columns to insert.\n\t */\n\tinsertColumns( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst columnsToInsert = options.columns || 1;\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' );\n\n\t\t\t// Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\t\t\tif ( insertAt < headingColumns ) {\n\t\t\t\twriter.setAttribute( 'headingColumns', headingColumns + columnsToInsert, table );\n\t\t\t}\n\n\t\t\tconst tableColumns = this.getColumns( table );\n\n\t\t\t// Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( insertAt === 0 || tableColumns === insertAt ) {\n\t\t\t\tfor ( const tableRow of table.getChildren() ) {\n\t\t\t\t\t// Ignore non-row elements inside the table (e.g. caption).\n\t\t\t\t\tif ( !tableRow.is( 'element', 'tableRow' ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcreateCells( columnsToInsert, writer, writer.createPositionAt( tableRow, insertAt ? 'end' : 0 ) );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tableWalker = new TableWalker( table, { column: insertAt, includeAllSlots: true } );\n\n\t\t\tfor ( const tableSlot of tableWalker ) {\n\t\t\t\tconst { row, cell, cellAnchorColumn, cellAnchorRow, cellWidth, cellHeight } = tableSlot;\n\n\t\t\t\t// When iterating over column the table walker outputs either:\n\t\t\t\t// - cells at given column index (cell \"e\" from method docs),\n\t\t\t\t// - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeAllSlots: true`),\n\t\t\t\t// - or a cell from the same row which spans over this column (cell \"a\").\n\n\t\t\t\tif ( cellAnchorColumn < insertAt ) {\n\t\t\t\t\t// If cell is anchored in previous column, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n\t\t\t\t\t// For such cells expand them by a number of columns inserted.\n\t\t\t\t\twriter.setAttribute( 'colspan', cellWidth + columnsToInsert, cell );\n\n\t\t\t\t\t// This cell will overlap cells in rows below so skip them (because of `includeAllSlots` option) - (cell \"a\")\n\t\t\t\t\tconst lastCellRow = cellAnchorRow + cellHeight - 1;\n\n\t\t\t\t\tfor ( let i = row; i <= lastCellRow; i++ ) {\n\t\t\t\t\t\ttableWalker.skipRow( i );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// It's either cell at this column index or spanned cell by a row-spanned cell from row above.\n\t\t\t\t\t// In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n\t\t\t\t\tcreateCells( columnsToInsert, writer, tableSlot.getPositionBefore() );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Removes rows from the given `table`.\n\t *\n\t * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows\n\t * and table headings values.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );\n\t *\n\t * Executing the above code in the context of the table on the left will transform its structure as presented on the right:\n\t *\n\t *\t\trow index\n\t *\t\t    ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐\n\t *\t\t  0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0\n\t *\t\t    │   ├───┼───┤                        │   ├───┼───┤\n\t *\t\t  1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1\n\t *\t\t    │   │   ├───┤        will give:      ├───┼───┼───┤\n\t *\t\t  2 │   │   │ f │                        │ h │ i │ j │ 2\n\t *\t\t    │   │   ├───┤                        └───┴───┴───┘\n\t *\t\t  3 │   │   │ g │\n\t *\t\t    ├───┼───┼───┤\n\t *\t\t  4 │ h │ i │ j │\n\t *\t\t    └───┴───┴───┘\n\t *\n\t * @param {module:engine/model/element~Element} table\n\t * @param {Object} options\n\t * @param {Number} options.at The row index at which the removing rows will start.\n\t * @param {Number} [options.rows=1] The number of rows to remove.\n\t */\n\tremoveRows( table, options ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst rowsToRemove = options.rows || 1;\n\t\tconst rowCount = this.getRows( table );\n\t\tconst first = options.at;\n\t\tconst last = first + rowsToRemove - 1;\n\n\t\tif ( last > rowCount - 1 ) {\n\t\t\t/**\n\t\t\t * The `options.at` param must point at existing row and `options.rows` must not exceed the rows in the table.\n\t\t\t *\n\t\t\t * @error tableutils-removerows-row-index-out-of-range\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'tableutils-removerows-row-index-out-of-range',\n\t\t\t\tthis,\n\t\t\t\t{ table, options }\n\t\t\t);\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\t// Removing rows from the table require that most calculations to be done prior to changing table structure.\n\t\t\t// Preparations must be done in the same enqueueChange callback to use the current table structure.\n\n\t\t\t// 1. Preparation - get row-spanned cells that have to be modified after removing rows.\n\t\t\tconst { cellsToMove, cellsToTrim } = getCellsToMoveAndTrimOnRemoveRow( table, first, last );\n\n\t\t\t// 2. Execution\n\n\t\t\t// 2a. Move cells from removed rows that extends over a removed section - must be done before removing rows.\n\t\t\t// This will fill any gaps in a rows below that previously were empty because of row-spanned cells.\n\t\t\tif ( cellsToMove.size ) {\n\t\t\t\tconst rowAfterRemovedSection = last + 1;\n\t\t\t\tmoveCellsToRow( table, rowAfterRemovedSection, cellsToMove, writer );\n\t\t\t}\n\n\t\t\t// 2b. Remove all required rows.\n\t\t\tfor ( let i = last; i >= first; i-- ) {\n\t\t\t\twriter.remove( table.getChild( i ) );\n\t\t\t}\n\n\t\t\t// 2c. Update cells from rows above that overlap removed section. Similar to step 2 but does not involve moving cells.\n\t\t\tfor ( const { rowspan, cell } of cellsToTrim ) {\n\t\t\t\tupdateNumericAttribute( 'rowspan', rowspan, cell, writer );\n\t\t\t}\n\n\t\t\t// 2d. Adjust heading rows if removed rows were in a heading section.\n\t\t\tupdateHeadingRows( table, first, last, writer );\n\n\t\t\t// 2e. Remove empty columns (without anchored cells) if there are any.\n\t\t\tif ( !removeEmptyColumns( table, this ) ) {\n\t\t\t\t// If there wasn't any empty columns then we still need to check if this wasn't called\n\t\t\t\t// because of cleaning empty rows and we only removed one of them.\n\t\t\t\tremoveEmptyRows( table, this );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Removes columns from the given `table`.\n\t *\n\t * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns\n\t * and table headings values.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );\n\t *\n\t * Executing the above code in the context of the table on the left will transform its structure as presented on the right:\n\t *\n\t *\t\t  0   1   2   3   4                       0   1   2\n\t *\t\t┌───────────────┬───┐                   ┌───────┬───┐\n\t *\t\t│ a             │ b │                   │ a     │ b │\n\t *\t\t│               ├───┤                   │       ├───┤\n\t *\t\t│               │ c │                   │       │ c │\n\t *\t\t├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤\n\t *\t\t│ d │ e │ f │ g │ h │                   │ d │ g │ h │\n\t *\t\t├───┼───┼───┤   ├───┤                   ├───┤   ├───┤\n\t *\t\t│ i │ j │ k │   │ l │                   │ i │   │ l │\n\t *\t\t├───┴───┴───┴───┴───┤                   ├───┴───┴───┤\n\t *\t\t│ m                 │                   │ m         │\n\t *\t\t└───────────────────┘                   └───────────┘\n\t *\t\t      ^---- remove from here, `at` = 1, `columns` = 2\n\t *\n\t * @param {module:engine/model/element~Element} table\n\t * @param {Object} options\n\t * @param {Number} options.at The row index at which the removing columns will start.\n\t * @param {Number} [options.columns=1] The number of columns to remove.\n\t */\n\tremoveColumns( table, options ) {\n\t\tconst model = this.editor.model;\n\t\tconst first = options.at;\n\t\tconst columnsToRemove = options.columns || 1;\n\t\tconst last = options.at + columnsToRemove - 1;\n\n\t\tmodel.change( writer => {\n\t\t\tadjustHeadingColumns( table, { first, last }, writer );\n\n\t\t\tfor ( let removedColumnIndex = last; removedColumnIndex >= first; removedColumnIndex-- ) {\n\t\t\t\tfor ( const { cell, column, cellWidth } of [ ...new TableWalker( table ) ] ) {\n\t\t\t\t\t// If colspaned cell overlaps removed column decrease its span.\n\t\t\t\t\tif ( column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex ) {\n\t\t\t\t\t\tupdateNumericAttribute( 'colspan', cellWidth - 1, cell, writer );\n\t\t\t\t\t} else if ( column === removedColumnIndex ) {\n\t\t\t\t\t\t// The cell in removed column has colspan of 1.\n\t\t\t\t\t\twriter.remove( cell );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove empty rows that could appear after removing columns.\n\t\t\tif ( !removeEmptyRows( table, this ) ) {\n\t\t\t\t// If there wasn't any empty rows then we still need to check if this wasn't called\n\t\t\t\t// because of cleaning empty columns and we only removed one of them.\n\t\t\t\tremoveEmptyColumns( table, this );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell vertically into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating colspans of other cells in a column\n\t * and inserting cells (columns) after that cell.\n\t *\n\t * In the table below, if cell \"a\" is split into 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * it will result in the table below:\n\t *\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| a |   |   | b | c |\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| d         | e | f |\n\t *\t\t+---+---+---+---+---+\n\t *\n\t * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n\t *\n\t * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a         |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a     |   |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellVertically( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( colspan > 1 ) {\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( colspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'colspan', updatedSpan, tableCell, writer );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tconst cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\t\t\t}\n\n\t\t\t// Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\t\t\tif ( colspan < numberOfCells ) {\n\t\t\t\tconst cellsToInsert = numberOfCells - colspan;\n\n\t\t\t\t// First step: expand cells on the same column as split cell.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table ) ];\n\n\t\t\t\t// Get the column index of split cell.\n\t\t\t\tconst { column: splitCellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\t\t\t\tconst cellsToUpdate = tableMap.filter( ( { cell, cellWidth, column } ) => {\n\t\t\t\t\tconst isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n\t\t\t\t\tconst spansOverColumn = ( column < splitCellColumn && column + cellWidth > splitCellColumn );\n\n\t\t\t\t\treturn isOnSameColumn || spansOverColumn;\n\t\t\t\t} );\n\n\t\t\t\t// Expand cells vertically.\n\t\t\t\tfor ( const { cell, cellWidth } of cellsToUpdate ) {\n\t\t\t\t\twriter.setAttribute( 'colspan', cellWidth + cellsToInsert, cell );\n\t\t\t\t}\n\n\t\t\t\t// Second step: create columns after split cell.\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\n\t\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' ) || 0;\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tif ( headingColumns > splitCellColumn ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingColumns', headingColumns + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell horizontally into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n\t * below.\n\t *\n\t * If in the table below cell \"b\" is split into 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * It will result in the table below:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n\t *\n\t * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+   +---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+   +---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+---+---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+---+---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellHorizontally( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\t\tconst splitCellRow = table.getChildIndex( tableRow );\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t// Cache table map before updating table.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, {\n\t\t\t\t\tstartRow: splitCellRow,\n\t\t\t\t\tendRow: splitCellRow + rowspan - 1,\n\t\t\t\t\tincludeAllSlots: true\n\t\t\t\t} ) ];\n\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( rowspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'rowspan', updatedSpan, tableCell, writer );\n\n\t\t\t\tconst { column: cellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tfor ( const tableSlot of tableMap ) {\n\t\t\t\t\tconst { column, row } = tableSlot;\n\n\t\t\t\t\t// As both newly created cells and the split cell might have rowspan,\n\t\t\t\t\t// the insertion of new cells must go to appropriate rows:\n\t\t\t\t\t//\n\t\t\t\t\t// 1. It's a row after split cell + it's height.\n\t\t\t\t\tconst isAfterSplitCell = row >= splitCellRow + updatedSpan;\n\t\t\t\t\t// 2. Is on the same column.\n\t\t\t\t\tconst isOnSameColumn = column === cellColumn;\n\t\t\t\t\t// 3. And it's row index is after previous cell height.\n\t\t\t\t\tconst isInEvenlySplitRow = ( row + splitCellRow + updatedSpan ) % newCellsSpan === 0;\n\n\t\t\t\t\tif ( isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow ) {\n\t\t\t\t\t\tcreateCells( 1, writer, tableSlot.getPositionBefore(), newCellsAttributes );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\t\t\tif ( rowspan < numberOfCells ) {\n\t\t\t\t// We already split the cell in check one so here we split to the remaining number of cells only.\n\t\t\t\tconst cellsToInsert = numberOfCells - rowspan;\n\n\t\t\t\t// This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, { startRow: 0, endRow: splitCellRow } ) ];\n\n\t\t\t\t// First step: expand cells.\n\t\t\t\tfor ( const { cell, cellHeight, row } of tableMap ) {\n\t\t\t\t\t// Expand rowspan of cells that are either:\n\t\t\t\t\t// - on the same row as current cell,\n\t\t\t\t\t// - or are below split cell row and overlaps that row.\n\t\t\t\t\tif ( cell !== tableCell && row + cellHeight > splitCellRow ) {\n\t\t\t\t\t\tconst rowspanToSet = cellHeight + cellsToInsert;\n\n\t\t\t\t\t\twriter.setAttribute( 'rowspan', rowspanToSet, cell );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Second step: create rows with single cell below split cell.\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tcreateEmptyRows( writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes );\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t\tif ( headingRows > splitCellRow ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingRows', headingRows + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the number of columns for a given table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n\t *\n\t * @param {module:engine/model/element~Element} table The table to analyze.\n\t * @returns {Number}\n\t */\n\tgetColumns( table ) {\n\t\t// Analyze first row only as all the rows should have the same width.\n\t\t// Using the first row without checking if it's a tableRow because we expect\n\t\t// that table will have only tableRow model elements at the beginning.\n\t\tconst row = table.getChild( 0 );\n\n\t\treturn [ ...row.getChildren() ].reduce( ( columns, row ) => {\n\t\t\tconst columnWidth = parseInt( row.getAttribute( 'colspan' ) || 1 );\n\n\t\t\treturn columns + columnWidth;\n\t\t}, 0 );\n\t}\n\n\t/**\n\t * Returns the number of rows for a given table. Any other element present in the table model is omitted.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).getRows( table );\n\t *\n\t * @param {module:engine/model/element~Element} table The table to analyze.\n\t * @returns {Number}\n\t */\n\tgetRows( table ) {\n\t\t// Rowspan not included due to #6427.\n\t\treturn Array.from( table.getChildren() )\n\t\t\t.reduce( ( rowCount, child ) => child.is( 'element', 'tableRow' ) ? rowCount + 1 : rowCount, 0 );\n\t}\n}\n\n// Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt The row index of row insertion.\n// @param {Number} rows The number of rows to create.\n// @param {Number} tableCellToInsert The number of cells to insert in each row.\nfunction createEmptyRows( writer, table, insertAt, rows, tableCellToInsert, attributes = {} ) {\n\tfor ( let i = 0; i < rows; i++ ) {\n\t\tconst tableRow = writer.createElement( 'tableRow' );\n\n\t\twriter.insert( tableRow, table, insertAt );\n\n\t\tcreateCells( tableCellToInsert, writer, writer.createPositionAt( tableRow, 'end' ), attributes );\n\t}\n}\n\n// Creates cells at a given position.\n//\n// @param {Number} columns The number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\nfunction createCells( cells, writer, insertPosition, attributes = {} ) {\n\tfor ( let i = 0; i < cells; i++ ) {\n\t\tcreateEmptyTableCell( writer, insertPosition, attributes );\n\t}\n}\n\n// Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span The span value do break.\n// @param {Number} numberOfCells The number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\nfunction breakSpanEvenly( span, numberOfCells ) {\n\tif ( span < numberOfCells ) {\n\t\treturn { newCellsSpan: 1, updatedSpan: 1 };\n\t}\n\n\tconst newCellsSpan = Math.floor( span / numberOfCells );\n\tconst updatedSpan = ( span - newCellsSpan * numberOfCells ) + newCellsSpan;\n\n\treturn { newCellsSpan, updatedSpan };\n}\n\n// Updates heading columns attribute if removing a row from head section.\nfunction adjustHeadingColumns( table, removedColumnIndexes, writer ) {\n\tconst headingColumns = table.getAttribute( 'headingColumns' ) || 0;\n\n\tif ( headingColumns && removedColumnIndexes.first < headingColumns ) {\n\t\tconst headingsRemoved = Math.min( headingColumns - 1 /* Other numbers are 0-based */, removedColumnIndexes.last ) -\n\t\t\tremovedColumnIndexes.first + 1;\n\n\t\twriter.setAttribute( 'headingColumns', headingColumns - headingsRemoved, table );\n\t}\n}\n\n// Calculates a new heading rows value for removing rows from heading section.\nfunction updateHeadingRows( table, first, last, writer ) {\n\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\tif ( first < headingRows ) {\n\t\tconst newRows = last < headingRows ? headingRows - ( last - first + 1 ) : first;\n\n\t\tupdateNumericAttribute( 'headingRows', newRows, table, writer, 0 );\n\t}\n}\n\n// Finds cells that will be:\n// - trimmed - Cells that are \"above\" removed rows sections and overlap the removed section - their rowspan must be trimmed.\n// - moved - Cells from removed rows section might stick out of. These cells are moved to the next row after a removed section.\n//\n// Sample table with overlapping & sticking out cells:\n//\n//      +----+----+----+----+----+\n//      | 00 | 01 | 02 | 03 | 04 |\n//      +----+    +    +    +    +\n//      | 10 |    |    |    |    |\n//      +----+----+    +    +    +\n//      | 20 | 21 |    |    |    | <-- removed row\n//      +    +    +----+    +    +\n//      |    |    | 32 |    |    | <-- removed row\n//      +----+    +    +----+    +\n//      | 40 |    |    | 43 |    |\n//      +----+----+----+----+----+\n//\n// In a table above:\n// - cells to trim: '02', '03' & '04'.\n// - cells to move: '21' & '32'.\nfunction getCellsToMoveAndTrimOnRemoveRow( table, first, last ) {\n\tconst cellsToMove = new Map();\n\tconst cellsToTrim = [];\n\n\tfor ( const { row, column, cellHeight, cell } of new TableWalker( table, { endRow: last } ) ) {\n\t\tconst lastRowOfCell = row + cellHeight - 1;\n\n\t\tconst isCellStickingOutFromRemovedRows = row >= first && row <= last && lastRowOfCell > last;\n\n\t\tif ( isCellStickingOutFromRemovedRows ) {\n\t\t\tconst rowspanInRemovedSection = last - row + 1;\n\t\t\tconst rowSpanToSet = cellHeight - rowspanInRemovedSection;\n\n\t\t\tcellsToMove.set( column, {\n\t\t\t\tcell,\n\t\t\t\trowspan: rowSpanToSet\n\t\t\t} );\n\t\t}\n\n\t\tconst isCellOverlappingRemovedRows = row < first && lastRowOfCell >= first;\n\n\t\tif ( isCellOverlappingRemovedRows ) {\n\t\t\tlet rowspanAdjustment;\n\n\t\t\t// Cell fully covers removed section - trim it by removed rows count.\n\t\t\tif ( lastRowOfCell >= last ) {\n\t\t\t\trowspanAdjustment = last - first + 1;\n\t\t\t}\n\t\t\t// Cell partially overlaps removed section - calculate cell's span that is in removed section.\n\t\t\telse {\n\t\t\t\trowspanAdjustment = lastRowOfCell - first + 1;\n\t\t\t}\n\n\t\t\tcellsToTrim.push( {\n\t\t\t\tcell,\n\t\t\t\trowspan: cellHeight - rowspanAdjustment\n\t\t\t} );\n\t\t}\n\t}\n\treturn { cellsToMove, cellsToTrim };\n}\n\nfunction moveCellsToRow( table, targetRowIndex, cellsToMove, writer ) {\n\tconst tableWalker = new TableWalker( table, {\n\t\tincludeAllSlots: true,\n\t\trow: targetRowIndex\n\t} );\n\n\tconst tableRowMap = [ ...tableWalker ];\n\tconst row = table.getChild( targetRowIndex );\n\n\tlet previousCell;\n\n\tfor ( const { column, cell, isAnchor } of tableRowMap ) {\n\t\tif ( cellsToMove.has( column ) ) {\n\t\t\tconst { cell: cellToMove, rowspan } = cellsToMove.get( column );\n\n\t\t\tconst targetPosition = previousCell ?\n\t\t\t\twriter.createPositionAfter( previousCell ) :\n\t\t\t\twriter.createPositionAt( row, 0 );\n\n\t\t\twriter.move( writer.createRangeOn( cellToMove ), targetPosition );\n\t\t\tupdateNumericAttribute( 'rowspan', rowspan, cellToMove, writer );\n\n\t\t\tpreviousCell = cellToMove;\n\t\t} else if ( isAnchor ) {\n\t\t\t// If cell is spanned then `cell` holds reference to overlapping cell. See ckeditor/ckeditor5#6502.\n\t\t\tpreviousCell = cell;\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}
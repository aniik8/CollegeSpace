{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagecaption/imagecaptionediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Element, enablePlaceholder } from 'ckeditor5/src/engine';\nimport { toWidgetEditable } from 'ckeditor5/src/widget';\nimport ToggleImageCaptionCommand from './toggleimagecaptioncommand';\nimport ImageUtils from '../imageutils';\nimport { getCaptionFromImageModelElement, matchImageCaptionViewElement } from './utils';\n/**\n * The image caption engine plugin. It is responsible for:\n *\n * * registering converters for the caption element,\n * * registering converters for the caption model attribute,\n * * registering the {@link module:image/imagecaption/toggleimagecaptioncommand~ToggleImageCaptionCommand `toggleImageCaption`} command.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageCaptionEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [ImageUtils];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'ImageCaptionEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    /**\n     * A map that keeps saved JSONified image captions and image model elements they are\n     * associated with.\n     *\n     * To learn more about this system, see {@link #_saveCaption}.\n     *\n     * @member {WeakMap.<module:engine/model/element~Element,Object>}\n     */\n\n    this._savedCaptionsMap = new WeakMap();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const schema = editor.model.schema; // Schema configuration.\n\n    if (!schema.isRegistered('caption')) {\n      schema.register('caption', {\n        allowIn: 'imageBlock',\n        allowContentOf: '$block',\n        isLimit: true\n      });\n    } else {\n      schema.extend('caption', {\n        allowIn: 'imageBlock'\n      });\n    }\n\n    editor.commands.add('toggleImageCaption', new ToggleImageCaptionCommand(this.editor));\n\n    this._setupConversion();\n\n    this._setupImageTypeCommandsIntegration();\n  }\n  /**\n   * Configures conversion pipelines to support upcasting and downcasting\n   * image captions.\n   *\n   * @private\n   */\n\n\n  _setupConversion() {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const t = editor.t; // View -> model converter for the data pipeline.\n\n    editor.conversion.for('upcast').elementToElement({\n      view: element => matchImageCaptionViewElement(imageUtils, element),\n      model: 'caption'\n    }); // Model -> view converter for the data pipeline.\n\n    editor.conversion.for('dataDowncast').elementToElement({\n      model: 'caption',\n      view: (modelElement, _ref) => {\n        let {\n          writer\n        } = _ref;\n\n        if (!imageUtils.isBlockImage(modelElement.parent)) {\n          return null;\n        }\n\n        return writer.createContainerElement('figcaption');\n      }\n    }); // Model -> view converter for the editing pipeline.\n\n    editor.conversion.for('editingDowncast').elementToElement({\n      model: 'caption',\n      view: (modelElement, _ref2) => {\n        let {\n          writer\n        } = _ref2;\n\n        if (!imageUtils.isBlockImage(modelElement.parent)) {\n          return null;\n        }\n\n        const figcaptionElement = writer.createEditableElement('figcaption');\n        writer.setCustomProperty('imageCaption', true, figcaptionElement);\n        enablePlaceholder({\n          view,\n          element: figcaptionElement,\n          text: t('Enter image caption'),\n          keepOnFocus: true\n        });\n        return toWidgetEditable(figcaptionElement, writer);\n      }\n    });\n    editor.editing.mapper.on('modelToViewPosition', mapModelPositionToView(view));\n    editor.data.mapper.on('modelToViewPosition', mapModelPositionToView(view));\n  }\n  /**\n   * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}\n   * to make sure the caption is preserved when the type of an image changes so it can be restored\n   * in the future if the user decides they want their caption back.\n   *\n   * @private\n   */\n\n\n  _setupImageTypeCommandsIntegration() {\n    const editor = this.editor;\n    const imageUtils = editor.plugins.get('ImageUtils');\n    const imageTypeInlineCommand = editor.commands.get('imageTypeInline');\n    const imageTypeBlockCommand = editor.commands.get('imageTypeBlock');\n\n    const handleImageTypeChange = evt => {\n      // The image type command execution can be unsuccessful.\n      if (!evt.return) {\n        return;\n      }\n\n      const {\n        oldElement,\n        newElement\n      } = evt.return;\n      /* istanbul ignore if: paranoid check */\n\n      if (!oldElement) {\n        return;\n      }\n\n      if (imageUtils.isBlockImage(oldElement)) {\n        const oldCaptionElement = getCaptionFromImageModelElement(oldElement); // If the old element was a captioned block image (the caption was visible),\n        // simply save it so it can be restored.\n\n        if (oldCaptionElement) {\n          this._saveCaption(newElement, oldCaptionElement);\n\n          return;\n        }\n      }\n\n      const savedOldElementCaption = this._getSavedCaption(oldElement); // If either:\n      //\n      // * the block image didn't have a visible caption,\n      // * the block image caption was hidden (and already saved),\n      // * the inline image was passed\n      //\n      // just try to \"pass\" the saved caption from the old image to the new image\n      // so it can be retrieved in the future if the user wants it back.\n\n\n      if (savedOldElementCaption) {\n        // Note: Since we're writing to a WeakMap, we don't bother with removing the\n        // [ oldElement, savedOldElementCaption ] pair from it.\n        this._saveCaption(newElement, savedOldElementCaption);\n      }\n    }; // Presence of the commands depends on the Image(Inline|Block)Editing plugins loaded in the editor.\n\n\n    if (imageTypeInlineCommand) {\n      this.listenTo(imageTypeInlineCommand, 'execute', handleImageTypeChange, {\n        priority: 'low'\n      });\n    }\n\n    if (imageTypeBlockCommand) {\n      this.listenTo(imageTypeBlockCommand, 'execute', handleImageTypeChange, {\n        priority: 'low'\n      });\n    }\n  }\n  /**\n   * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption\n   * of an image model element.\n   *\n   * See {@link #_saveCaption}.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} imageModelElement The model element the\n   * caption should be returned for.\n   * @returns {module:engine/model/element~Element|null} The model caption element or `null` if there is none.\n   */\n\n\n  _getSavedCaption(imageModelElement) {\n    const jsonObject = this._savedCaptionsMap.get(imageModelElement);\n\n    return jsonObject ? Element.fromJSON(jsonObject) : null;\n  }\n  /**\n   * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for\n   * an image element to allow restoring it in the future.\n   *\n   * A caption is saved every time it gets hidden and/or the type of an image changes. The\n   * user should be able to restore it on demand.\n   *\n   * **Note**: The caption cannot be stored in the image model element attribute because,\n   * for instance, when the model state propagates to collaborators, the attribute would get\n   * lost (mainly because it does not convert to anything when the caption is hidden) and\n   * the states of collaborators' models would de-synchronize causing numerous issues.\n   *\n   * See {@link #_getSavedCaption}.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} imageModelElement The model element the\n   * caption is saved for.\n   * @param {module:engine/model/element~Element} caption The caption model element to be saved.\n   */\n\n\n  _saveCaption(imageModelElement, caption) {\n    this._savedCaptionsMap.set(imageModelElement, caption.toJSON());\n  }\n\n} // Creates a mapper callback that reverses the order of `<img>` and `<figcaption>` in the image.\n// Without it, `<figcaption>` would precede the `<img>` in the conversion.\n//\n// <imageBlock>^</imageBlock> -> <figure><img>^<caption></caption></figure>\n//\n// @private\n// @param {module:engine/view/view~View} editingView\n// @returns {Function}\n\nfunction mapModelPositionToView(editingView) {\n  return (evt, data) => {\n    const modelPosition = data.modelPosition;\n    const parent = modelPosition.parent;\n\n    if (!parent.is('element', 'imageBlock')) {\n      return;\n    }\n\n    const viewElement = data.mapper.toViewElement(parent); // The \"img\" element is inserted by ImageBlockEditing during the downcast conversion via\n    // an explicit view position so the \"0\" position does not need any mapping.\n\n    data.viewPosition = editingView.createPositionAt(viewElement, modelPosition.offset + 1);\n  };\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionediting.js"],"names":["Plugin","Element","enablePlaceholder","toWidgetEditable","ToggleImageCaptionCommand","ImageUtils","getCaptionFromImageModelElement","matchImageCaptionViewElement","ImageCaptionEditing","requires","pluginName","constructor","editor","_savedCaptionsMap","WeakMap","init","schema","model","isRegistered","register","allowIn","allowContentOf","isLimit","extend","commands","add","_setupConversion","_setupImageTypeCommandsIntegration","view","editing","imageUtils","plugins","get","t","conversion","for","elementToElement","element","modelElement","writer","isBlockImage","parent","createContainerElement","figcaptionElement","createEditableElement","setCustomProperty","text","keepOnFocus","mapper","on","mapModelPositionToView","data","imageTypeInlineCommand","imageTypeBlockCommand","handleImageTypeChange","evt","return","oldElement","newElement","oldCaptionElement","_saveCaption","savedOldElementCaption","_getSavedCaption","listenTo","priority","imageModelElement","jsonObject","fromJSON","caption","set","toJSON","editingView","modelPosition","is","viewElement","toViewElement","viewPosition","createPositionAt","offset"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagecaption/imagecaptionediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Element, enablePlaceholder } from 'ckeditor5/src/engine';\nimport { toWidgetEditable } from 'ckeditor5/src/widget';\n\nimport ToggleImageCaptionCommand from './toggleimagecaptioncommand';\n\nimport ImageUtils from '../imageutils';\nimport { getCaptionFromImageModelElement, matchImageCaptionViewElement } from './utils';\n\n/**\n * The image caption engine plugin. It is responsible for:\n *\n * * registering converters for the caption element,\n * * registering converters for the caption model attribute,\n * * registering the {@link module:image/imagecaption/toggleimagecaptioncommand~ToggleImageCaptionCommand `toggleImageCaption`} command.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageCaptionEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ImageUtils ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ImageCaptionEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A map that keeps saved JSONified image captions and image model elements they are\n\t\t * associated with.\n\t\t *\n\t\t * To learn more about this system, see {@link #_saveCaption}.\n\t\t *\n\t\t * @member {WeakMap.<module:engine/model/element~Element,Object>}\n\t\t */\n\t\tthis._savedCaptionsMap = new WeakMap();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\n\t\t// Schema configuration.\n\t\tif ( !schema.isRegistered( 'caption' ) ) {\n\t\t\tschema.register( 'caption', {\n\t\t\t\tallowIn: 'imageBlock',\n\t\t\t\tallowContentOf: '$block',\n\t\t\t\tisLimit: true\n\t\t\t} );\n\t\t} else {\n\t\t\tschema.extend( 'caption', {\n\t\t\t\tallowIn: 'imageBlock'\n\t\t\t} );\n\t\t}\n\n\t\teditor.commands.add( 'toggleImageCaption', new ToggleImageCaptionCommand( this.editor ) );\n\n\t\tthis._setupConversion();\n\t\tthis._setupImageTypeCommandsIntegration();\n\t}\n\n\t/**\n\t * Configures conversion pipelines to support upcasting and downcasting\n\t * image captions.\n\t *\n\t * @private\n\t */\n\t_setupConversion() {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst t = editor.t;\n\n\t\t// View -> model converter for the data pipeline.\n\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t\t\tview: element => matchImageCaptionViewElement( imageUtils, element ),\n\t\t\tmodel: 'caption'\n\t\t} );\n\n\t\t// Model -> view converter for the data pipeline.\n\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( {\n\t\t\tmodel: 'caption',\n\t\t\tview: ( modelElement, { writer } ) => {\n\t\t\t\tif ( !imageUtils.isBlockImage( modelElement.parent ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn writer.createContainerElement( 'figcaption' );\n\t\t\t}\n\t\t} );\n\n\t\t// Model -> view converter for the editing pipeline.\n\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( {\n\t\t\tmodel: 'caption',\n\t\t\tview: ( modelElement, { writer } ) => {\n\t\t\t\tif ( !imageUtils.isBlockImage( modelElement.parent ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst figcaptionElement = writer.createEditableElement( 'figcaption' );\n\t\t\t\twriter.setCustomProperty( 'imageCaption', true, figcaptionElement );\n\n\t\t\t\tenablePlaceholder( {\n\t\t\t\t\tview,\n\t\t\t\t\telement: figcaptionElement,\n\t\t\t\t\ttext: t( 'Enter image caption' ),\n\t\t\t\t\tkeepOnFocus: true\n\t\t\t\t} );\n\n\t\t\t\treturn toWidgetEditable( figcaptionElement, writer );\n\t\t\t}\n\t\t} );\n\n\t\teditor.editing.mapper.on( 'modelToViewPosition', mapModelPositionToView( view ) );\n\t\teditor.data.mapper.on( 'modelToViewPosition', mapModelPositionToView( view ) );\n\t}\n\n\t/**\n\t * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}\n\t * to make sure the caption is preserved when the type of an image changes so it can be restored\n\t * in the future if the user decides they want their caption back.\n\t *\n\t * @private\n\t */\n\t_setupImageTypeCommandsIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst imageUtils = editor.plugins.get( 'ImageUtils' );\n\t\tconst imageTypeInlineCommand = editor.commands.get( 'imageTypeInline' );\n\t\tconst imageTypeBlockCommand = editor.commands.get( 'imageTypeBlock' );\n\n\t\tconst handleImageTypeChange = evt => {\n\t\t\t// The image type command execution can be unsuccessful.\n\t\t\tif ( !evt.return ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { oldElement, newElement } = evt.return;\n\n\t\t\t/* istanbul ignore if: paranoid check */\n\t\t\tif ( !oldElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( imageUtils.isBlockImage( oldElement ) ) {\n\t\t\t\tconst oldCaptionElement = getCaptionFromImageModelElement( oldElement );\n\n\t\t\t\t// If the old element was a captioned block image (the caption was visible),\n\t\t\t\t// simply save it so it can be restored.\n\t\t\t\tif ( oldCaptionElement ) {\n\t\t\t\t\tthis._saveCaption( newElement, oldCaptionElement );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst savedOldElementCaption = this._getSavedCaption( oldElement );\n\n\t\t\t// If either:\n\t\t\t//\n\t\t\t// * the block image didn't have a visible caption,\n\t\t\t// * the block image caption was hidden (and already saved),\n\t\t\t// * the inline image was passed\n\t\t\t//\n\t\t\t// just try to \"pass\" the saved caption from the old image to the new image\n\t\t\t// so it can be retrieved in the future if the user wants it back.\n\t\t\tif ( savedOldElementCaption ) {\n\t\t\t\t// Note: Since we're writing to a WeakMap, we don't bother with removing the\n\t\t\t\t// [ oldElement, savedOldElementCaption ] pair from it.\n\t\t\t\tthis._saveCaption( newElement, savedOldElementCaption );\n\t\t\t}\n\t\t};\n\n\t\t// Presence of the commands depends on the Image(Inline|Block)Editing plugins loaded in the editor.\n\t\tif ( imageTypeInlineCommand ) {\n\t\t\tthis.listenTo( imageTypeInlineCommand, 'execute', handleImageTypeChange, { priority: 'low' } );\n\t\t}\n\n\t\tif ( imageTypeBlockCommand ) {\n\t\t\tthis.listenTo( imageTypeBlockCommand, 'execute', handleImageTypeChange, { priority: 'low' } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption\n\t * of an image model element.\n\t *\n\t * See {@link #_saveCaption}.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} imageModelElement The model element the\n\t * caption should be returned for.\n\t * @returns {module:engine/model/element~Element|null} The model caption element or `null` if there is none.\n\t */\n\t_getSavedCaption( imageModelElement ) {\n\t\tconst jsonObject = this._savedCaptionsMap.get( imageModelElement );\n\n\t\treturn jsonObject ? Element.fromJSON( jsonObject ) : null;\n\t}\n\n\t/**\n\t * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for\n\t * an image element to allow restoring it in the future.\n\t *\n\t * A caption is saved every time it gets hidden and/or the type of an image changes. The\n\t * user should be able to restore it on demand.\n\t *\n\t * **Note**: The caption cannot be stored in the image model element attribute because,\n\t * for instance, when the model state propagates to collaborators, the attribute would get\n\t * lost (mainly because it does not convert to anything when the caption is hidden) and\n\t * the states of collaborators' models would de-synchronize causing numerous issues.\n\t *\n\t * See {@link #_getSavedCaption}.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} imageModelElement The model element the\n\t * caption is saved for.\n\t * @param {module:engine/model/element~Element} caption The caption model element to be saved.\n\t */\n\t_saveCaption( imageModelElement, caption ) {\n\t\tthis._savedCaptionsMap.set( imageModelElement, caption.toJSON() );\n\t}\n}\n\n// Creates a mapper callback that reverses the order of `<img>` and `<figcaption>` in the image.\n// Without it, `<figcaption>` would precede the `<img>` in the conversion.\n//\n// <imageBlock>^</imageBlock> -> <figure><img>^<caption></caption></figure>\n//\n// @private\n// @param {module:engine/view/view~View} editingView\n// @returns {Function}\nfunction mapModelPositionToView( editingView ) {\n\treturn ( evt, data ) => {\n\t\tconst modelPosition = data.modelPosition;\n\t\tconst parent = modelPosition.parent;\n\n\t\tif ( !parent.is( 'element', 'imageBlock' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = data.mapper.toViewElement( parent );\n\n\t\t// The \"img\" element is inserted by ImageBlockEditing during the downcast conversion via\n\t\t// an explicit view position so the \"0\" position does not need any mapping.\n\t\tdata.viewPosition = editingView.createPositionAt( viewElement, modelPosition.offset + 1 );\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}
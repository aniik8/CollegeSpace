{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-heading-rows-refresh-post-fixer\n */\n\n/**\n * Injects a table post-fixer into the model which marks the table in the differ to have it re-rendered.\n *\n * Table heading rows are represented in the model by a `headingRows` attribute. However, in the view, it's represented as separate\n * sections of the table (`<thead>` or `<tbody>`) and changing `headingRows` attribute requires moving table rows between two sections.\n * This causes problems with structural changes in a table (like adding and removing rows) thus atomic converters cannot be used.\n *\n * When table `headingRows` attribute changes, the entire table is re-rendered.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableHeadingRowsRefreshPostFixer(model) {\n  model.document.registerPostFixer(() => tableHeadingRowsRefreshPostFixer(model));\n}\n\nfunction tableHeadingRowsRefreshPostFixer(model) {\n  const differ = model.document.differ; // Stores tables to be refreshed so the table will be refreshed once for multiple changes.\n\n  const tablesToRefresh = new Set();\n\n  for (const change of differ.getChanges()) {\n    if (change.type === 'attribute') {\n      const element = change.range.start.nodeAfter;\n\n      if (element && element.is('element', 'table') && change.attributeKey === 'headingRows') {\n        tablesToRefresh.add(element);\n      }\n    } else {\n      /* istanbul ignore else */\n      if (change.type === 'insert' || change.type === 'remove') {\n        if (change.name === 'tableRow') {\n          const table = change.position.findAncestor('table');\n          const headingRows = table.getAttribute('headingRows') || 0;\n\n          if (change.position.offset < headingRows) {\n            tablesToRefresh.add(table);\n          }\n        } else if (change.name === 'tableCell') {\n          const table = change.position.findAncestor('table');\n          const headingColumns = table.getAttribute('headingColumns') || 0;\n\n          if (change.position.offset < headingColumns) {\n            tablesToRefresh.add(table);\n          }\n        }\n      }\n    }\n  }\n\n  if (tablesToRefresh.size) {\n    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: refreshing heading rows (${ tablesToRefresh.size }).` );\n    for (const table of tablesToRefresh.values()) {\n      // Should be handled by a `triggerBy` configuration. See: https://github.com/ckeditor/ckeditor5/issues/8138.\n      differ.refreshItem(table);\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/converters/table-heading-rows-refresh-post-fixer.js"],"names":["injectTableHeadingRowsRefreshPostFixer","model","document","registerPostFixer","tableHeadingRowsRefreshPostFixer","differ","tablesToRefresh","Set","change","getChanges","type","element","range","start","nodeAfter","is","attributeKey","add","name","table","position","findAncestor","headingRows","getAttribute","offset","headingColumns","size","values","refreshItem"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,sCAAT,CAAiDC,KAAjD,EAAyD;AACvEA,EAAAA,KAAK,CAACC,QAAN,CAAeC,iBAAf,CAAkC,MAAMC,gCAAgC,CAAEH,KAAF,CAAxE;AACA;;AAED,SAASG,gCAAT,CAA2CH,KAA3C,EAAmD;AAClD,QAAMI,MAAM,GAAGJ,KAAK,CAACC,QAAN,CAAeG,MAA9B,CADkD,CAGlD;;AACA,QAAMC,eAAe,GAAG,IAAIC,GAAJ,EAAxB;;AAEA,OAAM,MAAMC,MAAZ,IAAsBH,MAAM,CAACI,UAAP,EAAtB,EAA4C;AAC3C,QAAKD,MAAM,CAACE,IAAP,KAAgB,WAArB,EAAmC;AAClC,YAAMC,OAAO,GAAGH,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmBC,SAAnC;;AAEA,UAAKH,OAAO,IAAIA,OAAO,CAACI,EAAR,CAAY,SAAZ,EAAuB,OAAvB,CAAX,IAA+CP,MAAM,CAACQ,YAAP,KAAwB,aAA5E,EAA4F;AAC3FV,QAAAA,eAAe,CAACW,GAAhB,CAAqBN,OAArB;AACA;AACD,KAND,MAMO;AACN;AACA,UAAKH,MAAM,CAACE,IAAP,KAAgB,QAAhB,IAA4BF,MAAM,CAACE,IAAP,KAAgB,QAAjD,EAA4D;AAC3D,YAAKF,MAAM,CAACU,IAAP,KAAgB,UAArB,EAAkC;AACjC,gBAAMC,KAAK,GAAGX,MAAM,CAACY,QAAP,CAAgBC,YAAhB,CAA8B,OAA9B,CAAd;AACA,gBAAMC,WAAW,GAAGH,KAAK,CAACI,YAAN,CAAoB,aAApB,KAAuC,CAA3D;;AAEA,cAAKf,MAAM,CAACY,QAAP,CAAgBI,MAAhB,GAAyBF,WAA9B,EAA4C;AAC3ChB,YAAAA,eAAe,CAACW,GAAhB,CAAqBE,KAArB;AACA;AACD,SAPD,MAOO,IAAKX,MAAM,CAACU,IAAP,KAAgB,WAArB,EAAmC;AACzC,gBAAMC,KAAK,GAAGX,MAAM,CAACY,QAAP,CAAgBC,YAAhB,CAA8B,OAA9B,CAAd;AACA,gBAAMI,cAAc,GAAGN,KAAK,CAACI,YAAN,CAAoB,gBAApB,KAA0C,CAAjE;;AAEA,cAAKf,MAAM,CAACY,QAAP,CAAgBI,MAAhB,GAAyBC,cAA9B,EAA+C;AAC9CnB,YAAAA,eAAe,CAACW,GAAhB,CAAqBE,KAArB;AACA;AACD;AACD;AACD;AACD;;AAED,MAAKb,eAAe,CAACoB,IAArB,EAA4B;AAC3B;AAEA,SAAM,MAAMP,KAAZ,IAAqBb,eAAe,CAACqB,MAAhB,EAArB,EAAgD;AAC/C;AACAtB,MAAAA,MAAM,CAACuB,WAAP,CAAoBT,KAApB;AACA;;AAED,WAAO,IAAP;AACA;;AAED,SAAO,KAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-heading-rows-refresh-post-fixer\n */\n\n/**\n * Injects a table post-fixer into the model which marks the table in the differ to have it re-rendered.\n *\n * Table heading rows are represented in the model by a `headingRows` attribute. However, in the view, it's represented as separate\n * sections of the table (`<thead>` or `<tbody>`) and changing `headingRows` attribute requires moving table rows between two sections.\n * This causes problems with structural changes in a table (like adding and removing rows) thus atomic converters cannot be used.\n *\n * When table `headingRows` attribute changes, the entire table is re-rendered.\n *\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableHeadingRowsRefreshPostFixer( model ) {\n\tmodel.document.registerPostFixer( () => tableHeadingRowsRefreshPostFixer( model ) );\n}\n\nfunction tableHeadingRowsRefreshPostFixer( model ) {\n\tconst differ = model.document.differ;\n\n\t// Stores tables to be refreshed so the table will be refreshed once for multiple changes.\n\tconst tablesToRefresh = new Set();\n\n\tfor ( const change of differ.getChanges() ) {\n\t\tif ( change.type === 'attribute' ) {\n\t\t\tconst element = change.range.start.nodeAfter;\n\n\t\t\tif ( element && element.is( 'element', 'table' ) && change.attributeKey === 'headingRows' ) {\n\t\t\t\ttablesToRefresh.add( element );\n\t\t\t}\n\t\t} else {\n\t\t\t/* istanbul ignore else */\n\t\t\tif ( change.type === 'insert' || change.type === 'remove' ) {\n\t\t\t\tif ( change.name === 'tableRow' ) {\n\t\t\t\t\tconst table = change.position.findAncestor( 'table' );\n\t\t\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t\t\tif ( change.position.offset < headingRows ) {\n\t\t\t\t\t\ttablesToRefresh.add( table );\n\t\t\t\t\t}\n\t\t\t\t} else if ( change.name === 'tableCell' ) {\n\t\t\t\t\tconst table = change.position.findAncestor( 'table' );\n\t\t\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' ) || 0;\n\n\t\t\t\t\tif ( change.position.offset < headingColumns ) {\n\t\t\t\t\t\ttablesToRefresh.add( table );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( tablesToRefresh.size ) {\n\t\t// @if CK_DEBUG_TABLE // console.log( `Post-fixing table: refreshing heading rows (${ tablesToRefresh.size }).` );\n\n\t\tfor ( const table of tablesToRefresh.values() ) {\n\t\t\t// Should be handled by a `triggerBy` configuration. See: https://github.com/ckeditor/ckeditor5/issues/8138.\n\t\t\tdiffer.refreshItem( table );\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/utils/structure\n */\nimport TableWalker from '../tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './common';\n/**\n * Returns a cropped table according to given dimensions.\n\n * To return a cropped table that starts at first row and first column and end in third row and column:\n *\n *\t\tconst croppedTable = cropTableToDimensions( table, {\n *\t\t\tstartRow: 1,\n *\t\t\tendRow: 3,\n *\t\t\tstartColumn: 1,\n *\t\t\tendColumn: 3\n *\t\t}, writer );\n *\n * Calling the code above for the table below:\n *\n *\t\t      0   1   2   3   4                      0   1   2\n *\t\t    ┌───┬───┬───┬───┬───┐\n *\t\t 0  │ a │ b │ c │ d │ e │\n *\t\t    ├───┴───┤   ├───┴───┤                  ┌───┬───┬───┐\n *\t\t 1  │ f     │   │ g     │                  │   │   │ g │  0\n *\t\t    ├───┬───┴───┼───┬───┤   will return:   ├───┴───┼───┤\n *\t\t 2  │ h │ i     │ j │ k │                  │ i     │ j │  1\n *\t\t    ├───┤       ├───┤   │                  │       ├───┤\n *\t\t 3  │ l │       │ m │   │                  │       │ m │  2\n *\t\t    ├───┼───┬───┤   ├───┤                  └───────┴───┘\n *\t\t 4  │ n │ o │ p │   │ q │\n *\t\t    └───┴───┴───┴───┴───┘\n *\n * @param {module:engine/model/element~Element} sourceTable\n * @param {Object} cropDimensions\n * @param {Number} cropDimensions.startRow\n * @param {Number} cropDimensions.startColumn\n * @param {Number} cropDimensions.endRow\n * @param {Number} cropDimensions.endColumn\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element}\n */\n\nexport function cropTableToDimensions(sourceTable, cropDimensions, writer) {\n  const {\n    startRow,\n    startColumn,\n    endRow,\n    endColumn\n  } = cropDimensions; // Create empty table with empty rows equal to crop height.\n\n  const croppedTable = writer.createElement('table');\n  const cropHeight = endRow - startRow + 1;\n\n  for (let i = 0; i < cropHeight; i++) {\n    writer.insertElement('tableRow', croppedTable, 'end');\n  }\n\n  const tableMap = [...new TableWalker(sourceTable, {\n    startRow,\n    endRow,\n    startColumn,\n    endColumn,\n    includeAllSlots: true\n  })]; // Iterate over source table slots (including empty - spanned - ones).\n\n  for (const {\n    row: sourceRow,\n    column: sourceColumn,\n    cell: tableCell,\n    isAnchor,\n    cellAnchorRow,\n    cellAnchorColumn\n  } of tableMap) {\n    // Row index in cropped table.\n    const rowInCroppedTable = sourceRow - startRow;\n    const row = croppedTable.getChild(rowInCroppedTable); // For empty slots: fill the gap with empty table cell.\n\n    if (!isAnchor) {\n      // But fill the gap only if the spanning cell is anchored outside cropped area.\n      // In the table from method jsdoc those cells are: \"c\" & \"f\".\n      if (cellAnchorRow < startRow || cellAnchorColumn < startColumn) {\n        createEmptyTableCell(writer, writer.createPositionAt(row, 'end'));\n      }\n    } // Otherwise clone the cell with all children and trim if it exceeds cropped area.\n    else {\n      const tableCellCopy = writer.cloneElement(tableCell);\n      writer.append(tableCellCopy, row); // Trim table if it exceeds cropped area.\n      // In the table from method jsdoc those cells are: \"g\" & \"m\".\n\n      trimTableCellIfNeeded(tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer);\n    }\n  } // Adjust heading rows & columns in cropped table if crop selection includes headings parts.\n\n\n  addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer);\n  return croppedTable;\n}\n/**\n * Returns slot info of cells that starts above and overlaps a given row.\n *\n * In a table below, passing `overlapRow = 3`\n *\n *\t\t   ┌───┬───┬───┬───┬───┐\n *\t\t0  │ a │ b │ c │ d │ e │\n *\t\t   │   ├───┼───┼───┼───┤\n *\t\t1  │   │ f │ g │ h │ i │\n *\t\t   ├───┤   ├───┼───┤   │\n *\t\t2  │ j │   │ k │ l │   │\n *\t\t   │   │   │   ├───┼───┤\n *\t\t3  │   │   │   │ m │ n │  <- overlap row to check\n *\t\t   ├───┼───┤   │   ├───│\n *\t\t4  │ o │ p │   │   │ q │\n *\t\t   └───┴───┴───┴───┴───┘\n *\n * will return slot info for cells: \"j\", \"f\", \"k\".\n *\n * @param {module:engine/model/element~Element} table The table to check.\n * @param {Number} overlapRow The index of the row to check.\n * @param {Number} [startRow=0] A row to start analysis. Use it when it is known that the cells above that row will not overlap.\n * @returns {Array.<module:table/tablewalker~TableSlot>}\n */\n\nexport function getVerticallyOverlappingCells(table, overlapRow) {\n  let startRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const cells = [];\n  const tableWalker = new TableWalker(table, {\n    startRow,\n    endRow: overlapRow - 1\n  });\n\n  for (const slotInfo of tableWalker) {\n    const {\n      row,\n      cellHeight\n    } = slotInfo;\n    const cellEndRow = row + cellHeight - 1;\n\n    if (row < overlapRow && overlapRow <= cellEndRow) {\n      cells.push(slotInfo);\n    }\n  }\n\n  return cells;\n}\n/**\n * Splits the table cell horizontally.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} splitRow\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element} Created table cell.\n */\n\nexport function splitHorizontally(tableCell, splitRow, writer) {\n  const tableRow = tableCell.parent;\n  const table = tableRow.parent;\n  const rowIndex = tableRow.index;\n  const rowspan = parseInt(tableCell.getAttribute('rowspan'));\n  const newRowspan = splitRow - rowIndex;\n  const newCellAttributes = {};\n  const newCellRowSpan = rowspan - newRowspan;\n\n  if (newCellRowSpan > 1) {\n    newCellAttributes.rowspan = newCellRowSpan;\n  }\n\n  const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n\n  if (colspan > 1) {\n    newCellAttributes.colspan = colspan;\n  }\n\n  const startRow = rowIndex;\n  const endRow = startRow + newRowspan;\n  const tableMap = [...new TableWalker(table, {\n    startRow,\n    endRow,\n    includeAllSlots: true\n  })];\n  let newCell = null;\n  let columnIndex;\n\n  for (const tableSlot of tableMap) {\n    const {\n      row,\n      column,\n      cell\n    } = tableSlot;\n\n    if (cell === tableCell && columnIndex === undefined) {\n      columnIndex = column;\n    }\n\n    if (columnIndex !== undefined && columnIndex === column && row === endRow) {\n      newCell = createEmptyTableCell(writer, tableSlot.getPositionBefore(), newCellAttributes);\n    }\n  } // Update the rowspan attribute after updating table.\n\n\n  updateNumericAttribute('rowspan', newRowspan, tableCell, writer);\n  return newCell;\n}\n/**\n * Returns slot info of cells that starts before and overlaps a given column.\n *\n * In a table below, passing `overlapColumn = 3`\n *\n *\t\t  0   1   2   3   4\n *\t\t┌───────┬───────┬───┐\n *\t\t│ a     │ b     │ c │\n *\t\t│───┬───┴───────┼───┤\n *\t\t│ d │ e         │ f │\n *\t\t├───┼───┬───────┴───┤\n *\t\t│ g │ h │ i         │\n *\t\t├───┼───┼───┬───────┤\n *\t\t│ j │ k │ l │ m     │\n *\t\t├───┼───┴───┼───┬───┤\n *\t\t│ n │ o     │ p │ q │\n *\t\t└───┴───────┴───┴───┘\n *\t\t              ^\n *\t\t              Overlap column to check\n *\n * will return slot info for cells: \"b\", \"e\", \"i\".\n *\n * @param {module:engine/model/element~Element} table The table to check.\n * @param {Number} overlapColumn The index of the column to check.\n * @returns {Array.<module:table/tablewalker~TableSlot>}\n */\n\nexport function getHorizontallyOverlappingCells(table, overlapColumn) {\n  const cellsToSplit = [];\n  const tableWalker = new TableWalker(table);\n\n  for (const slotInfo of tableWalker) {\n    const {\n      column,\n      cellWidth\n    } = slotInfo;\n    const cellEndColumn = column + cellWidth - 1;\n\n    if (column < overlapColumn && overlapColumn <= cellEndColumn) {\n      cellsToSplit.push(slotInfo);\n    }\n  }\n\n  return cellsToSplit;\n}\n/**\n * Splits the table cell vertically.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} columnIndex The table cell column index.\n * @param {Number} splitColumn The index of column to split cell on.\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element} Created table cell.\n */\n\nexport function splitVertically(tableCell, columnIndex, splitColumn, writer) {\n  const colspan = parseInt(tableCell.getAttribute('colspan'));\n  const newColspan = splitColumn - columnIndex;\n  const newCellAttributes = {};\n  const newCellColSpan = colspan - newColspan;\n\n  if (newCellColSpan > 1) {\n    newCellAttributes.colspan = newCellColSpan;\n  }\n\n  const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n\n  if (rowspan > 1) {\n    newCellAttributes.rowspan = rowspan;\n  }\n\n  const newCell = createEmptyTableCell(writer, writer.createPositionAfter(tableCell), newCellAttributes); // Update the colspan attribute after updating table.\n\n  updateNumericAttribute('colspan', newColspan, tableCell, writer);\n  return newCell;\n}\n/**\n * Adjusts table cell dimensions to not exceed limit row and column.\n *\n * If table cell width (or height) covers a column (or row) that is after a limit column (or row)\n * this method will trim \"colspan\" (or \"rowspan\") attribute so the table cell will fit in a defined limits.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} cellRow\n * @param {Number} cellColumn\n * @param {Number} limitRow\n * @param {Number} limitColumn\n * @param {module:engine/model/writer~Writer} writer\n */\n\nexport function trimTableCellIfNeeded(tableCell, cellRow, cellColumn, limitRow, limitColumn, writer) {\n  const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n  const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  const endColumn = cellColumn + colspan - 1;\n\n  if (endColumn > limitColumn) {\n    const trimmedSpan = limitColumn - cellColumn + 1;\n    updateNumericAttribute('colspan', trimmedSpan, tableCell, writer, 1);\n  }\n\n  const endRow = cellRow + rowspan - 1;\n\n  if (endRow > limitRow) {\n    const trimmedSpan = limitRow - cellRow + 1;\n    updateNumericAttribute('rowspan', trimmedSpan, tableCell, writer, 1);\n  }\n} // Sets proper heading attributes to a cropped table.\n\nfunction addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer) {\n  const headingRows = parseInt(sourceTable.getAttribute('headingRows') || 0);\n\n  if (headingRows > 0) {\n    const headingRowsInCrop = headingRows - startRow;\n    updateNumericAttribute('headingRows', headingRowsInCrop, croppedTable, writer, 0);\n  }\n\n  const headingColumns = parseInt(sourceTable.getAttribute('headingColumns') || 0);\n\n  if (headingColumns > 0) {\n    const headingColumnsInCrop = headingColumns - startColumn;\n    updateNumericAttribute('headingColumns', headingColumnsInCrop, croppedTable, writer, 0);\n  }\n}\n/**\n * Removes columns that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+----+----+----+----+\n *     | 00 | 01      | 03 | 04      | 06 |\n *     +----+----+----+----+         +----+\n *     | 10 | 11      | 13 |         | 16 |\n *     +----+----+----+----+----+----+----+\n *     | 20 | 21      | 23 | 24      | 26 |\n *     +----+----+----+----+----+----+----+\n *                  ^--- empty ---^\n *\n * Will remove columns 2 and 5.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a column from a table use {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`}.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean} True if removed some columns.\n */\n\n\nexport function removeEmptyColumns(table, tableUtils) {\n  const width = tableUtils.getColumns(table);\n  const columnsMap = new Array(width).fill(0);\n\n  for (const {\n    column\n  } of new TableWalker(table)) {\n    columnsMap[column]++;\n  }\n\n  const emptyColumns = columnsMap.reduce((result, cellsCount, column) => {\n    return cellsCount ? result : [...result, column];\n  }, []);\n\n  if (emptyColumns.length > 0) {\n    // Remove only last empty column because it will recurrently trigger removing empty rows.\n    const emptyColumn = emptyColumns[emptyColumns.length - 1]; // @if CK_DEBUG_TABLE // console.log( `Removing empty column: ${ emptyColumn }.` );\n\n    tableUtils.removeColumns(table, {\n      at: emptyColumn\n    });\n    return true;\n  }\n\n  return false;\n}\n/**\n * Removes rows that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+\n *     | 00 | 01 | 02 |\n *     +----+----+----+\n *     | 10 | 11 | 12 |\n *     +    +    +    +\n *     |    |    |    | <-- empty\n *     +----+----+----+\n *     | 30 | 31 | 32 |\n *     +----+----+----+\n *     | 40      | 42 |\n *     +         +    +\n *     |         |    | <-- empty\n *     +----+----+----+\n *     | 60 | 61 | 62 |\n *     +----+----+----+\n *\n * Will remove rows 2 and 5.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a row from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`}.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean} True if removed some rows.\n */\n\nexport function removeEmptyRows(table, tableUtils) {\n  const emptyRows = [];\n  const tableRowCount = tableUtils.getRows(table);\n\n  for (let rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {\n    const tableRow = table.getChild(rowIndex);\n\n    if (tableRow.isEmpty) {\n      emptyRows.push(rowIndex);\n    }\n  }\n\n  if (emptyRows.length > 0) {\n    // Remove only last empty row because it will recurrently trigger removing empty columns.\n    const emptyRow = emptyRows[emptyRows.length - 1]; // @if CK_DEBUG_TABLE // console.log( `Removing empty row: ${ emptyRow }.` );\n\n    tableUtils.removeRows(table, {\n      at: emptyRow\n    });\n    return true;\n  }\n\n  return false;\n}\n/**\n * Removes rows and columns that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+----+\n *     | 00      | 02      |\n *     +----+----+         +\n *     | 10      |         |\n *     +----+----+----+----+\n *     | 20      | 22 | 23 |\n *     +         +    +    +\n *     |         |    |    | <-- empty row\n *     +----+----+----+----+\n *             ^--- empty column\n *\n * Will remove row 3 and column 1.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a rows from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`} and\n * {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`} to remove a column.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n */\n\nexport function removeEmptyRowsColumns(table, tableUtils) {\n  const removedColumns = removeEmptyColumns(table, tableUtils); // If there was some columns removed then cleaning empty rows was already triggered.\n\n  if (!removedColumns) {\n    removeEmptyRows(table, tableUtils);\n  }\n}\n/**\n * Returns adjusted last row index if selection covers part of a row with empty slots (spanned by other cells).\n * The `dimensions.lastRow` is equal to last row index but selection might be bigger.\n *\n * This happens *only* on rectangular selection so we analyze a case like this:\n *\n *        +---+---+---+---+\n *      0 | a | b | c | d |\n *        +   +   +---+---+\n *      1 |   | e | f | g |\n *        +   +---+   +---+\n *      2 |   | h |   | i | <- last row, each cell has rowspan = 2,\n *        +   +   +   +   +    so we need to return 3, not 2\n *      3 |   |   |   |   |\n *        +---+---+---+---+\n *\n * @param {module:engine/model/element~Element} table\n * @param {Object} dimensions\n * @param {Number} dimensions.firstRow\n * @param {Number} dimensions.firstColumn\n * @param {Number} dimensions.lastRow\n * @param {Number} dimensions.lastColumn\n * @returns {Number} Adjusted last row index.\n */\n\nexport function adjustLastRowIndex(table, dimensions) {\n  const lastRowMap = Array.from(new TableWalker(table, {\n    startColumn: dimensions.firstColumn,\n    endColumn: dimensions.lastColumn,\n    row: dimensions.lastRow\n  }));\n  const everyCellHasSingleRowspan = lastRowMap.every(_ref => {\n    let {\n      cellHeight\n    } = _ref;\n    return cellHeight === 1;\n  }); // It is a \"flat\" row, so the last row index is OK.\n\n  if (everyCellHasSingleRowspan) {\n    return dimensions.lastRow;\n  } // Otherwise get any cell's rowspan and adjust the last row index.\n\n\n  const rowspanAdjustment = lastRowMap[0].cellHeight - 1;\n  return dimensions.lastRow + rowspanAdjustment;\n}\n/**\n * Returns adjusted last column index if selection covers part of a column with empty slots (spanned by other cells).\n * The `dimensions.lastColumn` is equal to last column index but selection might be bigger.\n *\n * This happens *only* on rectangular selection so we analyze a case like this:\n *\n *       0   1   2   3\n *     +---+---+---+---+\n *     | a             |\n *     +---+---+---+---+\n *     | b | c | d     |\n *     +---+---+---+---+\n *     | e     | f     |\n *     +---+---+---+---+\n *     | g | h         |\n *     +---+---+---+---+\n *               ^\n *              last column, each cell has colspan = 2, so we need to return 3, not 2\n *\n * @param {module:engine/model/element~Element} table\n * @param {Object} dimensions\n * @param {Number} dimensions.firstRow\n * @param {Number} dimensions.firstColumn\n * @param {Number} dimensions.lastRow\n * @param {Number} dimensions.lastColumn\n * @returns {Number} Adjusted last column index.\n */\n\nexport function adjustLastColumnIndex(table, dimensions) {\n  const lastColumnMap = Array.from(new TableWalker(table, {\n    startRow: dimensions.firstRow,\n    endRow: dimensions.lastRow,\n    column: dimensions.lastColumn\n  }));\n  const everyCellHasSingleColspan = lastColumnMap.every(_ref2 => {\n    let {\n      cellWidth\n    } = _ref2;\n    return cellWidth === 1;\n  }); // It is a \"flat\" column, so the last column index is OK.\n\n  if (everyCellHasSingleColspan) {\n    return dimensions.lastColumn;\n  } // Otherwise get any cell's colspan and adjust the last column index.\n\n\n  const colspanAdjustment = lastColumnMap[0].cellWidth - 1;\n  return dimensions.lastColumn + colspanAdjustment;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/utils/structure.js"],"names":["TableWalker","createEmptyTableCell","updateNumericAttribute","cropTableToDimensions","sourceTable","cropDimensions","writer","startRow","startColumn","endRow","endColumn","croppedTable","createElement","cropHeight","i","insertElement","tableMap","includeAllSlots","row","sourceRow","column","sourceColumn","cell","tableCell","isAnchor","cellAnchorRow","cellAnchorColumn","rowInCroppedTable","getChild","createPositionAt","tableCellCopy","cloneElement","append","trimTableCellIfNeeded","addHeadingsToCroppedTable","getVerticallyOverlappingCells","table","overlapRow","cells","tableWalker","slotInfo","cellHeight","cellEndRow","push","splitHorizontally","splitRow","tableRow","parent","rowIndex","index","rowspan","parseInt","getAttribute","newRowspan","newCellAttributes","newCellRowSpan","colspan","newCell","columnIndex","tableSlot","undefined","getPositionBefore","getHorizontallyOverlappingCells","overlapColumn","cellsToSplit","cellWidth","cellEndColumn","splitVertically","splitColumn","newColspan","newCellColSpan","createPositionAfter","cellRow","cellColumn","limitRow","limitColumn","trimmedSpan","headingRows","headingRowsInCrop","headingColumns","headingColumnsInCrop","removeEmptyColumns","tableUtils","width","getColumns","columnsMap","Array","fill","emptyColumns","reduce","result","cellsCount","length","emptyColumn","removeColumns","at","removeEmptyRows","emptyRows","tableRowCount","getRows","isEmpty","emptyRow","removeRows","removeEmptyRowsColumns","removedColumns","adjustLastRowIndex","dimensions","lastRowMap","from","firstColumn","lastColumn","lastRow","everyCellHasSingleRowspan","every","rowspanAdjustment","adjustLastColumnIndex","lastColumnMap","firstRow","everyCellHasSingleColspan","colspanAdjustment"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/utils/structure\n */\n\nimport TableWalker from '../tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './common';\n\n/**\n * Returns a cropped table according to given dimensions.\n\n * To return a cropped table that starts at first row and first column and end in third row and column:\n *\n *\t\tconst croppedTable = cropTableToDimensions( table, {\n *\t\t\tstartRow: 1,\n *\t\t\tendRow: 3,\n *\t\t\tstartColumn: 1,\n *\t\t\tendColumn: 3\n *\t\t}, writer );\n *\n * Calling the code above for the table below:\n *\n *\t\t      0   1   2   3   4                      0   1   2\n *\t\t    ┌───┬───┬───┬───┬───┐\n *\t\t 0  │ a │ b │ c │ d │ e │\n *\t\t    ├───┴───┤   ├───┴───┤                  ┌───┬───┬───┐\n *\t\t 1  │ f     │   │ g     │                  │   │   │ g │  0\n *\t\t    ├───┬───┴───┼───┬───┤   will return:   ├───┴───┼───┤\n *\t\t 2  │ h │ i     │ j │ k │                  │ i     │ j │  1\n *\t\t    ├───┤       ├───┤   │                  │       ├───┤\n *\t\t 3  │ l │       │ m │   │                  │       │ m │  2\n *\t\t    ├───┼───┬───┤   ├───┤                  └───────┴───┘\n *\t\t 4  │ n │ o │ p │   │ q │\n *\t\t    └───┴───┴───┴───┴───┘\n *\n * @param {module:engine/model/element~Element} sourceTable\n * @param {Object} cropDimensions\n * @param {Number} cropDimensions.startRow\n * @param {Number} cropDimensions.startColumn\n * @param {Number} cropDimensions.endRow\n * @param {Number} cropDimensions.endColumn\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element}\n */\nexport function cropTableToDimensions( sourceTable, cropDimensions, writer ) {\n\tconst { startRow, startColumn, endRow, endColumn } = cropDimensions;\n\n\t// Create empty table with empty rows equal to crop height.\n\tconst croppedTable = writer.createElement( 'table' );\n\tconst cropHeight = endRow - startRow + 1;\n\n\tfor ( let i = 0; i < cropHeight; i++ ) {\n\t\twriter.insertElement( 'tableRow', croppedTable, 'end' );\n\t}\n\n\tconst tableMap = [ ...new TableWalker( sourceTable, { startRow, endRow, startColumn, endColumn, includeAllSlots: true } ) ];\n\n\t// Iterate over source table slots (including empty - spanned - ones).\n\tfor ( const { row: sourceRow, column: sourceColumn, cell: tableCell, isAnchor, cellAnchorRow, cellAnchorColumn } of tableMap ) {\n\t\t// Row index in cropped table.\n\t\tconst rowInCroppedTable = sourceRow - startRow;\n\t\tconst row = croppedTable.getChild( rowInCroppedTable );\n\n\t\t// For empty slots: fill the gap with empty table cell.\n\t\tif ( !isAnchor ) {\n\t\t\t// But fill the gap only if the spanning cell is anchored outside cropped area.\n\t\t\t// In the table from method jsdoc those cells are: \"c\" & \"f\".\n\t\t\tif ( cellAnchorRow < startRow || cellAnchorColumn < startColumn ) {\n\t\t\t\tcreateEmptyTableCell( writer, writer.createPositionAt( row, 'end' ) );\n\t\t\t}\n\t\t}\n\t\t// Otherwise clone the cell with all children and trim if it exceeds cropped area.\n\t\telse {\n\t\t\tconst tableCellCopy = writer.cloneElement( tableCell );\n\n\t\t\twriter.append( tableCellCopy, row );\n\n\t\t\t// Trim table if it exceeds cropped area.\n\t\t\t// In the table from method jsdoc those cells are: \"g\" & \"m\".\n\t\t\ttrimTableCellIfNeeded( tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer );\n\t\t}\n\t}\n\n\t// Adjust heading rows & columns in cropped table if crop selection includes headings parts.\n\taddHeadingsToCroppedTable( croppedTable, sourceTable, startRow, startColumn, writer );\n\n\treturn croppedTable;\n}\n\n/**\n * Returns slot info of cells that starts above and overlaps a given row.\n *\n * In a table below, passing `overlapRow = 3`\n *\n *\t\t   ┌───┬───┬───┬───┬───┐\n *\t\t0  │ a │ b │ c │ d │ e │\n *\t\t   │   ├───┼───┼───┼───┤\n *\t\t1  │   │ f │ g │ h │ i │\n *\t\t   ├───┤   ├───┼───┤   │\n *\t\t2  │ j │   │ k │ l │   │\n *\t\t   │   │   │   ├───┼───┤\n *\t\t3  │   │   │   │ m │ n │  <- overlap row to check\n *\t\t   ├───┼───┤   │   ├───│\n *\t\t4  │ o │ p │   │   │ q │\n *\t\t   └───┴───┴───┴───┴───┘\n *\n * will return slot info for cells: \"j\", \"f\", \"k\".\n *\n * @param {module:engine/model/element~Element} table The table to check.\n * @param {Number} overlapRow The index of the row to check.\n * @param {Number} [startRow=0] A row to start analysis. Use it when it is known that the cells above that row will not overlap.\n * @returns {Array.<module:table/tablewalker~TableSlot>}\n */\nexport function getVerticallyOverlappingCells( table, overlapRow, startRow = 0 ) {\n\tconst cells = [];\n\n\tconst tableWalker = new TableWalker( table, { startRow, endRow: overlapRow - 1 } );\n\n\tfor ( const slotInfo of tableWalker ) {\n\t\tconst { row, cellHeight } = slotInfo;\n\t\tconst cellEndRow = row + cellHeight - 1;\n\n\t\tif ( row < overlapRow && overlapRow <= cellEndRow ) {\n\t\t\tcells.push( slotInfo );\n\t\t}\n\t}\n\n\treturn cells;\n}\n\n/**\n * Splits the table cell horizontally.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} splitRow\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element} Created table cell.\n */\nexport function splitHorizontally( tableCell, splitRow, writer ) {\n\tconst tableRow = tableCell.parent;\n\tconst table = tableRow.parent;\n\tconst rowIndex = tableRow.index;\n\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) );\n\tconst newRowspan = splitRow - rowIndex;\n\n\tconst newCellAttributes = {};\n\tconst newCellRowSpan = rowspan - newRowspan;\n\n\tif ( newCellRowSpan > 1 ) {\n\t\tnewCellAttributes.rowspan = newCellRowSpan;\n\t}\n\n\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\tif ( colspan > 1 ) {\n\t\tnewCellAttributes.colspan = colspan;\n\t}\n\n\tconst startRow = rowIndex;\n\tconst endRow = startRow + newRowspan;\n\tconst tableMap = [ ...new TableWalker( table, { startRow, endRow, includeAllSlots: true } ) ];\n\n\tlet newCell = null;\n\tlet columnIndex;\n\n\tfor ( const tableSlot of tableMap ) {\n\t\tconst { row, column, cell } = tableSlot;\n\n\t\tif ( cell === tableCell && columnIndex === undefined ) {\n\t\t\tcolumnIndex = column;\n\t\t}\n\n\t\tif ( columnIndex !== undefined && columnIndex === column && row === endRow ) {\n\t\t\tnewCell = createEmptyTableCell( writer, tableSlot.getPositionBefore(), newCellAttributes );\n\t\t}\n\t}\n\n\t// Update the rowspan attribute after updating table.\n\tupdateNumericAttribute( 'rowspan', newRowspan, tableCell, writer );\n\n\treturn newCell;\n}\n\n/**\n * Returns slot info of cells that starts before and overlaps a given column.\n *\n * In a table below, passing `overlapColumn = 3`\n *\n *\t\t  0   1   2   3   4\n *\t\t┌───────┬───────┬───┐\n *\t\t│ a     │ b     │ c │\n *\t\t│───┬───┴───────┼───┤\n *\t\t│ d │ e         │ f │\n *\t\t├───┼───┬───────┴───┤\n *\t\t│ g │ h │ i         │\n *\t\t├───┼───┼───┬───────┤\n *\t\t│ j │ k │ l │ m     │\n *\t\t├───┼───┴───┼───┬───┤\n *\t\t│ n │ o     │ p │ q │\n *\t\t└───┴───────┴───┴───┘\n *\t\t              ^\n *\t\t              Overlap column to check\n *\n * will return slot info for cells: \"b\", \"e\", \"i\".\n *\n * @param {module:engine/model/element~Element} table The table to check.\n * @param {Number} overlapColumn The index of the column to check.\n * @returns {Array.<module:table/tablewalker~TableSlot>}\n */\nexport function getHorizontallyOverlappingCells( table, overlapColumn ) {\n\tconst cellsToSplit = [];\n\n\tconst tableWalker = new TableWalker( table );\n\n\tfor ( const slotInfo of tableWalker ) {\n\t\tconst { column, cellWidth } = slotInfo;\n\t\tconst cellEndColumn = column + cellWidth - 1;\n\n\t\tif ( column < overlapColumn && overlapColumn <= cellEndColumn ) {\n\t\t\tcellsToSplit.push( slotInfo );\n\t\t}\n\t}\n\n\treturn cellsToSplit;\n}\n\n/**\n * Splits the table cell vertically.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} columnIndex The table cell column index.\n * @param {Number} splitColumn The index of column to split cell on.\n * @param {module:engine/model/writer~Writer} writer\n * @returns {module:engine/model/element~Element} Created table cell.\n */\nexport function splitVertically( tableCell, columnIndex, splitColumn, writer ) {\n\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) );\n\tconst newColspan = splitColumn - columnIndex;\n\n\tconst newCellAttributes = {};\n\tconst newCellColSpan = colspan - newColspan;\n\n\tif ( newCellColSpan > 1 ) {\n\t\tnewCellAttributes.colspan = newCellColSpan;\n\t}\n\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\n\tif ( rowspan > 1 ) {\n\t\tnewCellAttributes.rowspan = rowspan;\n\t}\n\n\tconst newCell = createEmptyTableCell( writer, writer.createPositionAfter( tableCell ), newCellAttributes );\n\n\t// Update the colspan attribute after updating table.\n\tupdateNumericAttribute( 'colspan', newColspan, tableCell, writer );\n\n\treturn newCell;\n}\n\n/**\n * Adjusts table cell dimensions to not exceed limit row and column.\n *\n * If table cell width (or height) covers a column (or row) that is after a limit column (or row)\n * this method will trim \"colspan\" (or \"rowspan\") attribute so the table cell will fit in a defined limits.\n *\n * @param {module:engine/model/element~Element} tableCell\n * @param {Number} cellRow\n * @param {Number} cellColumn\n * @param {Number} limitRow\n * @param {Number} limitColumn\n * @param {module:engine/model/writer~Writer} writer\n */\nexport function trimTableCellIfNeeded( tableCell, cellRow, cellColumn, limitRow, limitColumn, writer ) {\n\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\n\tconst endColumn = cellColumn + colspan - 1;\n\n\tif ( endColumn > limitColumn ) {\n\t\tconst trimmedSpan = limitColumn - cellColumn + 1;\n\n\t\tupdateNumericAttribute( 'colspan', trimmedSpan, tableCell, writer, 1 );\n\t}\n\n\tconst endRow = cellRow + rowspan - 1;\n\n\tif ( endRow > limitRow ) {\n\t\tconst trimmedSpan = limitRow - cellRow + 1;\n\n\t\tupdateNumericAttribute( 'rowspan', trimmedSpan, tableCell, writer, 1 );\n\t}\n}\n\n// Sets proper heading attributes to a cropped table.\nfunction addHeadingsToCroppedTable( croppedTable, sourceTable, startRow, startColumn, writer ) {\n\tconst headingRows = parseInt( sourceTable.getAttribute( 'headingRows' ) || 0 );\n\n\tif ( headingRows > 0 ) {\n\t\tconst headingRowsInCrop = headingRows - startRow;\n\t\tupdateNumericAttribute( 'headingRows', headingRowsInCrop, croppedTable, writer, 0 );\n\t}\n\n\tconst headingColumns = parseInt( sourceTable.getAttribute( 'headingColumns' ) || 0 );\n\n\tif ( headingColumns > 0 ) {\n\t\tconst headingColumnsInCrop = headingColumns - startColumn;\n\t\tupdateNumericAttribute( 'headingColumns', headingColumnsInCrop, croppedTable, writer, 0 );\n\t}\n}\n\n/**\n * Removes columns that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+----+----+----+----+\n *     | 00 | 01      | 03 | 04      | 06 |\n *     +----+----+----+----+         +----+\n *     | 10 | 11      | 13 |         | 16 |\n *     +----+----+----+----+----+----+----+\n *     | 20 | 21      | 23 | 24      | 26 |\n *     +----+----+----+----+----+----+----+\n *                  ^--- empty ---^\n *\n * Will remove columns 2 and 5.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a column from a table use {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`}.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean} True if removed some columns.\n */\nexport function removeEmptyColumns( table, tableUtils ) {\n\tconst width = tableUtils.getColumns( table );\n\tconst columnsMap = new Array( width ).fill( 0 );\n\n\tfor ( const { column } of new TableWalker( table ) ) {\n\t\tcolumnsMap[ column ]++;\n\t}\n\n\tconst emptyColumns = columnsMap.reduce( ( result, cellsCount, column ) => {\n\t\treturn cellsCount ? result : [ ...result, column ];\n\t}, [] );\n\n\tif ( emptyColumns.length > 0 ) {\n\t\t// Remove only last empty column because it will recurrently trigger removing empty rows.\n\t\tconst emptyColumn = emptyColumns[ emptyColumns.length - 1 ];\n\n\t\t// @if CK_DEBUG_TABLE // console.log( `Removing empty column: ${ emptyColumn }.` );\n\t\ttableUtils.removeColumns( table, { at: emptyColumn } );\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes rows that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+\n *     | 00 | 01 | 02 |\n *     +----+----+----+\n *     | 10 | 11 | 12 |\n *     +    +    +    +\n *     |    |    |    | <-- empty\n *     +----+----+----+\n *     | 30 | 31 | 32 |\n *     +----+----+----+\n *     | 40      | 42 |\n *     +         +    +\n *     |         |    | <-- empty\n *     +----+----+----+\n *     | 60 | 61 | 62 |\n *     +----+----+----+\n *\n * Will remove rows 2 and 5.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a row from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`}.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n * @returns {Boolean} True if removed some rows.\n */\nexport function removeEmptyRows( table, tableUtils ) {\n\tconst emptyRows = [];\n\tconst tableRowCount = tableUtils.getRows( table );\n\n\tfor ( let rowIndex = 0; rowIndex < tableRowCount; rowIndex++ ) {\n\t\tconst tableRow = table.getChild( rowIndex );\n\n\t\tif ( tableRow.isEmpty ) {\n\t\t\temptyRows.push( rowIndex );\n\t\t}\n\t}\n\n\tif ( emptyRows.length > 0 ) {\n\t\t// Remove only last empty row because it will recurrently trigger removing empty columns.\n\t\tconst emptyRow = emptyRows[ emptyRows.length - 1 ];\n\n\t\t// @if CK_DEBUG_TABLE // console.log( `Removing empty row: ${ emptyRow }.` );\n\t\ttableUtils.removeRows( table, { at: emptyRow } );\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes rows and columns that have no cells anchored.\n *\n * In table below:\n *\n *     +----+----+----+----+\n *     | 00      | 02      |\n *     +----+----+         +\n *     | 10      |         |\n *     +----+----+----+----+\n *     | 20      | 22 | 23 |\n *     +         +    +    +\n *     |         |    |    | <-- empty row\n *     +----+----+----+----+\n *             ^--- empty column\n *\n * Will remove row 3 and column 1.\n *\n * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.\n * To remove a rows from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`} and\n * {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`} to remove a column.\n *\n * @protected\n * @param {module:engine/model/element~Element} table\n * @param {module:table/tableutils~TableUtils} tableUtils\n */\nexport function removeEmptyRowsColumns( table, tableUtils ) {\n\tconst removedColumns = removeEmptyColumns( table, tableUtils );\n\n\t// If there was some columns removed then cleaning empty rows was already triggered.\n\tif ( !removedColumns ) {\n\t\tremoveEmptyRows( table, tableUtils );\n\t}\n}\n\n/**\n * Returns adjusted last row index if selection covers part of a row with empty slots (spanned by other cells).\n * The `dimensions.lastRow` is equal to last row index but selection might be bigger.\n *\n * This happens *only* on rectangular selection so we analyze a case like this:\n *\n *        +---+---+---+---+\n *      0 | a | b | c | d |\n *        +   +   +---+---+\n *      1 |   | e | f | g |\n *        +   +---+   +---+\n *      2 |   | h |   | i | <- last row, each cell has rowspan = 2,\n *        +   +   +   +   +    so we need to return 3, not 2\n *      3 |   |   |   |   |\n *        +---+---+---+---+\n *\n * @param {module:engine/model/element~Element} table\n * @param {Object} dimensions\n * @param {Number} dimensions.firstRow\n * @param {Number} dimensions.firstColumn\n * @param {Number} dimensions.lastRow\n * @param {Number} dimensions.lastColumn\n * @returns {Number} Adjusted last row index.\n */\nexport function adjustLastRowIndex( table, dimensions ) {\n\tconst lastRowMap = Array.from( new TableWalker( table, {\n\t\tstartColumn: dimensions.firstColumn,\n\t\tendColumn: dimensions.lastColumn,\n\t\trow: dimensions.lastRow\n\t} ) );\n\n\tconst everyCellHasSingleRowspan = lastRowMap.every( ( { cellHeight } ) => cellHeight === 1 );\n\n\t// It is a \"flat\" row, so the last row index is OK.\n\tif ( everyCellHasSingleRowspan ) {\n\t\treturn dimensions.lastRow;\n\t}\n\n\t// Otherwise get any cell's rowspan and adjust the last row index.\n\tconst rowspanAdjustment = lastRowMap[ 0 ].cellHeight - 1;\n\treturn dimensions.lastRow + rowspanAdjustment;\n}\n\n/**\n * Returns adjusted last column index if selection covers part of a column with empty slots (spanned by other cells).\n * The `dimensions.lastColumn` is equal to last column index but selection might be bigger.\n *\n * This happens *only* on rectangular selection so we analyze a case like this:\n *\n *       0   1   2   3\n *     +---+---+---+---+\n *     | a             |\n *     +---+---+---+---+\n *     | b | c | d     |\n *     +---+---+---+---+\n *     | e     | f     |\n *     +---+---+---+---+\n *     | g | h         |\n *     +---+---+---+---+\n *               ^\n *              last column, each cell has colspan = 2, so we need to return 3, not 2\n *\n * @param {module:engine/model/element~Element} table\n * @param {Object} dimensions\n * @param {Number} dimensions.firstRow\n * @param {Number} dimensions.firstColumn\n * @param {Number} dimensions.lastRow\n * @param {Number} dimensions.lastColumn\n * @returns {Number} Adjusted last column index.\n */\nexport function adjustLastColumnIndex( table, dimensions ) {\n\tconst lastColumnMap = Array.from( new TableWalker( table, {\n\t\tstartRow: dimensions.firstRow,\n\t\tendRow: dimensions.lastRow,\n\t\tcolumn: dimensions.lastColumn\n\t} ) );\n\n\tconst everyCellHasSingleColspan = lastColumnMap.every( ( { cellWidth } ) => cellWidth === 1 );\n\n\t// It is a \"flat\" column, so the last column index is OK.\n\tif ( everyCellHasSingleColspan ) {\n\t\treturn dimensions.lastColumn;\n\t}\n\n\t// Otherwise get any cell's colspan and adjust the last column index.\n\tconst colspanAdjustment = lastColumnMap[ 0 ].cellWidth - 1;\n\treturn dimensions.lastColumn + colspanAdjustment;\n}\n"]},"metadata":{},"sourceType":"module"}
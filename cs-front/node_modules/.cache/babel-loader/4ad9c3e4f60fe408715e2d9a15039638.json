{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/downcast\n */\nimport TableWalker from './../tablewalker';\nimport { toWidget, toWidgetEditable } from 'ckeditor5/src/widget';\n/**\n * Model table element to view table element conversion helper.\n *\n * This conversion helper creates the whole table element with child elements.\n *\n * @param {Object} options\n * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertTable() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return dispatcher => dispatcher.on('insert:table', (evt, data, conversionApi) => {\n    const table = data.item;\n\n    if (!conversionApi.consumable.consume(table, 'insert')) {\n      return;\n    } // Consume attributes if present to not fire attribute change downcast\n\n\n    conversionApi.consumable.consume(table, 'attribute:headingRows:table');\n    conversionApi.consumable.consume(table, 'attribute:headingColumns:table');\n    const asWidget = options && options.asWidget;\n    const figureElement = conversionApi.writer.createContainerElement('figure', {\n      class: 'table'\n    });\n    const tableElement = conversionApi.writer.createContainerElement('table');\n    conversionApi.writer.insert(conversionApi.writer.createPositionAt(figureElement, 0), tableElement);\n    let tableWidget;\n\n    if (asWidget) {\n      tableWidget = toTableWidget(figureElement, conversionApi.writer);\n    }\n\n    const tableWalker = new TableWalker(table);\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // Cache for created table rows.\n\n    const viewRows = new Map();\n\n    for (const tableSlot of tableWalker) {\n      const {\n        row,\n        cell\n      } = tableSlot;\n      const tableRow = table.getChild(row);\n      const trElement = viewRows.get(row) || createTr(tableElement, tableRow, row, tableAttributes, conversionApi);\n      viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole table at once.\n\n      conversionApi.consumable.consume(cell, 'insert');\n      const insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n      createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, options);\n    } // Insert empty TR elements if there are any rows without anchored cells. Since the model is always normalized\n    // this can happen only in the document fragment that only part of the table is down-casted.\n\n\n    for (const tableRow of table.getChildren()) {\n      const rowIndex = tableRow.index; // Make sure that this is a table row and not some other element (i.e., caption).\n\n      if (tableRow.is('element', 'tableRow') && !viewRows.has(rowIndex)) {\n        viewRows.set(rowIndex, createTr(tableElement, tableRow, rowIndex, tableAttributes, conversionApi));\n      }\n    }\n\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(table, asWidget ? tableWidget : figureElement);\n    conversionApi.writer.insert(viewPosition, asWidget ? tableWidget : figureElement);\n  });\n}\n/**\n * Model row element to view `<tr>` element conversion helper.\n *\n * This conversion helper creates the whole `<tr>` element with child elements.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertRow() {\n  return dispatcher => dispatcher.on('insert:tableRow', (evt, data, conversionApi) => {\n    const tableRow = data.item;\n\n    if (!conversionApi.consumable.consume(tableRow, 'insert')) {\n      return;\n    }\n\n    const table = tableRow.parent;\n    const figureElement = conversionApi.mapper.toViewElement(table);\n    const tableElement = getViewTable(figureElement);\n    const row = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      row\n    });\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // Cache for created table rows.\n\n    const viewRows = new Map();\n\n    for (const tableSlot of tableWalker) {\n      const trElement = viewRows.get(row) || createTr(tableElement, tableRow, row, tableAttributes, conversionApi);\n      viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole row at once.\n\n      conversionApi.consumable.consume(tableSlot.cell, 'insert');\n      const insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n      createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, {\n        asWidget: true\n      });\n    }\n  });\n}\n/**\n * Model table cell element to view `<td>` or `<th>` element conversion helper.\n *\n * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)\n * and `<td>` otherwise.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertCell() {\n  return dispatcher => dispatcher.on('insert:tableCell', (evt, data, conversionApi) => {\n    const tableCell = data.item;\n\n    if (!conversionApi.consumable.consume(tableCell, 'insert')) {\n      return;\n    }\n\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowIndex = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      row: rowIndex\n    });\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // We need to iterate over a table in order to get proper row & column values from a walker\n\n    for (const tableSlot of tableWalker) {\n      if (tableSlot.cell === tableCell) {\n        const trElement = conversionApi.mapper.toViewElement(tableRow);\n        const insertPosition = conversionApi.writer.createPositionAt(trElement, tableRow.getChildIndex(tableCell));\n        createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, {\n          asWidget: true\n        }); // No need to iterate further.\n\n        return;\n      }\n    }\n  });\n}\n/**\n * Conversion helper that acts on heading column table attribute change.\n *\n * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending on the cell column index.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastTableHeadingColumnsChange() {\n  return dispatcher => dispatcher.on('attribute:headingColumns:table', (evt, data, conversionApi) => {\n    const table = data.item;\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    };\n    const oldColumns = data.attributeOldValue;\n    const newColumns = data.attributeNewValue;\n    const lastColumnToCheck = (oldColumns > newColumns ? oldColumns : newColumns) - 1;\n\n    for (const tableSlot of new TableWalker(table, {\n      endColumn: lastColumnToCheck\n    })) {\n      renameViewTableCellIfRequired(tableSlot, tableAttributes, conversionApi);\n    }\n  });\n}\n/**\n * Conversion helper that acts on a removed row.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastRemoveRow() {\n  return dispatcher => dispatcher.on('remove:tableRow', (evt, data, conversionApi) => {\n    // Prevent default remove converter.\n    evt.stop();\n    const viewWriter = conversionApi.writer;\n    const mapper = conversionApi.mapper;\n    const viewStart = mapper.toViewPosition(data.position).getLastMatchingPosition(value => !value.item.is('element', 'tr'));\n    const viewItem = viewStart.nodeAfter;\n    const tableSection = viewItem.parent;\n    const viewTable = tableSection.parent; // Remove associated <tr> from the view.\n\n    const removeRange = viewWriter.createRangeOn(viewItem);\n    const removed = viewWriter.remove(removeRange);\n\n    for (const child of viewWriter.createRangeIn(removed).getItems()) {\n      mapper.unbindViewElement(child);\n    } // Cleanup: Ensure that thead & tbody sections are removed if left empty after removing rows. See #6437, #6391.\n\n\n    removeTableSectionIfEmpty('thead', viewTable, conversionApi);\n    removeTableSectionIfEmpty('tbody', viewTable, conversionApi);\n  }, {\n    priority: 'higher'\n  });\n}\n/**\n * Overrides paragraph inside table cell conversion.\n *\n * This converter:\n * * should be used to override default paragraph conversion in the editing view.\n * * It will only convert <paragraph> placed directly inside <tableCell>.\n * * For a single paragraph without attributes it returns `<span>` to simulate data table.\n * * For all other cases it returns `<p>` element.\n *\n * @param {module:engine/model/element~Element} modelElement\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n * @returns {module:engine/view/containerelement~ContainerElement|undefined}\n */\n\nexport function convertParagraphInTableCell(modelElement, conversionApi) {\n  const {\n    writer\n  } = conversionApi;\n\n  if (!modelElement.parent.is('element', 'tableCell')) {\n    return;\n  }\n\n  if (isSingleParagraphWithoutAttributes(modelElement)) {\n    return writer.createContainerElement('span', {\n      class: 'ck-table-bogus-paragraph'\n    });\n  } else {\n    return writer.createContainerElement('p');\n  }\n}\n/**\n * Checks if given model `<paragraph>` is an only child of a parent (`<tableCell>`) and if it has any attribute set.\n *\n * The paragraph should be converted in the editing view to:\n *\n * * If returned `true` - to a `<span class=\"ck-table-bogus-paragraph\">`\n * * If returned `false` - to a `<p>`\n *\n * @param {module:engine/model/element~Element} modelElement\n * @returns {Boolean}\n */\n\nexport function isSingleParagraphWithoutAttributes(modelElement) {\n  const tableCell = modelElement.parent;\n  const isSingleParagraph = tableCell.childCount === 1;\n  return isSingleParagraph && !hasAnyAttribute(modelElement);\n} // Converts a given {@link module:engine/view/element~Element} to a table widget:\n// * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the table widget element.\n// * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n// @param {String} label The element's label. It will be concatenated with the table `alt` attribute if one is present.\n// @returns {module:engine/view/element~Element}\n\nfunction toTableWidget(viewElement, writer) {\n  writer.setCustomProperty('table', true, viewElement);\n  return toWidget(viewElement, writer, {\n    hasSelectionHandle: true\n  });\n} // Renames an existing table cell in the view to a given element name.\n//\n// **Note** This method will not do anything if a view table cell has not been converted yet.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} desiredCellElementName\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction renameViewTableCell(tableCell, desiredCellElementName, conversionApi) {\n  const viewWriter = conversionApi.writer;\n  const viewCell = conversionApi.mapper.toViewElement(tableCell);\n  const editable = viewWriter.createEditableElement(desiredCellElementName, viewCell.getAttributes());\n  const renamedCell = toWidgetEditable(editable, viewWriter);\n  viewWriter.insert(viewWriter.createPositionAfter(viewCell), renamedCell);\n  viewWriter.move(viewWriter.createRangeIn(viewCell), viewWriter.createPositionAt(renamedCell, 0));\n  viewWriter.remove(viewWriter.createRangeOn(viewCell));\n  conversionApi.mapper.unbindViewElement(viewCell);\n  conversionApi.mapper.bindElements(tableCell, renamedCell);\n} // Renames a table cell element in the view according to its location in the table.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction renameViewTableCellIfRequired(tableSlot, tableAttributes, conversionApi) {\n  const {\n    cell\n  } = tableSlot; // Check whether current columnIndex is overlapped by table cells from previous rows.\n\n  const desiredCellElementName = getCellElementName(tableSlot, tableAttributes);\n  const viewCell = conversionApi.mapper.toViewElement(cell); // If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view\n  // because of child conversion is done after parent.\n\n  if (viewCell && viewCell.name !== desiredCellElementName) {\n    renameViewTableCell(cell, desiredCellElementName, conversionApi);\n  }\n} // Creates a table cell element in the view.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {module:engine/view/position~Position} insertPosition\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, options) {\n  const asWidget = options && options.asWidget;\n  const cellElementName = getCellElementName(tableSlot, tableAttributes);\n  const cellElement = asWidget ? toWidgetEditable(conversionApi.writer.createEditableElement(cellElementName), conversionApi.writer) : conversionApi.writer.createContainerElement(cellElementName);\n  const tableCell = tableSlot.cell;\n  const firstChild = tableCell.getChild(0);\n  const isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';\n  conversionApi.writer.insert(insertPosition, cellElement);\n  conversionApi.mapper.bindElements(tableCell, cellElement); // Additional requirement for data pipeline to have backward compatible data tables.\n\n  if (!asWidget && isSingleParagraph && !hasAnyAttribute(firstChild)) {\n    const innerParagraph = tableCell.getChild(0);\n    conversionApi.consumable.consume(innerParagraph, 'insert');\n    conversionApi.mapper.bindElements(innerParagraph, cellElement);\n  }\n} // Creates a `<tr>` view element.\n//\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/model/element~Element} tableRow\n// @param {Number} rowIndex\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/element~Element}\n\n\nfunction createTr(tableElement, tableRow, rowIndex, tableAttributes, conversionApi) {\n  // Will always consume since we're converting <tableRow> element from a parent <table>.\n  conversionApi.consumable.consume(tableRow, 'insert');\n  const trElement = tableRow.isEmpty ? conversionApi.writer.createEmptyElement('tr') : conversionApi.writer.createContainerElement('tr');\n  conversionApi.mapper.bindElements(tableRow, trElement);\n  const headingRows = tableAttributes.headingRows;\n  const tableSection = getOrCreateTableSection(getSectionName(rowIndex, tableAttributes), tableElement, conversionApi);\n  const offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;\n  const position = conversionApi.writer.createPositionAt(tableSection, offset);\n  conversionApi.writer.insert(position, trElement);\n  return trElement;\n} // Returns `th` for heading cells and `td` for other cells for the current table walker value.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getCellElementName(tableSlot, tableAttributes) {\n  const {\n    row,\n    column\n  } = tableSlot;\n  const {\n    headingColumns,\n    headingRows\n  } = tableAttributes; // Column heading are all tableCells in the first `columnHeading` rows.\n\n  const isColumnHeading = headingRows && headingRows > row; // So a whole row gets <th> element.\n\n  if (isColumnHeading) {\n    return 'th';\n  } // Row heading are tableCells which columnIndex is lower then headingColumns.\n\n\n  const isRowHeading = headingColumns && headingColumns > column;\n  return isRowHeading ? 'th' : 'td';\n} // Returns the table section name for the current table walker value.\n//\n// @param {Number} row\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getSectionName(row, tableAttributes) {\n  return row < tableAttributes.headingRows ? 'thead' : 'tbody';\n} // Creates or returns an existing `<tbody>` or `<thead>` element with caching.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} viewTable\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} cachedTableSection An object that stores cached elements.\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction getOrCreateTableSection(sectionName, viewTable, conversionApi) {\n  const viewTableSection = getExistingTableSectionElement(sectionName, viewTable);\n  return viewTableSection ? viewTableSection : createTableSection(sectionName, viewTable, conversionApi);\n} // Finds an existing `<tbody>` or `<thead>` element or returns undefined.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction getExistingTableSectionElement(sectionName, tableElement) {\n  for (const tableSection of tableElement.getChildren()) {\n    if (tableSection.name == sectionName) {\n      return tableSection;\n    }\n  }\n} // Creates a table section at the end of the table.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction createTableSection(sectionName, tableElement, conversionApi) {\n  const tableChildElement = conversionApi.writer.createContainerElement(sectionName);\n  const insertPosition = conversionApi.writer.createPositionAt(tableElement, sectionName == 'tbody' ? 'end' : 0);\n  conversionApi.writer.insert(insertPosition, tableChildElement);\n  return tableChildElement;\n} // Removes an existing `<tbody>` or `<thead>` element if it is empty.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction removeTableSectionIfEmpty(sectionName, tableElement, conversionApi) {\n  const tableSection = getExistingTableSectionElement(sectionName, tableElement);\n\n  if (tableSection && tableSection.childCount === 0) {\n    conversionApi.writer.remove(conversionApi.writer.createRangeOn(tableSection));\n  }\n} // Finds a '<table>' element inside the `<figure>` widget.\n//\n// @param {module:engine/view/element~Element} viewFigure\n\n\nfunction getViewTable(viewFigure) {\n  for (const child of viewFigure.getChildren()) {\n    if (child.name === 'table') {\n      return child;\n    }\n  }\n} // Checks if an element has any attributes set.\n//\n// @param {module:engine/model/element~Element element\n// @returns {Boolean}\n\n\nfunction hasAnyAttribute(element) {\n  return !![...element.getAttributeKeys()].length;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/converters/downcast.js"],"names":["TableWalker","toWidget","toWidgetEditable","downcastInsertTable","options","dispatcher","on","evt","data","conversionApi","table","item","consumable","consume","asWidget","figureElement","writer","createContainerElement","class","tableElement","insert","createPositionAt","tableWidget","toTableWidget","tableWalker","tableAttributes","headingRows","getAttribute","headingColumns","viewRows","Map","tableSlot","row","cell","tableRow","getChild","trElement","get","createTr","set","insertPosition","createViewTableCellElement","getChildren","rowIndex","index","is","has","viewPosition","mapper","toViewPosition","range","start","bindElements","downcastInsertRow","parent","toViewElement","getViewTable","getChildIndex","downcastInsertCell","tableCell","downcastTableHeadingColumnsChange","name","oldColumns","attributeOldValue","newColumns","attributeNewValue","lastColumnToCheck","endColumn","renameViewTableCellIfRequired","downcastRemoveRow","stop","viewWriter","viewStart","position","getLastMatchingPosition","value","viewItem","nodeAfter","tableSection","viewTable","removeRange","createRangeOn","removed","remove","child","createRangeIn","getItems","unbindViewElement","removeTableSectionIfEmpty","priority","convertParagraphInTableCell","modelElement","isSingleParagraphWithoutAttributes","isSingleParagraph","childCount","hasAnyAttribute","viewElement","setCustomProperty","hasSelectionHandle","renameViewTableCell","desiredCellElementName","viewCell","editable","createEditableElement","getAttributes","renamedCell","createPositionAfter","move","getCellElementName","cellElementName","cellElement","firstChild","innerParagraph","isEmpty","createEmptyElement","getOrCreateTableSection","getSectionName","offset","column","isColumnHeading","isRowHeading","sectionName","viewTableSection","getExistingTableSectionElement","createTableSection","tableChildElement","viewFigure","element","getAttributeKeys","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/downcast\n */\n\nimport TableWalker from './../tablewalker';\nimport { toWidget, toWidgetEditable } from 'ckeditor5/src/widget';\n\n/**\n * Model table element to view table element conversion helper.\n *\n * This conversion helper creates the whole table element with child elements.\n *\n * @param {Object} options\n * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertTable( options = {} ) {\n\treturn dispatcher => dispatcher.on( 'insert:table', ( evt, data, conversionApi ) => {\n\t\tconst table = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( table, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consume attributes if present to not fire attribute change downcast\n\t\tconversionApi.consumable.consume( table, 'attribute:headingRows:table' );\n\t\tconversionApi.consumable.consume( table, 'attribute:headingColumns:table' );\n\n\t\tconst asWidget = options && options.asWidget;\n\n\t\tconst figureElement = conversionApi.writer.createContainerElement( 'figure', { class: 'table' } );\n\t\tconst tableElement = conversionApi.writer.createContainerElement( 'table' );\n\t\tconversionApi.writer.insert( conversionApi.writer.createPositionAt( figureElement, 0 ), tableElement );\n\n\t\tlet tableWidget;\n\n\t\tif ( asWidget ) {\n\t\t\ttableWidget = toTableWidget( figureElement, conversionApi.writer );\n\t\t}\n\n\t\tconst tableWalker = new TableWalker( table );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// Cache for created table rows.\n\t\tconst viewRows = new Map();\n\n\t\tfor ( const tableSlot of tableWalker ) {\n\t\t\tconst { row, cell } = tableSlot;\n\n\t\t\tconst tableRow = table.getChild( row );\n\t\t\tconst trElement = viewRows.get( row ) || createTr( tableElement, tableRow, row, tableAttributes, conversionApi );\n\t\t\tviewRows.set( row, trElement );\n\n\t\t\t// Consume table cell - it will be always consumed as we convert whole table at once.\n\t\t\tconversionApi.consumable.consume( cell, 'insert' );\n\n\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, 'end' );\n\n\t\t\tcreateViewTableCellElement( tableSlot, tableAttributes, insertPosition, conversionApi, options );\n\t\t}\n\n\t\t// Insert empty TR elements if there are any rows without anchored cells. Since the model is always normalized\n\t\t// this can happen only in the document fragment that only part of the table is down-casted.\n\t\tfor ( const tableRow of table.getChildren() ) {\n\t\t\tconst rowIndex = tableRow.index;\n\n\t\t\t// Make sure that this is a table row and not some other element (i.e., caption).\n\t\t\tif ( tableRow.is( 'element', 'tableRow' ) && !viewRows.has( rowIndex ) ) {\n\t\t\t\tviewRows.set( rowIndex, createTr( tableElement, tableRow, rowIndex, tableAttributes, conversionApi ) );\n\t\t\t}\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( table, asWidget ? tableWidget : figureElement );\n\t\tconversionApi.writer.insert( viewPosition, asWidget ? tableWidget : figureElement );\n\t} );\n}\n\n/**\n * Model row element to view `<tr>` element conversion helper.\n *\n * This conversion helper creates the whole `<tr>` element with child elements.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertRow() {\n\treturn dispatcher => dispatcher.on( 'insert:tableRow', ( evt, data, conversionApi ) => {\n\t\tconst tableRow = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( tableRow, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst table = tableRow.parent;\n\n\t\tconst figureElement = conversionApi.mapper.toViewElement( table );\n\t\tconst tableElement = getViewTable( figureElement );\n\n\t\tconst row = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { row } );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// Cache for created table rows.\n\t\tconst viewRows = new Map();\n\n\t\tfor ( const tableSlot of tableWalker ) {\n\t\t\tconst trElement = viewRows.get( row ) || createTr( tableElement, tableRow, row, tableAttributes, conversionApi );\n\t\t\tviewRows.set( row, trElement );\n\n\t\t\t// Consume table cell - it will be always consumed as we convert whole row at once.\n\t\t\tconversionApi.consumable.consume( tableSlot.cell, 'insert' );\n\n\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, 'end' );\n\n\t\t\tcreateViewTableCellElement( tableSlot, tableAttributes, insertPosition, conversionApi, { asWidget: true } );\n\t\t}\n\t} );\n}\n\n/**\n * Model table cell element to view `<td>` or `<th>` element conversion helper.\n *\n * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)\n * and `<td>` otherwise.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertCell() {\n\treturn dispatcher => dispatcher.on( 'insert:tableCell', ( evt, data, conversionApi ) => {\n\t\tconst tableCell = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( tableCell, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\t\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { row: rowIndex } );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// We need to iterate over a table in order to get proper row & column values from a walker\n\t\tfor ( const tableSlot of tableWalker ) {\n\t\t\tif ( tableSlot.cell === tableCell ) {\n\t\t\t\tconst trElement = conversionApi.mapper.toViewElement( tableRow );\n\t\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, tableRow.getChildIndex( tableCell ) );\n\n\t\t\t\tcreateViewTableCellElement( tableSlot, tableAttributes, insertPosition, conversionApi, { asWidget: true } );\n\n\t\t\t\t// No need to iterate further.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} );\n}\n\n/**\n * Conversion helper that acts on heading column table attribute change.\n *\n * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending on the cell column index.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastTableHeadingColumnsChange() {\n\treturn dispatcher => dispatcher.on( 'attribute:headingColumns:table', ( evt, data, conversionApi ) => {\n\t\tconst table = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\tconst oldColumns = data.attributeOldValue;\n\t\tconst newColumns = data.attributeNewValue;\n\n\t\tconst lastColumnToCheck = ( oldColumns > newColumns ? oldColumns : newColumns ) - 1;\n\n\t\tfor ( const tableSlot of new TableWalker( table, { endColumn: lastColumnToCheck } ) ) {\n\t\t\trenameViewTableCellIfRequired( tableSlot, tableAttributes, conversionApi );\n\t\t}\n\t} );\n}\n\n/**\n * Conversion helper that acts on a removed row.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastRemoveRow() {\n\treturn dispatcher => dispatcher.on( 'remove:tableRow', ( evt, data, conversionApi ) => {\n\t\t// Prevent default remove converter.\n\t\tevt.stop();\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst mapper = conversionApi.mapper;\n\n\t\tconst viewStart = mapper.toViewPosition( data.position ).getLastMatchingPosition( value => !value.item.is( 'element', 'tr' ) );\n\t\tconst viewItem = viewStart.nodeAfter;\n\t\tconst tableSection = viewItem.parent;\n\t\tconst viewTable = tableSection.parent;\n\n\t\t// Remove associated <tr> from the view.\n\t\tconst removeRange = viewWriter.createRangeOn( viewItem );\n\t\tconst removed = viewWriter.remove( removeRange );\n\n\t\tfor ( const child of viewWriter.createRangeIn( removed ).getItems() ) {\n\t\t\tmapper.unbindViewElement( child );\n\t\t}\n\n\t\t// Cleanup: Ensure that thead & tbody sections are removed if left empty after removing rows. See #6437, #6391.\n\t\tremoveTableSectionIfEmpty( 'thead', viewTable, conversionApi );\n\t\tremoveTableSectionIfEmpty( 'tbody', viewTable, conversionApi );\n\t}, { priority: 'higher' } );\n}\n\n/**\n * Overrides paragraph inside table cell conversion.\n *\n * This converter:\n * * should be used to override default paragraph conversion in the editing view.\n * * It will only convert <paragraph> placed directly inside <tableCell>.\n * * For a single paragraph without attributes it returns `<span>` to simulate data table.\n * * For all other cases it returns `<p>` element.\n *\n * @param {module:engine/model/element~Element} modelElement\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n * @returns {module:engine/view/containerelement~ContainerElement|undefined}\n */\nexport function convertParagraphInTableCell( modelElement, conversionApi ) {\n\tconst { writer } = conversionApi;\n\n\tif ( !modelElement.parent.is( 'element', 'tableCell' ) ) {\n\t\treturn;\n\t}\n\n\tif ( isSingleParagraphWithoutAttributes( modelElement ) ) {\n\t\treturn writer.createContainerElement( 'span', { class: 'ck-table-bogus-paragraph' } );\n\t} else {\n\t\treturn writer.createContainerElement( 'p' );\n\t}\n}\n\n/**\n * Checks if given model `<paragraph>` is an only child of a parent (`<tableCell>`) and if it has any attribute set.\n *\n * The paragraph should be converted in the editing view to:\n *\n * * If returned `true` - to a `<span class=\"ck-table-bogus-paragraph\">`\n * * If returned `false` - to a `<p>`\n *\n * @param {module:engine/model/element~Element} modelElement\n * @returns {Boolean}\n */\nexport function isSingleParagraphWithoutAttributes( modelElement ) {\n\tconst tableCell = modelElement.parent;\n\n\tconst isSingleParagraph = tableCell.childCount === 1;\n\n\treturn isSingleParagraph && !hasAnyAttribute( modelElement );\n}\n\n// Converts a given {@link module:engine/view/element~Element} to a table widget:\n// * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the table widget element.\n// * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.\n// @param {String} label The element's label. It will be concatenated with the table `alt` attribute if one is present.\n// @returns {module:engine/view/element~Element}\nfunction toTableWidget( viewElement, writer ) {\n\twriter.setCustomProperty( 'table', true, viewElement );\n\n\treturn toWidget( viewElement, writer, { hasSelectionHandle: true } );\n}\n\n// Renames an existing table cell in the view to a given element name.\n//\n// **Note** This method will not do anything if a view table cell has not been converted yet.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} desiredCellElementName\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction renameViewTableCell( tableCell, desiredCellElementName, conversionApi ) {\n\tconst viewWriter = conversionApi.writer;\n\tconst viewCell = conversionApi.mapper.toViewElement( tableCell );\n\n\tconst editable = viewWriter.createEditableElement( desiredCellElementName, viewCell.getAttributes() );\n\tconst renamedCell = toWidgetEditable( editable, viewWriter );\n\n\tviewWriter.insert( viewWriter.createPositionAfter( viewCell ), renamedCell );\n\tviewWriter.move( viewWriter.createRangeIn( viewCell ), viewWriter.createPositionAt( renamedCell, 0 ) );\n\tviewWriter.remove( viewWriter.createRangeOn( viewCell ) );\n\n\tconversionApi.mapper.unbindViewElement( viewCell );\n\tconversionApi.mapper.bindElements( tableCell, renamedCell );\n}\n\n// Renames a table cell element in the view according to its location in the table.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction renameViewTableCellIfRequired( tableSlot, tableAttributes, conversionApi ) {\n\tconst { cell } = tableSlot;\n\n\t// Check whether current columnIndex is overlapped by table cells from previous rows.\n\tconst desiredCellElementName = getCellElementName( tableSlot, tableAttributes );\n\n\tconst viewCell = conversionApi.mapper.toViewElement( cell );\n\n\t// If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view\n\t// because of child conversion is done after parent.\n\tif ( viewCell && viewCell.name !== desiredCellElementName ) {\n\t\trenameViewTableCell( cell, desiredCellElementName, conversionApi );\n\t}\n}\n\n// Creates a table cell element in the view.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {module:engine/view/position~Position} insertPosition\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction createViewTableCellElement( tableSlot, tableAttributes, insertPosition, conversionApi, options ) {\n\tconst asWidget = options && options.asWidget;\n\tconst cellElementName = getCellElementName( tableSlot, tableAttributes );\n\n\tconst cellElement = asWidget ?\n\t\ttoWidgetEditable( conversionApi.writer.createEditableElement( cellElementName ), conversionApi.writer ) :\n\t\tconversionApi.writer.createContainerElement( cellElementName );\n\n\tconst tableCell = tableSlot.cell;\n\n\tconst firstChild = tableCell.getChild( 0 );\n\tconst isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';\n\n\tconversionApi.writer.insert( insertPosition, cellElement );\n\n\tconversionApi.mapper.bindElements( tableCell, cellElement );\n\n\t// Additional requirement for data pipeline to have backward compatible data tables.\n\tif ( !asWidget && isSingleParagraph && !hasAnyAttribute( firstChild ) ) {\n\t\tconst innerParagraph = tableCell.getChild( 0 );\n\n\t\tconversionApi.consumable.consume( innerParagraph, 'insert' );\n\n\t\tconversionApi.mapper.bindElements( innerParagraph, cellElement );\n\t}\n}\n\n// Creates a `<tr>` view element.\n//\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/model/element~Element} tableRow\n// @param {Number} rowIndex\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/element~Element}\nfunction createTr( tableElement, tableRow, rowIndex, tableAttributes, conversionApi ) {\n\t// Will always consume since we're converting <tableRow> element from a parent <table>.\n\tconversionApi.consumable.consume( tableRow, 'insert' );\n\n\tconst trElement = tableRow.isEmpty ?\n\t\tconversionApi.writer.createEmptyElement( 'tr' ) :\n\t\tconversionApi.writer.createContainerElement( 'tr' );\n\n\tconversionApi.mapper.bindElements( tableRow, trElement );\n\n\tconst headingRows = tableAttributes.headingRows;\n\tconst tableSection = getOrCreateTableSection( getSectionName( rowIndex, tableAttributes ), tableElement, conversionApi );\n\n\tconst offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;\n\tconst position = conversionApi.writer.createPositionAt( tableSection, offset );\n\n\tconversionApi.writer.insert( position, trElement );\n\n\treturn trElement;\n}\n\n// Returns `th` for heading cells and `td` for other cells for the current table walker value.\n//\n// @param {module:table/tablewalker~TableSlot} tableSlot\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\nfunction getCellElementName( tableSlot, tableAttributes ) {\n\tconst { row, column } = tableSlot;\n\tconst { headingColumns, headingRows } = tableAttributes;\n\n\t// Column heading are all tableCells in the first `columnHeading` rows.\n\tconst isColumnHeading = headingRows && headingRows > row;\n\n\t// So a whole row gets <th> element.\n\tif ( isColumnHeading ) {\n\t\treturn 'th';\n\t}\n\n\t// Row heading are tableCells which columnIndex is lower then headingColumns.\n\tconst isRowHeading = headingColumns && headingColumns > column;\n\n\treturn isRowHeading ? 'th' : 'td';\n}\n\n// Returns the table section name for the current table walker value.\n//\n// @param {Number} row\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\nfunction getSectionName( row, tableAttributes ) {\n\treturn row < tableAttributes.headingRows ? 'thead' : 'tbody';\n}\n\n// Creates or returns an existing `<tbody>` or `<thead>` element with caching.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} viewTable\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} cachedTableSection An object that stores cached elements.\n// @returns {module:engine/view/containerelement~ContainerElement}\nfunction getOrCreateTableSection( sectionName, viewTable, conversionApi ) {\n\tconst viewTableSection = getExistingTableSectionElement( sectionName, viewTable );\n\n\treturn viewTableSection ? viewTableSection : createTableSection( sectionName, viewTable, conversionApi );\n}\n\n// Finds an existing `<tbody>` or `<thead>` element or returns undefined.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction getExistingTableSectionElement( sectionName, tableElement ) {\n\tfor ( const tableSection of tableElement.getChildren() ) {\n\t\tif ( tableSection.name == sectionName ) {\n\t\t\treturn tableSection;\n\t\t}\n\t}\n}\n\n// Creates a table section at the end of the table.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/containerelement~ContainerElement}\nfunction createTableSection( sectionName, tableElement, conversionApi ) {\n\tconst tableChildElement = conversionApi.writer.createContainerElement( sectionName );\n\n\tconst insertPosition = conversionApi.writer.createPositionAt( tableElement, sectionName == 'tbody' ? 'end' : 0 );\n\n\tconversionApi.writer.insert( insertPosition, tableChildElement );\n\n\treturn tableChildElement;\n}\n\n// Removes an existing `<tbody>` or `<thead>` element if it is empty.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction removeTableSectionIfEmpty( sectionName, tableElement, conversionApi ) {\n\tconst tableSection = getExistingTableSectionElement( sectionName, tableElement );\n\n\tif ( tableSection && tableSection.childCount === 0 ) {\n\t\tconversionApi.writer.remove( conversionApi.writer.createRangeOn( tableSection ) );\n\t}\n}\n\n// Finds a '<table>' element inside the `<figure>` widget.\n//\n// @param {module:engine/view/element~Element} viewFigure\nfunction getViewTable( viewFigure ) {\n\tfor ( const child of viewFigure.getChildren() ) {\n\t\tif ( child.name === 'table' ) {\n\t\t\treturn child;\n\t\t}\n\t}\n}\n\n// Checks if an element has any attributes set.\n//\n// @param {module:engine/model/element~Element element\n// @returns {Boolean}\nfunction hasAnyAttribute( element ) {\n\treturn !![ ...element.getAttributeKeys() ].length;\n}\n"]},"metadata":{},"sourceType":"module"}
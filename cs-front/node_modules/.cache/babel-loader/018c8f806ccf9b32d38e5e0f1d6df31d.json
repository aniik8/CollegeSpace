{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableclipboard\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport TableSelection from './tableselection';\nimport TableWalker from './tablewalker';\nimport TableUtils from './tableutils';\nimport { getColumnIndexes, getRowIndexes, getSelectionAffectedTableCells, isSelectionRectangular, sortRanges } from './utils/selection';\nimport { cropTableToDimensions, getHorizontallyOverlappingCells, getVerticallyOverlappingCells, removeEmptyRowsColumns, splitHorizontally, splitVertically, trimTableCellIfNeeded, adjustLastRowIndex, adjustLastColumnIndex } from './utils/structure';\n/**\n * This plugin adds support for copying/cutting/pasting fragments of tables.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableClipboard extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableClipboard';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [TableSelection, TableUtils];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const viewDocument = editor.editing.view.document;\n    this.listenTo(viewDocument, 'copy', (evt, data) => this._onCopyCut(evt, data));\n    this.listenTo(viewDocument, 'cut', (evt, data) => this._onCopyCut(evt, data));\n    this.listenTo(editor.model, 'insertContent', (evt, args) => this._onInsertContent(evt, ...args), {\n      priority: 'high'\n    });\n    this.decorate('_replaceTableSlotCell');\n  }\n  /**\n   * Copies table content to a clipboard on \"copy\" & \"cut\" events.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the handled event.\n   * @param {Object} data Clipboard event data.\n   */\n\n\n  _onCopyCut(evt, data) {\n    const tableSelection = this.editor.plugins.get(TableSelection);\n\n    if (!tableSelection.getSelectedTableCells()) {\n      return;\n    }\n\n    if (evt.name == 'cut' && this.editor.isReadOnly) {\n      return;\n    }\n\n    data.preventDefault();\n    evt.stop();\n    const dataController = this.editor.data;\n    const viewDocument = this.editor.editing.view.document;\n    const content = dataController.toView(tableSelection.getSelectionAsFragment());\n    viewDocument.fire('clipboardOutput', {\n      dataTransfer: data.dataTransfer,\n      content,\n      method: evt.name\n    });\n  }\n  /**\n   * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside\n   * selected table fragment.\n   *\n   * Depending on selected table fragment:\n   * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.\n   * - If dimensions are equal it will replace selected table fragment with a pasted table contents.\n   *\n   * @private\n   * @param evt\n   * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n   * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n   * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n   */\n\n\n  _onInsertContent(evt, content, selectable) {\n    if (selectable && !selectable.is('documentSelection')) {\n      return;\n    }\n\n    const model = this.editor.model;\n    const tableUtils = this.editor.plugins.get(TableUtils); // We might need to crop table before inserting so reference might change.\n\n    let pastedTable = getTableIfOnlyTableInContent(content, model);\n\n    if (!pastedTable) {\n      return;\n    }\n\n    const selectedTableCells = getSelectionAffectedTableCells(model.document.selection);\n\n    if (!selectedTableCells.length) {\n      removeEmptyRowsColumns(pastedTable, tableUtils);\n      return;\n    } // Override default model.insertContent() handling at this point.\n\n\n    evt.stop();\n    model.change(writer => {\n      const pastedDimensions = {\n        width: tableUtils.getColumns(pastedTable),\n        height: tableUtils.getRows(pastedTable)\n      }; // Prepare the table for pasting.\n\n      const selection = prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils); // Beyond this point we operate on a fixed content table with rectangular selection and proper last row/column values.\n\n      const selectionHeight = selection.lastRow - selection.firstRow + 1;\n      const selectionWidth = selection.lastColumn - selection.firstColumn + 1; // Crop pasted table if:\n      // - Pasted table dimensions exceeds selection area.\n      // - Pasted table has broken layout (ie some cells sticks out by the table dimensions established by the first and last row).\n      //\n      // Note: The table dimensions are established by the width of the first row and the total number of rows.\n      // It is possible to programmatically create a table that has rows which would have cells anchored beyond first row width but\n      // such table will not be created by other editing solutions.\n\n      const cropDimensions = {\n        startRow: 0,\n        startColumn: 0,\n        endRow: Math.min(selectionHeight, pastedDimensions.height) - 1,\n        endColumn: Math.min(selectionWidth, pastedDimensions.width) - 1\n      };\n      pastedTable = cropTableToDimensions(pastedTable, cropDimensions, writer); // Content table to which we insert a pasted table.\n\n      const selectedTable = selectedTableCells[0].findAncestor('table');\n\n      const cellsToSelect = this._replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer);\n\n      if (this.editor.plugins.get('TableSelection').isEnabled) {\n        // Selection ranges must be sorted because the first and last selection ranges are considered\n        // as anchor/focus cell ranges for multi-cell selection.\n        const selectionRanges = sortRanges(cellsToSelect.map(cell => writer.createRangeOn(cell)));\n        writer.setSelection(selectionRanges);\n      } else {\n        // Set selection inside first cell if multi-cell selection is disabled.\n        writer.setSelection(cellsToSelect[0], 0);\n      }\n    });\n  }\n  /**\n   * Replaces the part of selectedTable with pastedTable.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} pastedTable\n   * @param {Object} pastedDimensions\n   * @param {Number} pastedDimensions.height\n   * @param {Number} pastedDimensions.width\n   * @param {module:engine/model/element~Element} selectedTable\n   * @param {Object} selection\n   * @param {Number} selection.firstColumn\n   * @param {Number} selection.firstRow\n   * @param {Number} selection.lastColumn\n   * @param {Number} selection.lastRow\n   * @param {module:engine/model/writer~Writer} writer\n   * @returns {Array.<module:engine/model/element~Element>}\n   */\n\n\n  _replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer) {\n    const {\n      width: pastedWidth,\n      height: pastedHeight\n    } = pastedDimensions; // Holds two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.\n\n    const pastedTableLocationMap = createLocationMap(pastedTable, pastedWidth, pastedHeight);\n    const selectedTableMap = [...new TableWalker(selectedTable, {\n      startRow: selection.firstRow,\n      endRow: selection.lastRow,\n      startColumn: selection.firstColumn,\n      endColumn: selection.lastColumn,\n      includeAllSlots: true\n    })]; // Selection must be set to pasted cells (some might be removed or new created).\n\n    const cellsToSelect = []; // Store next cell insert position.\n\n    let insertPosition; // Content table replace cells algorithm iterates over a selected table fragment and:\n    //\n    // - Removes existing table cells at current slot (location).\n    // - Inserts cell from a pasted table for a matched slots.\n    //\n    // This ensures proper table geometry after the paste\n\n    for (const tableSlot of selectedTableMap) {\n      const {\n        row,\n        column\n      } = tableSlot; // Save the insert position for current row start.\n\n      if (column === selection.firstColumn) {\n        insertPosition = tableSlot.getPositionBefore();\n      } // Map current table slot location to an pasted table slot location.\n\n\n      const pastedRow = row - selection.firstRow;\n      const pastedColumn = column - selection.firstColumn;\n      const pastedCell = pastedTableLocationMap[pastedRow % pastedHeight][pastedColumn % pastedWidth]; // Clone cell to insert (to duplicate its attributes and children).\n      // Cloning is required to support repeating pasted table content when inserting to a bigger selection.\n\n      const cellToInsert = pastedCell ? writer.cloneElement(pastedCell) : null; // Replace the cell from the current slot with new table cell.\n\n      const newTableCell = this._replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer); // The cell was only removed.\n\n\n      if (!newTableCell) {\n        continue;\n      } // Trim the cell if it's row/col-spans would exceed selection area.\n\n\n      trimTableCellIfNeeded(newTableCell, row, column, selection.lastRow, selection.lastColumn, writer);\n      cellsToSelect.push(newTableCell);\n      insertPosition = writer.createPositionAfter(newTableCell);\n    } // If there are any headings, all the cells that overlap from heading must be splitted.\n\n\n    const headingRows = parseInt(selectedTable.getAttribute('headingRows') || 0);\n    const headingColumns = parseInt(selectedTable.getAttribute('headingColumns') || 0);\n    const areHeadingRowsIntersectingSelection = selection.firstRow < headingRows && headingRows <= selection.lastRow;\n    const areHeadingColumnsIntersectingSelection = selection.firstColumn < headingColumns && headingColumns <= selection.lastColumn;\n\n    if (areHeadingRowsIntersectingSelection) {\n      const columnsLimit = {\n        first: selection.firstColumn,\n        last: selection.lastColumn\n      };\n      const newCells = doHorizontalSplit(selectedTable, headingRows, columnsLimit, writer, selection.firstRow);\n      cellsToSelect.push(...newCells);\n    }\n\n    if (areHeadingColumnsIntersectingSelection) {\n      const rowsLimit = {\n        first: selection.firstRow,\n        last: selection.lastRow\n      };\n      const newCells = doVerticalSplit(selectedTable, headingColumns, rowsLimit, writer);\n      cellsToSelect.push(...newCells);\n    }\n\n    return cellsToSelect;\n  }\n  /**\n   * Replaces a single table slot.\n   *\n   * @private\n   * @param {module:table/tablewalker~TableSlot} tableSlot\n   * @param {module:engine/model/element~Element} cellToInsert\n   * @param {module:engine/model/position~Position} insertPosition\n   * @param {module:engine/model/writer~Writer} writer\n   * @returns {module:engine/model/element~Element|null} Inserted table cell or null if slot should remain empty.\n   */\n\n\n  _replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer) {\n    const {\n      cell,\n      isAnchor\n    } = tableSlot; // If the slot is occupied by a cell in a selected table - remove it.\n    // The slot of this cell will be either:\n    // - Replaced by a pasted table cell.\n    // - Spanned by a previously pasted table cell.\n\n    if (isAnchor) {\n      writer.remove(cell);\n    } // There is no cell to insert (might be spanned by other cell in a pasted table) - advance to the next content table slot.\n\n\n    if (!cellToInsert) {\n      return null;\n    }\n\n    writer.insert(cellToInsert, insertPosition);\n    return cellToInsert;\n  }\n\n}\n/**\n * Extract table for pasting into table.\n *\n * @private\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/model~Model} model The editor model.\n * @returns {module:engine/model/element~Element|null}\n */\n\nexport function getTableIfOnlyTableInContent(content, model) {\n  if (!content.is('documentFragment') && !content.is('element')) {\n    return null;\n  } // Table passed directly.\n\n\n  if (content.is('element', 'table')) {\n    return content;\n  } // We do not support mixed content when pasting table into table.\n  // See: https://github.com/ckeditor/ckeditor5/issues/6817.\n\n\n  if (content.childCount == 1 && content.getChild(0).is('element', 'table')) {\n    return content.getChild(0);\n  } // If there are only whitespaces around a table then use that table for pasting.\n\n\n  const contentRange = model.createRangeIn(content);\n\n  for (const element of contentRange.getItems()) {\n    if (element.is('element', 'table')) {\n      // Stop checking if there is some content before table.\n      const rangeBefore = model.createRange(contentRange.start, model.createPositionBefore(element));\n\n      if (model.hasContent(rangeBefore, {\n        ignoreWhitespaces: true\n      })) {\n        return null;\n      } // Stop checking if there is some content after table.\n\n\n      const rangeAfter = model.createRange(model.createPositionAfter(element), contentRange.end);\n\n      if (model.hasContent(rangeAfter, {\n        ignoreWhitespaces: true\n      })) {\n        return null;\n      } // There wasn't any content neither before nor after.\n\n\n      return element;\n    }\n  }\n\n  return null;\n} // Prepares a table for pasting and returns adjusted selection dimensions.\n//\n// @param {Array.<module:engine/model/element~Element>} selectedTableCells\n// @param {Object} pastedDimensions\n// @param {Number} pastedDimensions.height\n// @param {Number} pastedDimensions.width\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {Object} selection\n// @returns {Number} selection.firstColumn\n// @returns {Number} selection.firstRow\n// @returns {Number} selection.lastColumn\n// @returns {Number} selection.lastRow\n\nfunction prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils) {\n  const selectedTable = selectedTableCells[0].findAncestor('table');\n  const columnIndexes = getColumnIndexes(selectedTableCells);\n  const rowIndexes = getRowIndexes(selectedTableCells);\n  const selection = {\n    firstColumn: columnIndexes.first,\n    lastColumn: columnIndexes.last,\n    firstRow: rowIndexes.first,\n    lastRow: rowIndexes.last\n  }; // Single cell selected - expand selection to pasted table dimensions.\n\n  const shouldExpandSelection = selectedTableCells.length === 1;\n\n  if (shouldExpandSelection) {\n    selection.lastRow += pastedDimensions.height - 1;\n    selection.lastColumn += pastedDimensions.width - 1;\n    expandTableSize(selectedTable, selection.lastRow + 1, selection.lastColumn + 1, tableUtils);\n  } // In case of expanding selection we do not reset the selection so in this case we will always try to fix selection\n  // like in the case of a non-rectangular area. This might be fixed by re-setting selected cells array but this shortcut is safe.\n\n\n  if (shouldExpandSelection || !isSelectionRectangular(selectedTableCells, tableUtils)) {\n    // For a non-rectangular selection (ie in which some cells sticks out from a virtual selection rectangle) we need to create\n    // a table layout that has a rectangular selection. This will split cells so the selection become rectangular.\n    // Beyond this point we will operate on fixed content table.\n    splitCellsToRectangularSelection(selectedTable, selection, writer);\n  } // However a selected table fragment might be invalid if examined alone. Ie such table fragment:\n  //\n  //    +---+---+---+---+\n  //  0 | a | b | c | d |\n  //    +   +   +---+---+\n  //  1 |   | e | f | g |\n  //    +   +---+   +---+\n  //  2 |   | h |   | i | <- last row, each cell has rowspan = 2,\n  //    +   +   +   +   +    so we need to return 3, not 2\n  //  3 |   |   |   |   |\n  //    +---+---+---+---+\n  //\n  // is invalid as the cells \"h\" and \"i\" have rowspans.\n  // This case needs only adjusting the selection dimension as the rest of the algorithm operates on empty slots also.\n  else {\n    selection.lastRow = adjustLastRowIndex(selectedTable, selection);\n    selection.lastColumn = adjustLastColumnIndex(selectedTable, selection);\n  }\n\n  return selection;\n} // Expand table (in place) to expected size.\n\n\nfunction expandTableSize(table, expectedHeight, expectedWidth, tableUtils) {\n  const tableWidth = tableUtils.getColumns(table);\n  const tableHeight = tableUtils.getRows(table);\n\n  if (expectedWidth > tableWidth) {\n    tableUtils.insertColumns(table, {\n      at: tableWidth,\n      columns: expectedWidth - tableWidth\n    });\n  }\n\n  if (expectedHeight > tableHeight) {\n    tableUtils.insertRows(table, {\n      at: tableHeight,\n      rows: expectedHeight - tableHeight\n    });\n  }\n} // Returns two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.\n//\n// At given row & column location it might be one of:\n//\n// * cell - cell from pasted table anchored at this location.\n// * null - if no cell is anchored at this location.\n//\n// For instance, from a table below:\n//\n//\t\t+----+----+----+----+\n//\t\t| 00 | 01 | 02 | 03 |\n//\t\t+    +----+----+----+\n//\t\t|    | 11      | 13 |\n//\t\t+----+         +----+\n//\t\t| 20 |         | 23 |\n//\t\t+----+----+----+----+\n//\n// The method will return an array (numbers represents cell element):\n//\n//\tconst map = [\n//\t\t[ '00', '01', '02', '03' ],\n//\t\t[ null, '11', null, '13' ],\n//\t\t[ '20', null, null, '23' ]\n//\t]\n//\n// This allows for a quick access to table at give row & column. For instance to access table cell \"13\" from pasted table call:\n//\n//\t\tconst cell = map[ 1 ][ 3 ]\n//\n\n\nfunction createLocationMap(table, width, height) {\n  // Create height x width (row x column) two-dimensional table to store cells.\n  const map = new Array(height).fill(null).map(() => new Array(width).fill(null));\n\n  for (const {\n    column,\n    row,\n    cell\n  } of new TableWalker(table)) {\n    map[row][column] = cell;\n  }\n\n  return map;\n} // Make selected cells rectangular by splitting the cells that stand out from a rectangular selection.\n//\n// In the table below a selection is shown with \"::\" and slots with anchor cells are named.\n//\n// +----+----+----+----+----+                    +----+----+----+----+----+\n// | 00 | 01 | 02 | 03      |                    | 00 | 01 | 02 | 03      |\n// +    +----+    +----+----+                    |    ::::::::::::::::----+\n// |    | 11 |    | 13 | 14 |                    |    ::11 |    | 13:: 14 |    <- first row\n// +----+----+    +    +----+                    +----::---|    |   ::----+\n// | 20 | 21 |    |    | 24 |   select cells:    | 20 ::21 |    |   :: 24 |\n// +----+----+    +----+----+     11 -> 33       +----::---|    |---::----+\n// | 30      |    | 33 | 34 |                    | 30 ::   |    | 33:: 34 |    <- last row\n// +         +    +----+    +                    |    ::::::::::::::::    +\n// |         |    | 43 |    |                    |         |    | 43 |    |\n// +----+----+----+----+----+                    +----+----+----+----+----+\n//                                                      ^          ^\n//                                                     first & last columns\n//\n// Will update table to:\n//\n//                       +----+----+----+----+----+\n//                       | 00 | 01 | 02 | 03      |\n//                       +    +----+----+----+----+\n//                       |    | 11 |    | 13 | 14 |\n//                       +----+----+    +    +----+\n//                       | 20 | 21 |    |    | 24 |\n//                       +----+----+    +----+----+\n//                       | 30 |    |    | 33 | 34 |\n//                       +    +----+----+----+    +\n//                       |    |    |    | 43 |    |\n//                       +----+----+----+----+----+\n//\n// In th example above:\n// - Cell \"02\" which have `rowspan = 4` must be trimmed at first and at after last row.\n// - Cell \"03\" which have `rowspan = 2` and `colspan = 2` must be trimmed at first column and after last row.\n// - Cells \"00\", \"03\" & \"30\" which cannot be cut by this algorithm as they are outside the trimmed area.\n// - Cell \"13\" cannot be cut as it is inside the trimmed area.\n\n\nfunction splitCellsToRectangularSelection(table, dimensions, writer) {\n  const {\n    firstRow,\n    lastRow,\n    firstColumn,\n    lastColumn\n  } = dimensions;\n  const rowIndexes = {\n    first: firstRow,\n    last: lastRow\n  };\n  const columnIndexes = {\n    first: firstColumn,\n    last: lastColumn\n  }; // 1. Split cells vertically in two steps as first step might create cells that needs to split again.\n\n  doVerticalSplit(table, firstColumn, rowIndexes, writer);\n  doVerticalSplit(table, lastColumn + 1, rowIndexes, writer); // 2. Split cells horizontally in two steps as first step might create cells that needs to split again.\n\n  doHorizontalSplit(table, firstRow, columnIndexes, writer);\n  doHorizontalSplit(table, lastRow + 1, columnIndexes, writer, firstRow);\n}\n\nfunction doHorizontalSplit(table, splitRow, limitColumns, writer) {\n  let startRow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  // If selection starts at first row then no split is needed.\n  if (splitRow < 1) {\n    return;\n  }\n\n  const overlappingCells = getVerticallyOverlappingCells(table, splitRow, startRow); // Filter out cells that are not touching insides of the rectangular selection.\n\n  const cellsToSplit = overlappingCells.filter(_ref => {\n    let {\n      column,\n      cellWidth\n    } = _ref;\n    return isAffectedBySelection(column, cellWidth, limitColumns);\n  });\n  return cellsToSplit.map(_ref2 => {\n    let {\n      cell\n    } = _ref2;\n    return splitHorizontally(cell, splitRow, writer);\n  });\n}\n\nfunction doVerticalSplit(table, splitColumn, limitRows, writer) {\n  // If selection starts at first column then no split is needed.\n  if (splitColumn < 1) {\n    return;\n  }\n\n  const overlappingCells = getHorizontallyOverlappingCells(table, splitColumn); // Filter out cells that are not touching insides of the rectangular selection.\n\n  const cellsToSplit = overlappingCells.filter(_ref3 => {\n    let {\n      row,\n      cellHeight\n    } = _ref3;\n    return isAffectedBySelection(row, cellHeight, limitRows);\n  });\n  return cellsToSplit.map(_ref4 => {\n    let {\n      cell,\n      column\n    } = _ref4;\n    return splitVertically(cell, column, splitColumn, writer);\n  });\n} // Checks if cell at given row (column) is affected by a rectangular selection defined by first/last column (row).\n//\n// The same check is used for row as for column.\n\n\nfunction isAffectedBySelection(index, span, limit) {\n  const endIndex = index + span - 1;\n  const {\n    first,\n    last\n  } = limit;\n  const isInsideSelection = index >= first && index <= last;\n  const overlapsSelectionFromOutside = index < first && endIndex >= first;\n  return isInsideSelection || overlapsSelectionFromOutside;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tableclipboard.js"],"names":["Plugin","TableSelection","TableWalker","TableUtils","getColumnIndexes","getRowIndexes","getSelectionAffectedTableCells","isSelectionRectangular","sortRanges","cropTableToDimensions","getHorizontallyOverlappingCells","getVerticallyOverlappingCells","removeEmptyRowsColumns","splitHorizontally","splitVertically","trimTableCellIfNeeded","adjustLastRowIndex","adjustLastColumnIndex","TableClipboard","pluginName","requires","init","editor","viewDocument","editing","view","document","listenTo","evt","data","_onCopyCut","model","args","_onInsertContent","priority","decorate","tableSelection","plugins","get","getSelectedTableCells","name","isReadOnly","preventDefault","stop","dataController","content","toView","getSelectionAsFragment","fire","dataTransfer","method","selectable","is","tableUtils","pastedTable","getTableIfOnlyTableInContent","selectedTableCells","selection","length","change","writer","pastedDimensions","width","getColumns","height","getRows","prepareTableForPasting","selectionHeight","lastRow","firstRow","selectionWidth","lastColumn","firstColumn","cropDimensions","startRow","startColumn","endRow","Math","min","endColumn","selectedTable","findAncestor","cellsToSelect","_replaceSelectedCellsWithPasted","isEnabled","selectionRanges","map","cell","createRangeOn","setSelection","pastedWidth","pastedHeight","pastedTableLocationMap","createLocationMap","selectedTableMap","includeAllSlots","insertPosition","tableSlot","row","column","getPositionBefore","pastedRow","pastedColumn","pastedCell","cellToInsert","cloneElement","newTableCell","_replaceTableSlotCell","push","createPositionAfter","headingRows","parseInt","getAttribute","headingColumns","areHeadingRowsIntersectingSelection","areHeadingColumnsIntersectingSelection","columnsLimit","first","last","newCells","doHorizontalSplit","rowsLimit","doVerticalSplit","isAnchor","remove","insert","childCount","getChild","contentRange","createRangeIn","element","getItems","rangeBefore","createRange","start","createPositionBefore","hasContent","ignoreWhitespaces","rangeAfter","end","columnIndexes","rowIndexes","shouldExpandSelection","expandTableSize","splitCellsToRectangularSelection","table","expectedHeight","expectedWidth","tableWidth","tableHeight","insertColumns","at","columns","insertRows","rows","Array","fill","dimensions","splitRow","limitColumns","overlappingCells","cellsToSplit","filter","cellWidth","isAffectedBySelection","splitColumn","limitRows","cellHeight","index","span","limit","endIndex","isInsideSelection","overlapsSelectionFromOutside"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableclipboard\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\n\nimport TableSelection from './tableselection';\nimport TableWalker from './tablewalker';\nimport TableUtils from './tableutils';\nimport { getColumnIndexes, getRowIndexes, getSelectionAffectedTableCells, isSelectionRectangular, sortRanges } from './utils/selection';\nimport {\n\tcropTableToDimensions,\n\tgetHorizontallyOverlappingCells,\n\tgetVerticallyOverlappingCells,\n\tremoveEmptyRowsColumns,\n\tsplitHorizontally,\n\tsplitVertically,\n\ttrimTableCellIfNeeded,\n\tadjustLastRowIndex,\n\tadjustLastColumnIndex\n} from './utils/structure';\n\n/**\n * This plugin adds support for copying/cutting/pasting fragments of tables.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableClipboard extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableClipboard';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ TableSelection, TableUtils ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst viewDocument = editor.editing.view.document;\n\n\t\tthis.listenTo( viewDocument, 'copy', ( evt, data ) => this._onCopyCut( evt, data ) );\n\t\tthis.listenTo( viewDocument, 'cut', ( evt, data ) => this._onCopyCut( evt, data ) );\n\t\tthis.listenTo( editor.model, 'insertContent', ( evt, args ) => this._onInsertContent( evt, ...args ), { priority: 'high' } );\n\n\t\tthis.decorate( '_replaceTableSlotCell' );\n\t}\n\n\t/**\n\t * Copies table content to a clipboard on \"copy\" & \"cut\" events.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the handled event.\n\t * @param {Object} data Clipboard event data.\n\t */\n\t_onCopyCut( evt, data ) {\n\t\tconst tableSelection = this.editor.plugins.get( TableSelection );\n\n\t\tif ( !tableSelection.getSelectedTableCells() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( evt.name == 'cut' && this.editor.isReadOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.preventDefault();\n\t\tevt.stop();\n\n\t\tconst dataController = this.editor.data;\n\t\tconst viewDocument = this.editor.editing.view.document;\n\n\t\tconst content = dataController.toView( tableSelection.getSelectionAsFragment() );\n\n\t\tviewDocument.fire( 'clipboardOutput', {\n\t\t\tdataTransfer: data.dataTransfer,\n\t\t\tcontent,\n\t\t\tmethod: evt.name\n\t\t} );\n\t}\n\n\t/**\n\t * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside\n\t * selected table fragment.\n\t *\n\t * Depending on selected table fragment:\n\t * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.\n\t * - If dimensions are equal it will replace selected table fragment with a pasted table contents.\n\t *\n\t * @private\n\t * @param evt\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n\t * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n\t */\n\t_onInsertContent( evt, content, selectable ) {\n\t\tif ( selectable && !selectable.is( 'documentSelection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst model = this.editor.model;\n\t\tconst tableUtils = this.editor.plugins.get( TableUtils );\n\n\t\t// We might need to crop table before inserting so reference might change.\n\t\tlet pastedTable = getTableIfOnlyTableInContent( content, model );\n\n\t\tif ( !pastedTable ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectedTableCells = getSelectionAffectedTableCells( model.document.selection );\n\n\t\tif ( !selectedTableCells.length ) {\n\t\t\tremoveEmptyRowsColumns( pastedTable, tableUtils );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Override default model.insertContent() handling at this point.\n\t\tevt.stop();\n\n\t\tmodel.change( writer => {\n\t\t\tconst pastedDimensions = {\n\t\t\t\twidth: tableUtils.getColumns( pastedTable ),\n\t\t\t\theight: tableUtils.getRows( pastedTable )\n\t\t\t};\n\n\t\t\t// Prepare the table for pasting.\n\t\t\tconst selection = prepareTableForPasting( selectedTableCells, pastedDimensions, writer, tableUtils );\n\n\t\t\t// Beyond this point we operate on a fixed content table with rectangular selection and proper last row/column values.\n\n\t\t\tconst selectionHeight = selection.lastRow - selection.firstRow + 1;\n\t\t\tconst selectionWidth = selection.lastColumn - selection.firstColumn + 1;\n\n\t\t\t// Crop pasted table if:\n\t\t\t// - Pasted table dimensions exceeds selection area.\n\t\t\t// - Pasted table has broken layout (ie some cells sticks out by the table dimensions established by the first and last row).\n\t\t\t//\n\t\t\t// Note: The table dimensions are established by the width of the first row and the total number of rows.\n\t\t\t// It is possible to programmatically create a table that has rows which would have cells anchored beyond first row width but\n\t\t\t// such table will not be created by other editing solutions.\n\t\t\tconst cropDimensions = {\n\t\t\t\tstartRow: 0,\n\t\t\t\tstartColumn: 0,\n\t\t\t\tendRow: Math.min( selectionHeight, pastedDimensions.height ) - 1,\n\t\t\t\tendColumn: Math.min( selectionWidth, pastedDimensions.width ) - 1\n\t\t\t};\n\n\t\t\tpastedTable = cropTableToDimensions( pastedTable, cropDimensions, writer );\n\n\t\t\t// Content table to which we insert a pasted table.\n\t\t\tconst selectedTable = selectedTableCells[ 0 ].findAncestor( 'table' );\n\n\t\t\tconst cellsToSelect = this._replaceSelectedCellsWithPasted( pastedTable, pastedDimensions, selectedTable, selection, writer );\n\n\t\t\tif ( this.editor.plugins.get( 'TableSelection' ).isEnabled ) {\n\t\t\t\t// Selection ranges must be sorted because the first and last selection ranges are considered\n\t\t\t\t// as anchor/focus cell ranges for multi-cell selection.\n\t\t\t\tconst selectionRanges = sortRanges( cellsToSelect.map( cell => writer.createRangeOn( cell ) ) );\n\n\t\t\t\twriter.setSelection( selectionRanges );\n\t\t\t} else {\n\t\t\t\t// Set selection inside first cell if multi-cell selection is disabled.\n\t\t\t\twriter.setSelection( cellsToSelect[ 0 ], 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Replaces the part of selectedTable with pastedTable.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} pastedTable\n\t * @param {Object} pastedDimensions\n\t * @param {Number} pastedDimensions.height\n\t * @param {Number} pastedDimensions.width\n\t * @param {module:engine/model/element~Element} selectedTable\n\t * @param {Object} selection\n\t * @param {Number} selection.firstColumn\n\t * @param {Number} selection.firstRow\n\t * @param {Number} selection.lastColumn\n\t * @param {Number} selection.lastRow\n\t * @param {module:engine/model/writer~Writer} writer\n\t * @returns {Array.<module:engine/model/element~Element>}\n\t */\n\t_replaceSelectedCellsWithPasted( pastedTable, pastedDimensions, selectedTable, selection, writer ) {\n\t\tconst { width: pastedWidth, height: pastedHeight } = pastedDimensions;\n\n\t\t// Holds two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.\n\t\tconst pastedTableLocationMap = createLocationMap( pastedTable, pastedWidth, pastedHeight );\n\n\t\tconst selectedTableMap = [ ...new TableWalker( selectedTable, {\n\t\t\tstartRow: selection.firstRow,\n\t\t\tendRow: selection.lastRow,\n\t\t\tstartColumn: selection.firstColumn,\n\t\t\tendColumn: selection.lastColumn,\n\t\t\tincludeAllSlots: true\n\t\t} ) ];\n\n\t\t// Selection must be set to pasted cells (some might be removed or new created).\n\t\tconst cellsToSelect = [];\n\n\t\t// Store next cell insert position.\n\t\tlet insertPosition;\n\n\t\t// Content table replace cells algorithm iterates over a selected table fragment and:\n\t\t//\n\t\t// - Removes existing table cells at current slot (location).\n\t\t// - Inserts cell from a pasted table for a matched slots.\n\t\t//\n\t\t// This ensures proper table geometry after the paste\n\t\tfor ( const tableSlot of selectedTableMap ) {\n\t\t\tconst { row, column } = tableSlot;\n\n\t\t\t// Save the insert position for current row start.\n\t\t\tif ( column === selection.firstColumn ) {\n\t\t\t\tinsertPosition = tableSlot.getPositionBefore();\n\t\t\t}\n\n\t\t\t// Map current table slot location to an pasted table slot location.\n\t\t\tconst pastedRow = row - selection.firstRow;\n\t\t\tconst pastedColumn = column - selection.firstColumn;\n\t\t\tconst pastedCell = pastedTableLocationMap[ pastedRow % pastedHeight ][ pastedColumn % pastedWidth ];\n\n\t\t\t// Clone cell to insert (to duplicate its attributes and children).\n\t\t\t// Cloning is required to support repeating pasted table content when inserting to a bigger selection.\n\t\t\tconst cellToInsert = pastedCell ? writer.cloneElement( pastedCell ) : null;\n\n\t\t\t// Replace the cell from the current slot with new table cell.\n\t\t\tconst newTableCell = this._replaceTableSlotCell( tableSlot, cellToInsert, insertPosition, writer );\n\n\t\t\t// The cell was only removed.\n\t\t\tif ( !newTableCell ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Trim the cell if it's row/col-spans would exceed selection area.\n\t\t\ttrimTableCellIfNeeded( newTableCell, row, column, selection.lastRow, selection.lastColumn, writer );\n\n\t\t\tcellsToSelect.push( newTableCell );\n\n\t\t\tinsertPosition = writer.createPositionAfter( newTableCell );\n\t\t}\n\n\t\t// If there are any headings, all the cells that overlap from heading must be splitted.\n\t\tconst headingRows = parseInt( selectedTable.getAttribute( 'headingRows' ) || 0 );\n\t\tconst headingColumns = parseInt( selectedTable.getAttribute( 'headingColumns' ) || 0 );\n\n\t\tconst areHeadingRowsIntersectingSelection = selection.firstRow < headingRows && headingRows <= selection.lastRow;\n\t\tconst areHeadingColumnsIntersectingSelection = selection.firstColumn < headingColumns && headingColumns <= selection.lastColumn;\n\n\t\tif ( areHeadingRowsIntersectingSelection ) {\n\t\t\tconst columnsLimit = { first: selection.firstColumn, last: selection.lastColumn };\n\t\t\tconst newCells = doHorizontalSplit( selectedTable, headingRows, columnsLimit, writer, selection.firstRow );\n\n\t\t\tcellsToSelect.push( ...newCells );\n\t\t}\n\n\t\tif ( areHeadingColumnsIntersectingSelection ) {\n\t\t\tconst rowsLimit = { first: selection.firstRow, last: selection.lastRow };\n\t\t\tconst newCells = doVerticalSplit( selectedTable, headingColumns, rowsLimit, writer );\n\n\t\t\tcellsToSelect.push( ...newCells );\n\t\t}\n\n\t\treturn cellsToSelect;\n\t}\n\n\t/**\n\t * Replaces a single table slot.\n\t *\n\t * @private\n\t * @param {module:table/tablewalker~TableSlot} tableSlot\n\t * @param {module:engine/model/element~Element} cellToInsert\n\t * @param {module:engine/model/position~Position} insertPosition\n\t * @param {module:engine/model/writer~Writer} writer\n\t * @returns {module:engine/model/element~Element|null} Inserted table cell or null if slot should remain empty.\n\t */\n\t_replaceTableSlotCell( tableSlot, cellToInsert, insertPosition, writer ) {\n\t\tconst { cell, isAnchor } = tableSlot;\n\n\t\t// If the slot is occupied by a cell in a selected table - remove it.\n\t\t// The slot of this cell will be either:\n\t\t// - Replaced by a pasted table cell.\n\t\t// - Spanned by a previously pasted table cell.\n\t\tif ( isAnchor ) {\n\t\t\twriter.remove( cell );\n\t\t}\n\n\t\t// There is no cell to insert (might be spanned by other cell in a pasted table) - advance to the next content table slot.\n\t\tif ( !cellToInsert ) {\n\t\t\treturn null;\n\t\t}\n\n\t\twriter.insert( cellToInsert, insertPosition );\n\n\t\treturn cellToInsert;\n\t}\n}\n\n/**\n * Extract table for pasting into table.\n *\n * @private\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/model~Model} model The editor model.\n * @returns {module:engine/model/element~Element|null}\n */\nexport function getTableIfOnlyTableInContent( content, model ) {\n\tif ( !content.is( 'documentFragment' ) && !content.is( 'element' ) ) {\n\t\treturn null;\n\t}\n\n\t// Table passed directly.\n\tif ( content.is( 'element', 'table' ) ) {\n\t\treturn content;\n\t}\n\n\t// We do not support mixed content when pasting table into table.\n\t// See: https://github.com/ckeditor/ckeditor5/issues/6817.\n\tif ( content.childCount == 1 && content.getChild( 0 ).is( 'element', 'table' ) ) {\n\t\treturn content.getChild( 0 );\n\t}\n\n\t// If there are only whitespaces around a table then use that table for pasting.\n\n\tconst contentRange = model.createRangeIn( content );\n\n\tfor ( const element of contentRange.getItems() ) {\n\t\tif ( element.is( 'element', 'table' ) ) {\n\t\t\t// Stop checking if there is some content before table.\n\t\t\tconst rangeBefore = model.createRange( contentRange.start, model.createPositionBefore( element ) );\n\n\t\t\tif ( model.hasContent( rangeBefore, { ignoreWhitespaces: true } ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Stop checking if there is some content after table.\n\t\t\tconst rangeAfter = model.createRange( model.createPositionAfter( element ), contentRange.end );\n\n\t\t\tif ( model.hasContent( rangeAfter, { ignoreWhitespaces: true } ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// There wasn't any content neither before nor after.\n\t\t\treturn element;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Prepares a table for pasting and returns adjusted selection dimensions.\n//\n// @param {Array.<module:engine/model/element~Element>} selectedTableCells\n// @param {Object} pastedDimensions\n// @param {Number} pastedDimensions.height\n// @param {Number} pastedDimensions.width\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {Object} selection\n// @returns {Number} selection.firstColumn\n// @returns {Number} selection.firstRow\n// @returns {Number} selection.lastColumn\n// @returns {Number} selection.lastRow\nfunction prepareTableForPasting( selectedTableCells, pastedDimensions, writer, tableUtils ) {\n\tconst selectedTable = selectedTableCells[ 0 ].findAncestor( 'table' );\n\n\tconst columnIndexes = getColumnIndexes( selectedTableCells );\n\tconst rowIndexes = getRowIndexes( selectedTableCells );\n\n\tconst selection = {\n\t\tfirstColumn: columnIndexes.first,\n\t\tlastColumn: columnIndexes.last,\n\t\tfirstRow: rowIndexes.first,\n\t\tlastRow: rowIndexes.last\n\t};\n\n\t// Single cell selected - expand selection to pasted table dimensions.\n\tconst shouldExpandSelection = selectedTableCells.length === 1;\n\n\tif ( shouldExpandSelection ) {\n\t\tselection.lastRow += pastedDimensions.height - 1;\n\t\tselection.lastColumn += pastedDimensions.width - 1;\n\n\t\texpandTableSize( selectedTable, selection.lastRow + 1, selection.lastColumn + 1, tableUtils );\n\t}\n\n\t// In case of expanding selection we do not reset the selection so in this case we will always try to fix selection\n\t// like in the case of a non-rectangular area. This might be fixed by re-setting selected cells array but this shortcut is safe.\n\tif ( shouldExpandSelection || !isSelectionRectangular( selectedTableCells, tableUtils ) ) {\n\t\t// For a non-rectangular selection (ie in which some cells sticks out from a virtual selection rectangle) we need to create\n\t\t// a table layout that has a rectangular selection. This will split cells so the selection become rectangular.\n\t\t// Beyond this point we will operate on fixed content table.\n\t\tsplitCellsToRectangularSelection( selectedTable, selection, writer );\n\t}\n\t// However a selected table fragment might be invalid if examined alone. Ie such table fragment:\n\t//\n\t//    +---+---+---+---+\n\t//  0 | a | b | c | d |\n\t//    +   +   +---+---+\n\t//  1 |   | e | f | g |\n\t//    +   +---+   +---+\n\t//  2 |   | h |   | i | <- last row, each cell has rowspan = 2,\n\t//    +   +   +   +   +    so we need to return 3, not 2\n\t//  3 |   |   |   |   |\n\t//    +---+---+---+---+\n\t//\n\t// is invalid as the cells \"h\" and \"i\" have rowspans.\n\t// This case needs only adjusting the selection dimension as the rest of the algorithm operates on empty slots also.\n\telse {\n\t\tselection.lastRow = adjustLastRowIndex( selectedTable, selection );\n\t\tselection.lastColumn = adjustLastColumnIndex( selectedTable, selection );\n\t}\n\n\treturn selection;\n}\n\n// Expand table (in place) to expected size.\nfunction expandTableSize( table, expectedHeight, expectedWidth, tableUtils ) {\n\tconst tableWidth = tableUtils.getColumns( table );\n\tconst tableHeight = tableUtils.getRows( table );\n\n\tif ( expectedWidth > tableWidth ) {\n\t\ttableUtils.insertColumns( table, {\n\t\t\tat: tableWidth,\n\t\t\tcolumns: expectedWidth - tableWidth\n\t\t} );\n\t}\n\n\tif ( expectedHeight > tableHeight ) {\n\t\ttableUtils.insertRows( table, {\n\t\t\tat: tableHeight,\n\t\t\trows: expectedHeight - tableHeight\n\t\t} );\n\t}\n}\n\n// Returns two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.\n//\n// At given row & column location it might be one of:\n//\n// * cell - cell from pasted table anchored at this location.\n// * null - if no cell is anchored at this location.\n//\n// For instance, from a table below:\n//\n//\t\t+----+----+----+----+\n//\t\t| 00 | 01 | 02 | 03 |\n//\t\t+    +----+----+----+\n//\t\t|    | 11      | 13 |\n//\t\t+----+         +----+\n//\t\t| 20 |         | 23 |\n//\t\t+----+----+----+----+\n//\n// The method will return an array (numbers represents cell element):\n//\n//\tconst map = [\n//\t\t[ '00', '01', '02', '03' ],\n//\t\t[ null, '11', null, '13' ],\n//\t\t[ '20', null, null, '23' ]\n//\t]\n//\n// This allows for a quick access to table at give row & column. For instance to access table cell \"13\" from pasted table call:\n//\n//\t\tconst cell = map[ 1 ][ 3 ]\n//\nfunction createLocationMap( table, width, height ) {\n\t// Create height x width (row x column) two-dimensional table to store cells.\n\tconst map = new Array( height ).fill( null )\n\t\t.map( () => new Array( width ).fill( null ) );\n\n\tfor ( const { column, row, cell } of new TableWalker( table ) ) {\n\t\tmap[ row ][ column ] = cell;\n\t}\n\n\treturn map;\n}\n\n// Make selected cells rectangular by splitting the cells that stand out from a rectangular selection.\n//\n// In the table below a selection is shown with \"::\" and slots with anchor cells are named.\n//\n// +----+----+----+----+----+                    +----+----+----+----+----+\n// | 00 | 01 | 02 | 03      |                    | 00 | 01 | 02 | 03      |\n// +    +----+    +----+----+                    |    ::::::::::::::::----+\n// |    | 11 |    | 13 | 14 |                    |    ::11 |    | 13:: 14 |    <- first row\n// +----+----+    +    +----+                    +----::---|    |   ::----+\n// | 20 | 21 |    |    | 24 |   select cells:    | 20 ::21 |    |   :: 24 |\n// +----+----+    +----+----+     11 -> 33       +----::---|    |---::----+\n// | 30      |    | 33 | 34 |                    | 30 ::   |    | 33:: 34 |    <- last row\n// +         +    +----+    +                    |    ::::::::::::::::    +\n// |         |    | 43 |    |                    |         |    | 43 |    |\n// +----+----+----+----+----+                    +----+----+----+----+----+\n//                                                      ^          ^\n//                                                     first & last columns\n//\n// Will update table to:\n//\n//                       +----+----+----+----+----+\n//                       | 00 | 01 | 02 | 03      |\n//                       +    +----+----+----+----+\n//                       |    | 11 |    | 13 | 14 |\n//                       +----+----+    +    +----+\n//                       | 20 | 21 |    |    | 24 |\n//                       +----+----+    +----+----+\n//                       | 30 |    |    | 33 | 34 |\n//                       +    +----+----+----+    +\n//                       |    |    |    | 43 |    |\n//                       +----+----+----+----+----+\n//\n// In th example above:\n// - Cell \"02\" which have `rowspan = 4` must be trimmed at first and at after last row.\n// - Cell \"03\" which have `rowspan = 2` and `colspan = 2` must be trimmed at first column and after last row.\n// - Cells \"00\", \"03\" & \"30\" which cannot be cut by this algorithm as they are outside the trimmed area.\n// - Cell \"13\" cannot be cut as it is inside the trimmed area.\nfunction splitCellsToRectangularSelection( table, dimensions, writer ) {\n\tconst { firstRow, lastRow, firstColumn, lastColumn } = dimensions;\n\n\tconst rowIndexes = { first: firstRow, last: lastRow };\n\tconst columnIndexes = { first: firstColumn, last: lastColumn };\n\n\t// 1. Split cells vertically in two steps as first step might create cells that needs to split again.\n\tdoVerticalSplit( table, firstColumn, rowIndexes, writer );\n\tdoVerticalSplit( table, lastColumn + 1, rowIndexes, writer );\n\n\t// 2. Split cells horizontally in two steps as first step might create cells that needs to split again.\n\tdoHorizontalSplit( table, firstRow, columnIndexes, writer );\n\tdoHorizontalSplit( table, lastRow + 1, columnIndexes, writer, firstRow );\n}\n\nfunction doHorizontalSplit( table, splitRow, limitColumns, writer, startRow = 0 ) {\n\t// If selection starts at first row then no split is needed.\n\tif ( splitRow < 1 ) {\n\t\treturn;\n\t}\n\n\tconst overlappingCells = getVerticallyOverlappingCells( table, splitRow, startRow );\n\n\t// Filter out cells that are not touching insides of the rectangular selection.\n\tconst cellsToSplit = overlappingCells.filter( ( { column, cellWidth } ) => isAffectedBySelection( column, cellWidth, limitColumns ) );\n\n\treturn cellsToSplit.map( ( { cell } ) => splitHorizontally( cell, splitRow, writer ) );\n}\n\nfunction doVerticalSplit( table, splitColumn, limitRows, writer ) {\n\t// If selection starts at first column then no split is needed.\n\tif ( splitColumn < 1 ) {\n\t\treturn;\n\t}\n\n\tconst overlappingCells = getHorizontallyOverlappingCells( table, splitColumn );\n\n\t// Filter out cells that are not touching insides of the rectangular selection.\n\tconst cellsToSplit = overlappingCells.filter( ( { row, cellHeight } ) => isAffectedBySelection( row, cellHeight, limitRows ) );\n\n\treturn cellsToSplit.map( ( { cell, column } ) => splitVertically( cell, column, splitColumn, writer ) );\n}\n\n// Checks if cell at given row (column) is affected by a rectangular selection defined by first/last column (row).\n//\n// The same check is used for row as for column.\nfunction isAffectedBySelection( index, span, limit ) {\n\tconst endIndex = index + span - 1;\n\tconst { first, last } = limit;\n\n\tconst isInsideSelection = index >= first && index <= last;\n\tconst overlapsSelectionFromOutside = index < first && endIndex >= first;\n\n\treturn isInsideSelection || overlapsSelectionFromOutside;\n}\n"]},"metadata":{},"sourceType":"module"}
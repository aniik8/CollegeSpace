{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/liststyleediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport ListEditing from './listediting';\nimport ListStyleCommand from './liststylecommand';\nimport { getSiblingListItem, getSiblingNodes } from './utils';\nconst DEFAULT_LIST_TYPE = 'default';\n/**\n * The list style engine feature.\n *\n * It sets the value for the `listItem` attribute of the {@link module:list/list~List `<listItem>`} element that\n * allows modifying the list style type.\n *\n * It registers the `'listStyle'` command.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ListStyleEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [ListEditing];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get pluginName() {\n    return 'ListStyleEditing';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const model = editor.model; // Extend schema.\n\n    model.schema.extend('listItem', {\n      allowAttributes: ['listStyle']\n    });\n    editor.commands.add('listStyle', new ListStyleCommand(editor, DEFAULT_LIST_TYPE)); // Fix list attributes when modifying their nesting levels (the `listIndent` attribute).\n\n    this.listenTo(editor.commands.get('indentList'), '_executeCleanup', fixListAfterIndentListCommand(editor));\n    this.listenTo(editor.commands.get('outdentList'), '_executeCleanup', fixListAfterOutdentListCommand(editor));\n    this.listenTo(editor.commands.get('bulletedList'), '_executeCleanup', restoreDefaultListStyle(editor));\n    this.listenTo(editor.commands.get('numberedList'), '_executeCleanup', restoreDefaultListStyle(editor)); // Register a post-fixer that ensures that the `listStyle` attribute is specified in each `listItem` element.\n\n    model.document.registerPostFixer(fixListStyleAttributeOnListItemElements(editor)); // Set up conversion.\n\n    editor.conversion.for('upcast').add(upcastListItemStyle());\n    editor.conversion.for('downcast').add(downcastListStyleAttribute()); // Handle merging two separated lists into the single one.\n\n    this._mergeListStyleAttributeWhileMergingLists();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  afterInit() {\n    const editor = this.editor; // Enable post-fixer that removes the `listStyle` attribute from to-do list items only if the \"TodoList\" plugin is on.\n    // We need to registry the hook here since the `TodoList` plugin can be added after the `ListStyleEditing`.\n\n    if (editor.commands.get('todoList')) {\n      editor.model.document.registerPostFixer(removeListStyleAttributeFromTodoList(editor));\n    }\n  }\n  /**\n   * Starts listening to {@link module:engine/model/model~Model#deleteContent} checks whether two lists will be merged into a single one\n   * after deleting the content.\n   *\n   * The purpose of this action is to adjust the `listStyle` value for the list that was merged.\n   *\n   * Consider the following model's content:\n   *\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n   *     <paragraph>[A paragraph.]</paragraph>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 1</listItem>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n   *\n   * After removing the paragraph element, the second list will be merged into the first one.\n   * We want to inherit the `listStyle` attribute for the second list from the first one.\n   *\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n   *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n   *\n   * See https://github.com/ckeditor/ckeditor5/issues/7879.\n   *\n   * @private\n   */\n\n\n  _mergeListStyleAttributeWhileMergingLists() {\n    const editor = this.editor;\n    const model = editor.model; // First the outer-most`listItem` in the first list reference.\n    // If found, the lists should be merged and this `listItem` provides the `listStyle` attribute\n    // and it is also a starting point when searching for items in the second list.\n\n    let firstMostOuterItem; // Check whether the removed content is between two lists.\n\n    this.listenTo(model, 'deleteContent', (evt, _ref) => {\n      let [selection] = _ref;\n      const firstPosition = selection.getFirstPosition();\n      const lastPosition = selection.getLastPosition(); // Typing or removing content in a single item. Aborting.\n\n      if (firstPosition.parent === lastPosition.parent) {\n        return;\n      } // An element before the content that will be removed is not a list.\n\n\n      if (!firstPosition.parent.is('element', 'listItem')) {\n        return;\n      }\n\n      const nextSibling = lastPosition.parent.nextSibling; // An element after the content that will be removed is not a list.\n\n      if (!nextSibling || !nextSibling.is('element', 'listItem')) {\n        return;\n      } // Find the outermost list item based on the `listIndent` attribute. We can't assume that `listIndent=0`\n      // because the selection can be hooked in nested lists.\n      //\n      // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n      // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List [item 1.1</listItem>\n      // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1.</listItem>\n      // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"circle\">UL List ]item 1.1</listItem>\n      //\n      // After deleting the content, we would like to inherit the \"square\" attribute for the last element:\n      //\n      // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n      // <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List []item 1.1</listItem>\n\n\n      const mostOuterItemList = getSiblingListItem(firstPosition.parent, {\n        sameIndent: true,\n        listIndent: nextSibling.getAttribute('listIndent')\n      }); // The outermost list item may not exist while removing elements between lists with different value\n      // of the `listIndent` attribute. In such a case we don't want to update anything. See: #8073.\n\n      if (!mostOuterItemList) {\n        return;\n      }\n\n      if (mostOuterItemList.getAttribute('listType') === nextSibling.getAttribute('listType')) {\n        firstMostOuterItem = mostOuterItemList;\n      }\n    }, {\n      priority: 'high'\n    }); // If so, update the `listStyle` attribute for the second list.\n\n    this.listenTo(model, 'deleteContent', () => {\n      if (!firstMostOuterItem) {\n        return;\n      }\n\n      model.change(writer => {\n        // Find the first most-outer item list in the merged list.\n        // A case when the first list item in the second list was merged into the last item in the first list.\n        //\n        // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n        // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n        // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1</listItem>\n        // <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n        const secondListMostOuterItem = getSiblingListItem(firstMostOuterItem.nextSibling, {\n          sameIndent: true,\n          listIndent: firstMostOuterItem.getAttribute('listIndent'),\n          direction: 'forward'\n        });\n        const items = [secondListMostOuterItem, ...getSiblingNodes(writer.createPositionAt(secondListMostOuterItem, 0), 'forward')];\n\n        for (const listItem of items) {\n          writer.setAttribute('listStyle', firstMostOuterItem.getAttribute('listStyle'), listItem);\n        }\n      });\n      firstMostOuterItem = null;\n    }, {\n      priority: 'low'\n    });\n  }\n\n} // Returns a converter that consumes the `style` attribute and searches for the `list-style-type` definition.\n// If not found, the `\"default\"` value will be used.\n//\n// @returns {Function}\n\nfunction upcastListItemStyle() {\n  return dispatcher => {\n    dispatcher.on('element:li', (evt, data, conversionApi) => {\n      const listParent = data.viewItem.parent; // It may happen that the native spell checker fixes a word inside a list item.\n      // When the children mutation is fired, the `<li>` does not have the parent element. See: #9325.\n\n      if (!listParent) {\n        return;\n      }\n\n      const listStyle = listParent.getStyle('list-style-type') || DEFAULT_LIST_TYPE;\n      const listItem = data.modelRange.start.nodeAfter || data.modelRange.end.nodeBefore;\n      conversionApi.writer.setAttribute('listStyle', listStyle, listItem);\n    }, {\n      priority: 'low'\n    });\n  };\n} // Returns a converter that adds the `list-style-type` definition as a value for the `style` attribute.\n// The `\"default\"` value is removed and not present in the view/data.\n//\n// @returns {Function}\n\n\nfunction downcastListStyleAttribute() {\n  return dispatcher => {\n    dispatcher.on('attribute:listStyle:listItem', (evt, data, conversionApi) => {\n      const viewWriter = conversionApi.writer;\n      const currentElement = data.item;\n      const previousElement = getSiblingListItem(currentElement.previousSibling, {\n        sameIndent: true,\n        listIndent: currentElement.getAttribute('listIndent'),\n        direction: 'backward'\n      });\n      const viewItem = conversionApi.mapper.toViewElement(currentElement); // A case when elements represent different lists. We need to separate their container.\n\n      if (!areRepresentingSameList(currentElement, previousElement)) {\n        viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n      }\n\n      setListStyle(viewWriter, data.attributeNewValue, viewItem.parent);\n    }, {\n      priority: 'low'\n    });\n  }; // Checks whether specified list items belong to the same list.\n  //\n  // @param {module:engine/model/element~Element} `listItem1` The first list item to check.\n  // @param {module:engine/model/element~Element|null} `listItem2` The second list item to check.\n  // @returns {Boolean}\n\n  function areRepresentingSameList(listItem1, listItem2) {\n    return listItem2 && listItem1.getAttribute('listType') === listItem2.getAttribute('listType') && listItem1.getAttribute('listIndent') === listItem2.getAttribute('listIndent') && listItem1.getAttribute('listStyle') === listItem2.getAttribute('listStyle');\n  } // Updates or removes the `list-style-type` from the `element`.\n  //\n  // @param {module:engine/view/downcastwriter~DowncastWriter} writer\n  // @param {String} listStyle\n  // @param {module:engine/view/element~Element} element\n\n\n  function setListStyle(writer, listStyle, element) {\n    if (listStyle && listStyle !== DEFAULT_LIST_TYPE) {\n      writer.setStyle('list-style-type', listStyle, element);\n    } else {\n      writer.removeStyle('list-style-type', element);\n    }\n  }\n} // When indenting list, nested list should clear its value for the `listStyle` attribute or inherit from nested lists.\n//\n// ■ List item 1.\n// ■ List item 2.[]\n// ■ List item 3.\n// editor.execute( 'indentList' );\n//\n// ■ List item 1.\n//     ○ List item 2.[]\n// ■ List item 3.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\n\n\nfunction fixListAfterIndentListCommand(editor) {\n  return (evt, changedItems) => {\n    let valueToSet;\n    const root = changedItems[0];\n    const rootIndent = root.getAttribute('listIndent');\n    const itemsToUpdate = changedItems.filter(item => item.getAttribute('listIndent') === rootIndent); // A case where a few list items are indented must be checked separately\n    // since `getSiblingListItem()` returns the first changed element.\n    // ■ List item 1.\n    //     ○ [List item 2.\n    //     ○ List item 3.]\n    // ■ List item 4.\n    //\n    // List items: `2` and `3` should be adjusted.\n\n    if (root.previousSibling.getAttribute('listIndent') + 1 === rootIndent) {\n      // valueToSet = root.previousSibling.getAttribute( 'listStyle' ) || DEFAULT_LIST_TYPE;\n      valueToSet = DEFAULT_LIST_TYPE;\n    } else {\n      const previousSibling = getSiblingListItem(root.previousSibling, {\n        sameIndent: true,\n        direction: 'backward',\n        listIndent: rootIndent\n      });\n      valueToSet = previousSibling.getAttribute('listStyle');\n    }\n\n    editor.model.change(writer => {\n      for (const item of itemsToUpdate) {\n        writer.setAttribute('listStyle', valueToSet, item);\n      }\n    });\n  };\n} // When outdenting a list, a nested list should copy its value for the `listStyle` attribute\n// from the previous sibling list item including the same value for the `listIndent` value.\n//\n// ■ List item 1.\n//     ○ List item 2.[]\n// ■ List item 3.\n//\n// editor.execute( 'outdentList' );\n//\n// ■ List item 1.\n// ■ List item 2.[]\n// ■ List item 3.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\n\n\nfunction fixListAfterOutdentListCommand(editor) {\n  return (evt, changedItems) => {\n    changedItems = changedItems.reverse().filter(item => item.is('element', 'listItem'));\n\n    if (!changedItems.length) {\n      return;\n    }\n\n    const indent = changedItems[0].getAttribute('listIndent');\n    const listType = changedItems[0].getAttribute('listType');\n    let listItem = changedItems[0].previousSibling; // ■ List item 1.\n    //     ○ List item 2.\n    //     ○ List item 3.[]\n    // ■ List item 4.\n    //\n    // After outdenting a list, `List item 3` should inherit the `listStyle` attribute from `List item 1`.\n    //\n    // ■ List item 1.\n    //     ○ List item 2.\n    // ■ List item 3.[]\n    // ■ List item 4.\n\n    if (listItem.is('element', 'listItem')) {\n      while (listItem.getAttribute('listIndent') !== indent) {\n        listItem = listItem.previousSibling;\n      }\n    } else {\n      listItem = null;\n    } // Outdenting such a list should restore values based on `List item 4`.\n    // ■ List item 1.[]\n    //     ○ List item 2.\n    //     ○ List item 3.\n    // ■ List item 4.\n\n\n    if (!listItem) {\n      listItem = changedItems[changedItems.length - 1].nextSibling;\n    } // And such a list should not modify anything.\n    // However, `listItem` can indicate a node below the list. Be sure that we have the `listItem` element.\n    // ■ List item 1.[]\n    //     ○ List item 2.\n    //     ○ List item 3.\n    // <paragraph>The later if check.</paragraph>\n\n\n    if (!listItem || !listItem.is('element', 'listItem')) {\n      return;\n    } // Do not modify the list if found `listItem` represents other type of list than outdented list items.\n\n\n    if (listItem.getAttribute('listType') !== listType) {\n      return;\n    }\n\n    editor.model.change(writer => {\n      const itemsToUpdate = changedItems.filter(item => item.getAttribute('listIndent') === indent);\n\n      for (const item of itemsToUpdate) {\n        writer.setAttribute('listStyle', listItem.getAttribute('listStyle'), item);\n      }\n    });\n  };\n} // Each `listItem` element must have specified the `listStyle` attribute.\n// This post-fixer checks whether inserted elements `listItem` elements should inherit the `listStyle` value from\n// their sibling nodes or should use the default value.\n//\n// Paragraph[]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2. // ...\n// ■ List item 3. // ...\n//\n// editor.execute( 'bulletedList' )\n//\n// ■ Paragraph[]  // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2.\n// ■ List item 3.\n//\n// It also covers a such change:\n//\n// [Paragraph 1\n// Paragraph 2]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2. // ...\n// ■ List item 3. // ...\n//\n// editor.execute( 'numberedList' )\n//\n// 1. [Paragraph 1 // [listStyle=\"default\", listType=\"numbered\"]\n// 2. Paragraph 2] // [listStyle=\"default\", listType=\"numbered\"]\n// ■ List item 1.  // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2.  // ...\n// ■ List item 3.  // ...\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\n\n\nfunction fixListStyleAttributeOnListItemElements(editor) {\n  return writer => {\n    let wasFixed = false;\n    const insertedListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter(item => {\n      // Don't touch todo lists. They are handled in another post-fixer.\n      return item.getAttribute('listType') !== 'todo';\n    });\n\n    if (!insertedListItems.length) {\n      return wasFixed;\n    } // Check whether the last inserted element is next to the `listItem` element.\n    //\n    // ■ Paragraph[]  // <-- The inserted item.\n    // ■ List item 1.\n\n\n    let existingListItem = insertedListItems[insertedListItems.length - 1].nextSibling; // If it doesn't, maybe the `listItem` was inserted at the end of the list.\n    //\n    // ■ List item 1.\n    // ■ Paragraph[]  // <-- The inserted item.\n\n    if (!existingListItem || !existingListItem.is('element', 'listItem')) {\n      existingListItem = insertedListItems[insertedListItems.length - 1].previousSibling;\n\n      if (existingListItem) {\n        const indent = insertedListItems[0].getAttribute('listIndent'); // But we need to find a `listItem` with the `listIndent=0` attribute.\n        // If doesn't, maybe the `listItem` was inserted at the end of the list.\n        //\n        // ■ List item 1.\n        //     ○ List item 2.\n        // ■ Paragraph[]  // <-- The inserted item.\n\n        while (existingListItem.is('element', 'listItem') && existingListItem.getAttribute('listIndent') !== indent) {\n          existingListItem = existingListItem.previousSibling; // If the item does not exist, most probably there is no other content in the editor. See: #8072.\n\n          if (!existingListItem) {\n            break;\n          }\n        }\n      }\n    }\n\n    for (const item of insertedListItems) {\n      if (!item.hasAttribute('listStyle')) {\n        if (shouldInheritListType(existingListItem, item)) {\n          writer.setAttribute('listStyle', existingListItem.getAttribute('listStyle'), item);\n        } else {\n          writer.setAttribute('listStyle', DEFAULT_LIST_TYPE, item);\n        }\n\n        wasFixed = true;\n      } else {\n        // Adjust the `listStyle` attribute for inserted (pasted) items. See #8160.\n        //\n        // ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n        //     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n        //     ○ [] (selection is here)\n        //\n        // Then, pasting a list with different attributes (listStyle, listType):\n        //\n        // 1. First. // [listStyle=\"decimal\", listType=\"numbered\"]\n        // 2. Second // [listStyle=\"decimal\", listType=\"numbered\"]\n        //\n        // The `listType` attribute will be corrected by the `ListEditing` converters.\n        // We need to adjust the `listStyle` attribute. Expected structure:\n        //\n        // ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n        //     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n        //     ○ First. // [listStyle=\"circle\", listType=\"bulleted\"]\n        //     ○ Second // [listStyle=\"circle\", listType=\"bulleted\"]\n        const previousSibling = item.previousSibling;\n\n        if (shouldInheritListTypeFromPreviousItem(previousSibling, item)) {\n          writer.setAttribute('listStyle', previousSibling.getAttribute('listStyle'), item);\n          wasFixed = true;\n        }\n      }\n    }\n\n    return wasFixed;\n  };\n} // Checks whether the `listStyle` attribute should be copied from the `baseItem` element.\n//\n// The attribute should be copied if the inserted element does not have defined it and\n// the value for the element is other than default in the base element.\n//\n// @param {module:engine/model/element~Element|null} baseItem\n// @param {module:engine/model/element~Element} itemToChange\n// @returns {Boolean}\n\n\nfunction shouldInheritListType(baseItem, itemToChange) {\n  if (!baseItem) {\n    return false;\n  }\n\n  const baseListStyle = baseItem.getAttribute('listStyle');\n\n  if (!baseListStyle) {\n    return false;\n  }\n\n  if (baseListStyle === DEFAULT_LIST_TYPE) {\n    return false;\n  }\n\n  if (baseItem.getAttribute('listType') !== itemToChange.getAttribute('listType')) {\n    return false;\n  }\n\n  return true;\n} // Checks whether the `listStyle` attribute should be copied from previous list item.\n//\n// The attribute should be copied if there's a mismatch of styles of the pasted list into a nested list.\n// Top-level lists are not normalized as we allow side-by-side list of different types.\n//\n// @param {module:engine/model/element~Element|null} previousItem\n// @param {module:engine/model/element~Element} itemToChange\n// @returns {Boolean}\n\n\nfunction shouldInheritListTypeFromPreviousItem(previousItem, itemToChange) {\n  if (!previousItem || !previousItem.is('element', 'listItem')) {\n    return false;\n  }\n\n  if (itemToChange.getAttribute('listType') !== previousItem.getAttribute('listType')) {\n    return false;\n  }\n\n  const previousItemIndent = previousItem.getAttribute('listIndent');\n\n  if (previousItemIndent < 1 || previousItemIndent !== itemToChange.getAttribute('listIndent')) {\n    return false;\n  }\n\n  const previousItemListStyle = previousItem.getAttribute('listStyle');\n\n  if (!previousItemListStyle || previousItemListStyle === itemToChange.getAttribute('listStyle')) {\n    return false;\n  }\n\n  return true;\n} // Removes the `listStyle` attribute from \"todo\" list items.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\n\n\nfunction removeListStyleAttributeFromTodoList(editor) {\n  return writer => {\n    const todoListItems = getChangedListItems(editor.model.document.differ.getChanges()).filter(item => {\n      // Handle the todo lists only. The rest is handled in another post-fixer.\n      return item.getAttribute('listType') === 'todo' && item.hasAttribute('listStyle');\n    });\n\n    if (!todoListItems.length) {\n      return false;\n    }\n\n    for (const item of todoListItems) {\n      writer.removeAttribute('listStyle', item);\n    }\n\n    return true;\n  };\n} // Restores the `listStyle` attribute after changing the list type.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\n\n\nfunction restoreDefaultListStyle(editor) {\n  return (evt, changedItems) => {\n    changedItems = changedItems.filter(item => item.is('element', 'listItem'));\n    editor.model.change(writer => {\n      for (const item of changedItems) {\n        // Remove the attribute. Post-fixer will restore the proper value.\n        writer.removeAttribute('listStyle', item);\n      }\n    });\n  };\n} // Returns the `listItem` that was inserted or changed.\n//\n// @param {Array.<Object>} changes The changes list returned by the differ.\n// @returns {Array.<module:engine/model/element~Element>}\n\n\nfunction getChangedListItems(changes) {\n  const items = [];\n\n  for (const change of changes) {\n    const item = getItemFromChange(change);\n\n    if (item && item.is('element', 'listItem')) {\n      items.push(item);\n    }\n  }\n\n  return items;\n}\n\nfunction getItemFromChange(change) {\n  if (change.type === 'attribute') {\n    return change.range.start.nodeAfter;\n  }\n\n  if (change.type === 'insert') {\n    return change.position.nodeAfter;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-list/src/liststyleediting.js"],"names":["Plugin","ListEditing","ListStyleCommand","getSiblingListItem","getSiblingNodes","DEFAULT_LIST_TYPE","ListStyleEditing","requires","pluginName","init","editor","model","schema","extend","allowAttributes","commands","add","listenTo","get","fixListAfterIndentListCommand","fixListAfterOutdentListCommand","restoreDefaultListStyle","document","registerPostFixer","fixListStyleAttributeOnListItemElements","conversion","for","upcastListItemStyle","downcastListStyleAttribute","_mergeListStyleAttributeWhileMergingLists","afterInit","removeListStyleAttributeFromTodoList","firstMostOuterItem","evt","selection","firstPosition","getFirstPosition","lastPosition","getLastPosition","parent","is","nextSibling","mostOuterItemList","sameIndent","listIndent","getAttribute","priority","change","writer","secondListMostOuterItem","direction","items","createPositionAt","listItem","setAttribute","dispatcher","on","data","conversionApi","listParent","viewItem","listStyle","getStyle","modelRange","start","nodeAfter","end","nodeBefore","viewWriter","currentElement","item","previousElement","previousSibling","mapper","toViewElement","areRepresentingSameList","breakContainer","createPositionBefore","setListStyle","attributeNewValue","listItem1","listItem2","element","setStyle","removeStyle","changedItems","valueToSet","root","rootIndent","itemsToUpdate","filter","reverse","length","indent","listType","wasFixed","insertedListItems","getChangedListItems","differ","getChanges","existingListItem","hasAttribute","shouldInheritListType","shouldInheritListTypeFromPreviousItem","baseItem","itemToChange","baseListStyle","previousItem","previousItemIndent","previousItemListStyle","todoListItems","removeAttribute","changes","getItemFromChange","push","type","range","position"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/liststyleediting\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport ListEditing from './listediting';\nimport ListStyleCommand from './liststylecommand';\nimport { getSiblingListItem, getSiblingNodes } from './utils';\n\nconst DEFAULT_LIST_TYPE = 'default';\n\n/**\n * The list style engine feature.\n *\n * It sets the value for the `listItem` attribute of the {@link module:list/list~List `<listItem>`} element that\n * allows modifying the list style type.\n *\n * It registers the `'listStyle'` command.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ListStyleEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ ListEditing ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'ListStyleEditing';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\t// Extend schema.\n\t\tmodel.schema.extend( 'listItem', {\n\t\t\tallowAttributes: [ 'listStyle' ]\n\t\t} );\n\n\t\teditor.commands.add( 'listStyle', new ListStyleCommand( editor, DEFAULT_LIST_TYPE ) );\n\n\t\t// Fix list attributes when modifying their nesting levels (the `listIndent` attribute).\n\t\tthis.listenTo( editor.commands.get( 'indentList' ), '_executeCleanup', fixListAfterIndentListCommand( editor ) );\n\t\tthis.listenTo( editor.commands.get( 'outdentList' ), '_executeCleanup', fixListAfterOutdentListCommand( editor ) );\n\n\t\tthis.listenTo( editor.commands.get( 'bulletedList' ), '_executeCleanup', restoreDefaultListStyle( editor ) );\n\t\tthis.listenTo( editor.commands.get( 'numberedList' ), '_executeCleanup', restoreDefaultListStyle( editor ) );\n\n\t\t// Register a post-fixer that ensures that the `listStyle` attribute is specified in each `listItem` element.\n\t\tmodel.document.registerPostFixer( fixListStyleAttributeOnListItemElements( editor ) );\n\n\t\t// Set up conversion.\n\t\teditor.conversion.for( 'upcast' ).add( upcastListItemStyle() );\n\t\teditor.conversion.for( 'downcast' ).add( downcastListStyleAttribute() );\n\n\t\t// Handle merging two separated lists into the single one.\n\t\tthis._mergeListStyleAttributeWhileMergingLists();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tafterInit() {\n\t\tconst editor = this.editor;\n\n\t\t// Enable post-fixer that removes the `listStyle` attribute from to-do list items only if the \"TodoList\" plugin is on.\n\t\t// We need to registry the hook here since the `TodoList` plugin can be added after the `ListStyleEditing`.\n\t\tif ( editor.commands.get( 'todoList' ) ) {\n\t\t\teditor.model.document.registerPostFixer( removeListStyleAttributeFromTodoList( editor ) );\n\t\t}\n\t}\n\n\t/**\n\t * Starts listening to {@link module:engine/model/model~Model#deleteContent} checks whether two lists will be merged into a single one\n\t * after deleting the content.\n\t *\n\t * The purpose of this action is to adjust the `listStyle` value for the list that was merged.\n\t *\n\t * Consider the following model's content:\n\t *\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n\t *     <paragraph>[A paragraph.]</paragraph>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 1</listItem>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n\t *\n\t * After removing the paragraph element, the second list will be merged into the first one.\n\t * We want to inherit the `listStyle` attribute for the second list from the first one.\n\t *\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t *     <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n\t *\n\t * See https://github.com/ckeditor/ckeditor5/issues/7879.\n\t *\n\t * @private\n\t */\n\t_mergeListStyleAttributeWhileMergingLists() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\n\t\t// First the outer-most`listItem` in the first list reference.\n\t\t// If found, the lists should be merged and this `listItem` provides the `listStyle` attribute\n\t\t// and it is also a starting point when searching for items in the second list.\n\t\tlet firstMostOuterItem;\n\n\t\t// Check whether the removed content is between two lists.\n\t\tthis.listenTo( model, 'deleteContent', ( evt, [ selection ] ) => {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst lastPosition = selection.getLastPosition();\n\n\t\t\t// Typing or removing content in a single item. Aborting.\n\t\t\tif ( firstPosition.parent === lastPosition.parent ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// An element before the content that will be removed is not a list.\n\t\t\tif ( !firstPosition.parent.is( 'element', 'listItem' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextSibling = lastPosition.parent.nextSibling;\n\n\t\t\t// An element after the content that will be removed is not a list.\n\t\t\tif ( !nextSibling || !nextSibling.is( 'element', 'listItem' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find the outermost list item based on the `listIndent` attribute. We can't assume that `listIndent=0`\n\t\t\t// because the selection can be hooked in nested lists.\n\t\t\t//\n\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t\t\t// <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List [item 1.1</listItem>\n\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1.</listItem>\n\t\t\t// <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"circle\">UL List ]item 1.1</listItem>\n\t\t\t//\n\t\t\t// After deleting the content, we would like to inherit the \"square\" attribute for the last element:\n\t\t\t//\n\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t\t\t// <listItem listIndent=\"1\" listType=\"bulleted\" listStyle=\"square\">UL List []item 1.1</listItem>\n\t\t\tconst mostOuterItemList = getSiblingListItem( firstPosition.parent, {\n\t\t\t\tsameIndent: true,\n\t\t\t\tlistIndent: nextSibling.getAttribute( 'listIndent' )\n\t\t\t} );\n\n\t\t\t// The outermost list item may not exist while removing elements between lists with different value\n\t\t\t// of the `listIndent` attribute. In such a case we don't want to update anything. See: #8073.\n\t\t\tif ( !mostOuterItemList ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( mostOuterItemList.getAttribute( 'listType' ) === nextSibling.getAttribute( 'listType' ) ) {\n\t\t\t\tfirstMostOuterItem = mostOuterItemList;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// If so, update the `listStyle` attribute for the second list.\n\t\tthis.listenTo( model, 'deleteContent', () => {\n\t\t\tif ( !firstMostOuterItem ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmodel.change( writer => {\n\t\t\t\t// Find the first most-outer item list in the merged list.\n\t\t\t\t// A case when the first list item in the second list was merged into the last item in the first list.\n\t\t\t\t//\n\t\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 1</listItem>\n\t\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"square\">UL List item 2</listItem>\n\t\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">[]UL List item 1</listItem>\n\t\t\t\t// <listItem listIndent=\"0\" listType=\"bulleted\" listStyle=\"circle\">UL List item 2</listItem>\n\t\t\t\tconst secondListMostOuterItem = getSiblingListItem( firstMostOuterItem.nextSibling, {\n\t\t\t\t\tsameIndent: true,\n\t\t\t\t\tlistIndent: firstMostOuterItem.getAttribute( 'listIndent' ),\n\t\t\t\t\tdirection: 'forward'\n\t\t\t\t} );\n\n\t\t\t\tconst items = [\n\t\t\t\t\tsecondListMostOuterItem,\n\t\t\t\t\t...getSiblingNodes( writer.createPositionAt( secondListMostOuterItem, 0 ), 'forward' )\n\t\t\t\t];\n\n\t\t\t\tfor ( const listItem of items ) {\n\t\t\t\t\twriter.setAttribute( 'listStyle', firstMostOuterItem.getAttribute( 'listStyle' ), listItem );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tfirstMostOuterItem = null;\n\t\t}, { priority: 'low' } );\n\t}\n}\n\n// Returns a converter that consumes the `style` attribute and searches for the `list-style-type` definition.\n// If not found, the `\"default\"` value will be used.\n//\n// @returns {Function}\nfunction upcastListItemStyle() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:li', ( evt, data, conversionApi ) => {\n\t\t\tconst listParent = data.viewItem.parent;\n\n\t\t\t// It may happen that the native spell checker fixes a word inside a list item.\n\t\t\t// When the children mutation is fired, the `<li>` does not have the parent element. See: #9325.\n\t\t\tif ( !listParent ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst listStyle = listParent.getStyle( 'list-style-type' ) || DEFAULT_LIST_TYPE;\n\t\t\tconst listItem = data.modelRange.start.nodeAfter || data.modelRange.end.nodeBefore;\n\n\t\t\tconversionApi.writer.setAttribute( 'listStyle', listStyle, listItem );\n\t\t}, { priority: 'low' } );\n\t};\n}\n\n// Returns a converter that adds the `list-style-type` definition as a value for the `style` attribute.\n// The `\"default\"` value is removed and not present in the view/data.\n//\n// @returns {Function}\nfunction downcastListStyleAttribute() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'attribute:listStyle:listItem', ( evt, data, conversionApi ) => {\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst currentElement = data.item;\n\n\t\t\tconst previousElement = getSiblingListItem( currentElement.previousSibling, {\n\t\t\t\tsameIndent: true,\n\t\t\t\tlistIndent: currentElement.getAttribute( 'listIndent' ),\n\t\t\t\tdirection: 'backward'\n\t\t\t} );\n\n\t\t\tconst viewItem = conversionApi.mapper.toViewElement( currentElement );\n\n\t\t\t// A case when elements represent different lists. We need to separate their container.\n\t\t\tif ( !areRepresentingSameList( currentElement, previousElement ) ) {\n\t\t\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\t\t}\n\n\t\t\tsetListStyle( viewWriter, data.attributeNewValue, viewItem.parent );\n\t\t}, { priority: 'low' } );\n\t};\n\n\t// Checks whether specified list items belong to the same list.\n\t//\n\t// @param {module:engine/model/element~Element} `listItem1` The first list item to check.\n\t// @param {module:engine/model/element~Element|null} `listItem2` The second list item to check.\n\t// @returns {Boolean}\n\tfunction areRepresentingSameList( listItem1, listItem2 ) {\n\t\treturn listItem2 &&\n\t\t\tlistItem1.getAttribute( 'listType' ) === listItem2.getAttribute( 'listType' ) &&\n\t\t\tlistItem1.getAttribute( 'listIndent' ) === listItem2.getAttribute( 'listIndent' ) &&\n\t\t\tlistItem1.getAttribute( 'listStyle' ) === listItem2.getAttribute( 'listStyle' );\n\t}\n\n\t// Updates or removes the `list-style-type` from the `element`.\n\t//\n\t// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\t// @param {String} listStyle\n\t// @param {module:engine/view/element~Element} element\n\tfunction setListStyle( writer, listStyle, element ) {\n\t\tif ( listStyle && listStyle !== DEFAULT_LIST_TYPE ) {\n\t\t\twriter.setStyle( 'list-style-type', listStyle, element );\n\t\t} else {\n\t\t\twriter.removeStyle( 'list-style-type', element );\n\t\t}\n\t}\n}\n\n// When indenting list, nested list should clear its value for the `listStyle` attribute or inherit from nested lists.\n//\n// ■ List item 1.\n// ■ List item 2.[]\n// ■ List item 3.\n// editor.execute( 'indentList' );\n//\n// ■ List item 1.\n//     ○ List item 2.[]\n// ■ List item 3.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\nfunction fixListAfterIndentListCommand( editor ) {\n\treturn ( evt, changedItems ) => {\n\t\tlet valueToSet;\n\n\t\tconst root = changedItems[ 0 ];\n\t\tconst rootIndent = root.getAttribute( 'listIndent' );\n\n\t\tconst itemsToUpdate = changedItems.filter( item => item.getAttribute( 'listIndent' ) === rootIndent );\n\n\t\t// A case where a few list items are indented must be checked separately\n\t\t// since `getSiblingListItem()` returns the first changed element.\n\t\t// ■ List item 1.\n\t\t//     ○ [List item 2.\n\t\t//     ○ List item 3.]\n\t\t// ■ List item 4.\n\t\t//\n\t\t// List items: `2` and `3` should be adjusted.\n\t\tif ( root.previousSibling.getAttribute( 'listIndent' ) + 1 === rootIndent ) {\n\t\t\t// valueToSet = root.previousSibling.getAttribute( 'listStyle' ) || DEFAULT_LIST_TYPE;\n\t\t\tvalueToSet = DEFAULT_LIST_TYPE;\n\t\t} else {\n\t\t\tconst previousSibling = getSiblingListItem( root.previousSibling, {\n\t\t\t\tsameIndent: true, direction: 'backward', listIndent: rootIndent\n\t\t\t} );\n\n\t\t\tvalueToSet = previousSibling.getAttribute( 'listStyle' );\n\t\t}\n\n\t\teditor.model.change( writer => {\n\t\t\tfor ( const item of itemsToUpdate ) {\n\t\t\t\twriter.setAttribute( 'listStyle', valueToSet, item );\n\t\t\t}\n\t\t} );\n\t};\n}\n\n// When outdenting a list, a nested list should copy its value for the `listStyle` attribute\n// from the previous sibling list item including the same value for the `listIndent` value.\n//\n// ■ List item 1.\n//     ○ List item 2.[]\n// ■ List item 3.\n//\n// editor.execute( 'outdentList' );\n//\n// ■ List item 1.\n// ■ List item 2.[]\n// ■ List item 3.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\nfunction fixListAfterOutdentListCommand( editor ) {\n\treturn ( evt, changedItems ) => {\n\t\tchangedItems = changedItems.reverse().filter( item => item.is( 'element', 'listItem' ) );\n\n\t\tif ( !changedItems.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst indent = changedItems[ 0 ].getAttribute( 'listIndent' );\n\t\tconst listType = changedItems[ 0 ].getAttribute( 'listType' );\n\t\tlet listItem = changedItems[ 0 ].previousSibling;\n\n\t\t// ■ List item 1.\n\t\t//     ○ List item 2.\n\t\t//     ○ List item 3.[]\n\t\t// ■ List item 4.\n\t\t//\n\t\t// After outdenting a list, `List item 3` should inherit the `listStyle` attribute from `List item 1`.\n\t\t//\n\t\t// ■ List item 1.\n\t\t//     ○ List item 2.\n\t\t// ■ List item 3.[]\n\t\t// ■ List item 4.\n\t\tif ( listItem.is( 'element', 'listItem' ) ) {\n\t\t\twhile ( listItem.getAttribute( 'listIndent' ) !== indent ) {\n\t\t\t\tlistItem = listItem.previousSibling;\n\t\t\t}\n\t\t} else {\n\t\t\tlistItem = null;\n\t\t}\n\n\t\t// Outdenting such a list should restore values based on `List item 4`.\n\t\t// ■ List item 1.[]\n\t\t//     ○ List item 2.\n\t\t//     ○ List item 3.\n\t\t// ■ List item 4.\n\t\tif ( !listItem ) {\n\t\t\tlistItem = changedItems[ changedItems.length - 1 ].nextSibling;\n\t\t}\n\n\t\t// And such a list should not modify anything.\n\t\t// However, `listItem` can indicate a node below the list. Be sure that we have the `listItem` element.\n\t\t// ■ List item 1.[]\n\t\t//     ○ List item 2.\n\t\t//     ○ List item 3.\n\t\t// <paragraph>The later if check.</paragraph>\n\t\tif ( !listItem || !listItem.is( 'element', 'listItem' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not modify the list if found `listItem` represents other type of list than outdented list items.\n\t\tif ( listItem.getAttribute( 'listType' ) !== listType ) {\n\t\t\treturn;\n\t\t}\n\n\t\teditor.model.change( writer => {\n\t\t\tconst itemsToUpdate = changedItems.filter( item => item.getAttribute( 'listIndent' ) === indent );\n\n\t\t\tfor ( const item of itemsToUpdate ) {\n\t\t\t\twriter.setAttribute( 'listStyle', listItem.getAttribute( 'listStyle' ), item );\n\t\t\t}\n\t\t} );\n\t};\n}\n\n// Each `listItem` element must have specified the `listStyle` attribute.\n// This post-fixer checks whether inserted elements `listItem` elements should inherit the `listStyle` value from\n// their sibling nodes or should use the default value.\n//\n// Paragraph[]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2. // ...\n// ■ List item 3. // ...\n//\n// editor.execute( 'bulletedList' )\n//\n// ■ Paragraph[]  // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2.\n// ■ List item 3.\n//\n// It also covers a such change:\n//\n// [Paragraph 1\n// Paragraph 2]\n// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2. // ...\n// ■ List item 3. // ...\n//\n// editor.execute( 'numberedList' )\n//\n// 1. [Paragraph 1 // [listStyle=\"default\", listType=\"numbered\"]\n// 2. Paragraph 2] // [listStyle=\"default\", listType=\"numbered\"]\n// ■ List item 1.  // [listStyle=\"square\", listType=\"bulleted\"]\n// ■ List item 2.  // ...\n// ■ List item 3.  // ...\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\nfunction fixListStyleAttributeOnListItemElements( editor ) {\n\treturn writer => {\n\t\tlet wasFixed = false;\n\n\t\tconst insertedListItems = getChangedListItems( editor.model.document.differ.getChanges() )\n\t\t\t.filter( item => {\n\t\t\t\t// Don't touch todo lists. They are handled in another post-fixer.\n\t\t\t\treturn item.getAttribute( 'listType' ) !== 'todo';\n\t\t\t} );\n\n\t\tif ( !insertedListItems.length ) {\n\t\t\treturn wasFixed;\n\t\t}\n\n\t\t// Check whether the last inserted element is next to the `listItem` element.\n\t\t//\n\t\t// ■ Paragraph[]  // <-- The inserted item.\n\t\t// ■ List item 1.\n\t\tlet existingListItem = insertedListItems[ insertedListItems.length - 1 ].nextSibling;\n\n\t\t// If it doesn't, maybe the `listItem` was inserted at the end of the list.\n\t\t//\n\t\t// ■ List item 1.\n\t\t// ■ Paragraph[]  // <-- The inserted item.\n\t\tif ( !existingListItem || !existingListItem.is( 'element', 'listItem' ) ) {\n\t\t\texistingListItem = insertedListItems[ insertedListItems.length - 1 ].previousSibling;\n\n\t\t\tif ( existingListItem ) {\n\t\t\t\tconst indent = insertedListItems[ 0 ].getAttribute( 'listIndent' );\n\n\t\t\t\t// But we need to find a `listItem` with the `listIndent=0` attribute.\n\t\t\t\t// If doesn't, maybe the `listItem` was inserted at the end of the list.\n\t\t\t\t//\n\t\t\t\t// ■ List item 1.\n\t\t\t\t//     ○ List item 2.\n\t\t\t\t// ■ Paragraph[]  // <-- The inserted item.\n\t\t\t\twhile ( existingListItem.is( 'element', 'listItem' ) && existingListItem.getAttribute( 'listIndent' ) !== indent ) {\n\t\t\t\t\texistingListItem = existingListItem.previousSibling;\n\n\t\t\t\t\t// If the item does not exist, most probably there is no other content in the editor. See: #8072.\n\t\t\t\t\tif ( !existingListItem ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor ( const item of insertedListItems ) {\n\t\t\tif ( !item.hasAttribute( 'listStyle' ) ) {\n\t\t\t\tif ( shouldInheritListType( existingListItem, item ) ) {\n\t\t\t\t\twriter.setAttribute( 'listStyle', existingListItem.getAttribute( 'listStyle' ), item );\n\t\t\t\t} else {\n\t\t\t\t\twriter.setAttribute( 'listStyle', DEFAULT_LIST_TYPE, item );\n\t\t\t\t}\n\t\t\t\twasFixed = true;\n\t\t\t} else {\n\t\t\t\t// Adjust the `listStyle` attribute for inserted (pasted) items. See #8160.\n\t\t\t\t//\n\t\t\t\t// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n\t\t\t\t//     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n\t\t\t\t//     ○ [] (selection is here)\n\t\t\t\t//\n\t\t\t\t// Then, pasting a list with different attributes (listStyle, listType):\n\t\t\t\t//\n\t\t\t\t// 1. First. // [listStyle=\"decimal\", listType=\"numbered\"]\n\t\t\t\t// 2. Second // [listStyle=\"decimal\", listType=\"numbered\"]\n\t\t\t\t//\n\t\t\t\t// The `listType` attribute will be corrected by the `ListEditing` converters.\n\t\t\t\t// We need to adjust the `listStyle` attribute. Expected structure:\n\t\t\t\t//\n\t\t\t\t// ■ List item 1. // [listStyle=\"square\", listType=\"bulleted\"]\n\t\t\t\t//     ○ List item 1.1. // [listStyle=\"circle\", listType=\"bulleted\"]\n\t\t\t\t//     ○ First. // [listStyle=\"circle\", listType=\"bulleted\"]\n\t\t\t\t//     ○ Second // [listStyle=\"circle\", listType=\"bulleted\"]\n\t\t\t\tconst previousSibling = item.previousSibling;\n\n\t\t\t\tif ( shouldInheritListTypeFromPreviousItem( previousSibling, item ) ) {\n\t\t\t\t\twriter.setAttribute( 'listStyle', previousSibling.getAttribute( 'listStyle' ), item );\n\n\t\t\t\t\twasFixed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn wasFixed;\n\t};\n}\n\n// Checks whether the `listStyle` attribute should be copied from the `baseItem` element.\n//\n// The attribute should be copied if the inserted element does not have defined it and\n// the value for the element is other than default in the base element.\n//\n// @param {module:engine/model/element~Element|null} baseItem\n// @param {module:engine/model/element~Element} itemToChange\n// @returns {Boolean}\nfunction shouldInheritListType( baseItem, itemToChange ) {\n\tif ( !baseItem ) {\n\t\treturn false;\n\t}\n\n\tconst baseListStyle = baseItem.getAttribute( 'listStyle' );\n\n\tif ( !baseListStyle ) {\n\t\treturn false;\n\t}\n\n\tif ( baseListStyle === DEFAULT_LIST_TYPE ) {\n\t\treturn false;\n\t}\n\n\tif ( baseItem.getAttribute( 'listType' ) !== itemToChange.getAttribute( 'listType' ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Checks whether the `listStyle` attribute should be copied from previous list item.\n//\n// The attribute should be copied if there's a mismatch of styles of the pasted list into a nested list.\n// Top-level lists are not normalized as we allow side-by-side list of different types.\n//\n// @param {module:engine/model/element~Element|null} previousItem\n// @param {module:engine/model/element~Element} itemToChange\n// @returns {Boolean}\nfunction shouldInheritListTypeFromPreviousItem( previousItem, itemToChange ) {\n\tif ( !previousItem || !previousItem.is( 'element', 'listItem' ) ) {\n\t\treturn false;\n\t}\n\n\tif ( itemToChange.getAttribute( 'listType' ) !== previousItem.getAttribute( 'listType' ) ) {\n\t\treturn false;\n\t}\n\n\tconst previousItemIndent = previousItem.getAttribute( 'listIndent' );\n\n\tif ( previousItemIndent < 1 || previousItemIndent !== itemToChange.getAttribute( 'listIndent' ) ) {\n\t\treturn false;\n\t}\n\n\tconst previousItemListStyle = previousItem.getAttribute( 'listStyle' );\n\n\tif ( !previousItemListStyle || previousItemListStyle === itemToChange.getAttribute( 'listStyle' ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Removes the `listStyle` attribute from \"todo\" list items.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\nfunction removeListStyleAttributeFromTodoList( editor ) {\n\treturn writer => {\n\t\tconst todoListItems = getChangedListItems( editor.model.document.differ.getChanges() )\n\t\t\t.filter( item => {\n\t\t\t\t// Handle the todo lists only. The rest is handled in another post-fixer.\n\t\t\t\treturn item.getAttribute( 'listType' ) === 'todo' && item.hasAttribute( 'listStyle' );\n\t\t\t} );\n\n\t\tif ( !todoListItems.length ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const item of todoListItems ) {\n\t\t\twriter.removeAttribute( 'listStyle', item );\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// Restores the `listStyle` attribute after changing the list type.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @returns {Function}\nfunction restoreDefaultListStyle( editor ) {\n\treturn ( evt, changedItems ) => {\n\t\tchangedItems = changedItems.filter( item => item.is( 'element', 'listItem' ) );\n\n\t\teditor.model.change( writer => {\n\t\t\tfor ( const item of changedItems ) {\n\t\t\t\t// Remove the attribute. Post-fixer will restore the proper value.\n\t\t\t\twriter.removeAttribute( 'listStyle', item );\n\t\t\t}\n\t\t} );\n\t};\n}\n\n// Returns the `listItem` that was inserted or changed.\n//\n// @param {Array.<Object>} changes The changes list returned by the differ.\n// @returns {Array.<module:engine/model/element~Element>}\nfunction getChangedListItems( changes ) {\n\tconst items = [];\n\n\tfor ( const change of changes ) {\n\t\tconst item = getItemFromChange( change );\n\n\t\tif ( item && item.is( 'element', 'listItem' ) ) {\n\t\t\titems.push( item );\n\t\t}\n\t}\n\n\treturn items;\n}\n\nfunction getItemFromChange( change ) {\n\tif ( change.type === 'attribute' ) {\n\t\treturn change.range.start.nodeAfter;\n\t}\n\n\tif ( change.type === 'insert' ) {\n\t\treturn change.position.nodeAfter;\n\t}\n\n\treturn null;\n}\n\n"]},"metadata":{},"sourceType":"module"}
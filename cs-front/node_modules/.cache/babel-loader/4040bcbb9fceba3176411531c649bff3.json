{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n// @if CK_DEBUG // import { CKEditorError } from 'ckeditor5/src/utils';\n\n/**\n * The table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableSlot} with proper table cell attributes.\n */\nexport default class TableWalker {\n  /**\n   * Creates an instance of the table walker.\n   *\n   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n   * It walks row by row and column by column in order to output values defined in the constructor.\n   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,\n   * pass the `includeAllSlots` option to the constructor.\n   *\n   * The most important values of the iterator are column and row indexes of a cell.\n   *\n   * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.\n   *\n   * To iterate over a given row:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n   *\n   *\t\tfor ( const tableSlot of tableWalker ) {\n   *\t\t\tconsole.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );\n   *\t\t}\n   *\n   * For instance the code above for the following table:\n   *\n   *\t\t+----+----+----+----+----+----+\n   *\t\t| 00      | 02 | 03 | 04 | 05 |\n   *\t\t|         +----+----+----+----+\n   *\t\t|         | 12      | 14 | 15 |\n   *\t\t|         +----+----+----+    +\n   *\t\t|         | 22           |    |\n   *\t\t|----+----+----+----+----+    +\n   *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n   *\t\t+----+----+----+----+----+----+\n   *\n   * will log in the console:\n   *\n   *\t\t'A cell at row 1 and column 2'\n   *\t\t'A cell at row 1 and column 4'\n   *\t\t'A cell at row 1 and column 5'\n   *\t\t'A cell at row 2 and column 2'\n   *\n   * To also iterate over spanned cells:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );\n   *\n   *\t\tfor ( const tableSlot of tableWalker ) {\n   *\t\t\tconsole.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );\n   *\t\t}\n   *\n   * will log in the console for the table from the previous example:\n   *\n   *\t\t'Cell at 1 x 0 : is spanned'\n   *\t\t'Cell at 1 x 1 : is spanned'\n   *\t\t'Cell at 1 x 2 : is anchored'\n   *\t\t'Cell at 1 x 3 : is spanned'\n   *\t\t'Cell at 1 x 4 : is anchored'\n   *\t\t'Cell at 1 x 5 : is anchored'\n   *\n   * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.\n   * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`\n   * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).\n   *\n   * @constructor\n   * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n   * @param {Object} [options={}] An object with configuration.\n   * @param {Number} [options.row] A row index for which this iterator will output cells.\n   * Can't be used together with `startRow` and `endRow`.\n   * @param {Number} [options.startRow=0] A row index from which this iterator should start. Can't be used together with `row`.\n   * @param {Number} [options.endRow] A row index at which this iterator should end. Can't be used together with `row`.\n   * @param {Number} [options.column] A column index for which this iterator will output cells.\n   * Can't be used together with `startColumn` and `endColumn`.\n   * @param {Number} [options.startColumn=0] A column index from which this iterator should start. Can't be used together with `column`.\n   * @param {Number} [options.endColumn] A column index at which this iterator should end. Can't be used together with `column`.\n   * @param {Boolean} [options.includeAllSlots=false] Also return values for spanned cells.\n   */\n  constructor(table) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * The walker's table element.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element}\n     * @protected\n     */\n    this._table = table;\n    /**\n     * A row index from which this iterator will start.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._startRow = options.row !== undefined ? options.row : options.startRow || 0;\n    /**\n     * A row index at which this iterator will end.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._endRow = options.row !== undefined ? options.row : options.endRow;\n    /**\n     * If set, the table walker will only output cells from a given column and following ones or cells that overlap them.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._startColumn = options.column !== undefined ? options.column : options.startColumn || 0;\n    /**\n     * If set, the table walker will only output cells up to a given column.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._endColumn = options.column !== undefined ? options.column : options.endColumn;\n    /**\n     * Enables output of spanned cells that are normally not yielded.\n     *\n     * @readonly\n     * @member {Boolean}\n     * @private\n     */\n\n    this._includeAllSlots = !!options.includeAllSlots;\n    /**\n     * Row indexes to skip from the iteration.\n     *\n     * @readonly\n     * @member {Set<Number>}\n     * @private\n     */\n\n    this._skipRows = new Set();\n    /**\n     * The current row index.\n     *\n     * @member {Number}\n     * @protected\n     */\n\n    this._row = 0;\n    /**\n     * The index of the current row element in the table.\n     *\n     * @type {Number}\n     * @protected\n     */\n\n    this._rowIndex = 0;\n    /**\n     * The current column index.\n     *\n     * @member {Number}\n     * @protected\n     */\n\n    this._column = 0;\n    /**\n     * The cell index in a parent row. For spanned cells when {@link #_includeAllSlots} is set to `true`,\n     * this represents the index of the next table cell.\n     *\n     * @member {Number}\n     * @protected\n     */\n\n    this._cellIndex = 0;\n    /**\n     * Holds a map of spanned cells in a table.\n     *\n     * @readonly\n     * @member {Map.<Number, Map.<Number, Object>>}\n     * @private\n     */\n\n    this._spannedCells = new Map();\n    /**\n     * Index of the next column where a cell is anchored.\n     *\n     * @member {Number}\n     * @private\n     */\n\n    this._nextCellAtColumn = -1;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:table/tablewalker~TableSlot>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Gets the next table walker's value.\n   *\n   * @returns {module:table/tablewalker~TableSlot} The next table walker's value.\n   */\n\n\n  next() {\n    const row = this._table.getChild(this._rowIndex); // Iterator is done when there's no row (table ended) or the row is after `endRow` limit.\n\n\n    if (!row || this._isOverEndRow()) {\n      return {\n        done: true\n      };\n    } // We step over current element when it is not a tableRow instance.\n\n\n    if (!row.is('element', 'tableRow')) {\n      this._rowIndex++;\n      return this.next();\n    }\n\n    if (this._isOverEndColumn()) {\n      return this._advanceToNextRow();\n    }\n\n    let outValue = null;\n\n    const spanData = this._getSpanned();\n\n    if (spanData) {\n      if (this._includeAllSlots && !this._shouldSkipSlot()) {\n        outValue = this._formatOutValue(spanData.cell, spanData.row, spanData.column);\n      }\n    } else {\n      const cell = row.getChild(this._cellIndex);\n\n      if (!cell) {\n        // If there are no more cells left in row advance to the next row.\n        return this._advanceToNextRow();\n      }\n\n      const colspan = parseInt(cell.getAttribute('colspan') || 1);\n      const rowspan = parseInt(cell.getAttribute('rowspan') || 1); // Record this cell spans if it's not 1x1 cell.\n\n      if (colspan > 1 || rowspan > 1) {\n        this._recordSpans(cell, rowspan, colspan);\n      }\n\n      if (!this._shouldSkipSlot()) {\n        outValue = this._formatOutValue(cell);\n      }\n\n      this._nextCellAtColumn = this._column + colspan;\n    } // Advance to the next column before returning value.\n\n\n    this._column++;\n\n    if (this._column == this._nextCellAtColumn) {\n      this._cellIndex++;\n    } // The current value will be returned only if current row and column are not skipped.\n\n\n    return outValue || this.next();\n  }\n  /**\n   * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n   * to output.\n   *\n   * @param {Number} row The row index to skip.\n   */\n\n\n  skipRow(row) {\n    this._skipRows.add(row);\n  }\n  /**\n   * Advances internal cursor to the next row.\n   *\n   * @private\n   * @returns {module:table/tablewalker~TableSlot}\n   */\n\n\n  _advanceToNextRow() {\n    this._row++;\n    this._rowIndex++;\n    this._column = 0;\n    this._cellIndex = 0;\n    this._nextCellAtColumn = -1;\n    return this.next();\n  }\n  /**\n   * Checks if the current row is over {@link #_endRow}.\n   *\n   * @private\n   * @returns {Boolean}\n   */\n\n\n  _isOverEndRow() {\n    // If #_endRow is defined skip all rows after it.\n    return this._endRow !== undefined && this._row > this._endRow;\n  }\n  /**\n   * Checks if the current cell is over {@link #_endColumn}\n   *\n   * @private\n   * @returns {Boolean}\n   */\n\n\n  _isOverEndColumn() {\n    // If #_endColumn is defined skip all cells after it.\n    return this._endColumn !== undefined && this._column > this._endColumn;\n  }\n  /**\n   * A common method for formatting the iterator's output value.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} cell The table cell to output.\n   * @param {Number} [anchorRow] The row index of a cell anchor slot.\n   * @param {Number} [anchorColumn] The column index of a cell anchor slot.\n   * @returns {{done: Boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n   */\n\n\n  _formatOutValue(cell) {\n    let anchorRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row;\n    let anchorColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._column;\n    return {\n      done: false,\n      value: new TableSlot(this, cell, anchorRow, anchorColumn)\n    };\n  }\n  /**\n   * Checks if the current slot should be skipped.\n   *\n   * @private\n   * @returns {Boolean}\n   */\n\n\n  _shouldSkipSlot() {\n    const rowIsMarkedAsSkipped = this._skipRows.has(this._row);\n\n    const rowIsBeforeStartRow = this._row < this._startRow;\n    const columnIsBeforeStartColumn = this._column < this._startColumn;\n    const columnIsAfterEndColumn = this._endColumn !== undefined && this._column > this._endColumn;\n    return rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;\n  }\n  /**\n   * Returns the cell element that is spanned over the current cell location.\n   *\n   * @private\n   * @returns {module:engine/model/element~Element}\n   */\n\n\n  _getSpanned() {\n    const rowMap = this._spannedCells.get(this._row); // No spans for given row.\n\n\n    if (!rowMap) {\n      return null;\n    } // If spans for given rows has entry for column it means that this location if spanned by other cell.\n\n\n    return rowMap.get(this._column) || null;\n  }\n  /**\n   * Updates spanned cells map relative to the current cell location and its span dimensions.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} cell A cell that is spanned.\n   * @param {Number} rowspan Cell height.\n   * @param {Number} colspan Cell width.\n   */\n\n\n  _recordSpans(cell, rowspan, colspan) {\n    const data = {\n      cell,\n      row: this._row,\n      column: this._column\n    };\n\n    for (let rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++) {\n      for (let columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++) {\n        if (rowToUpdate != this._row || columnToUpdate != this._column) {\n          this._markSpannedCell(rowToUpdate, columnToUpdate, data);\n        }\n      }\n    }\n  }\n  /**\n   * Marks the cell location as spanned by another cell.\n   *\n   * @private\n   * @param {Number} row The row index of the cell location.\n   * @param {Number} column The column index of the cell location.\n   * @param {Object} data A spanned cell details (cell element, anchor row and column).\n   */\n\n\n  _markSpannedCell(row, column, data) {\n    if (!this._spannedCells.has(row)) {\n      this._spannedCells.set(row, new Map());\n    }\n\n    const rowSpans = this._spannedCells.get(row);\n\n    rowSpans.set(column, data);\n  }\n\n}\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n */\n\nclass TableSlot {\n  /**\n   * Creates an instance of the table walker value.\n   *\n   * @protected\n   * @param {module:table/tablewalker~TableWalker} tableWalker The table walker instance.\n   * @param {module:engine/model/element~Element} cell The current table cell.\n   * @param {Number} anchorRow The row index of a cell anchor slot.\n   * @param {Number} anchorColumn The column index of a cell anchor slot.\n   */\n  constructor(tableWalker, cell, anchorRow, anchorColumn) {\n    /**\n     * The current table cell.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element}\n     */\n    this.cell = cell;\n    /**\n     * The row index of a table slot.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.row = tableWalker._row;\n    /**\n     * The column index of a table slot.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.column = tableWalker._column;\n    /**\n     * The row index of a cell anchor slot.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.cellAnchorRow = anchorRow;\n    /**\n     * The column index of a cell anchor slot.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.cellAnchorColumn = anchorColumn;\n    /**\n     * The index of the current cell in the parent row.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._cellIndex = tableWalker._cellIndex;\n    /**\n     * The index of the current row element in the table.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._rowIndex = tableWalker._rowIndex;\n    /**\n     * The table element.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element}\n     * @private\n     */\n\n    this._table = tableWalker._table;\n  }\n  /**\n   * Whether the cell is anchored in the current slot.\n   *\n   * @readonly\n   * @returns {Boolean}\n   */\n\n\n  get isAnchor() {\n    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;\n  }\n  /**\n   * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.\n   *\n   * @readonly\n   * @returns {Number}\n   */\n\n\n  get cellWidth() {\n    return parseInt(this.cell.getAttribute('colspan') || 1);\n  }\n  /**\n   * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.\n   *\n   * @readonly\n   * @returns {Number}\n   */\n\n\n  get cellHeight() {\n    return parseInt(this.cell.getAttribute('rowspan') || 1);\n  }\n  /**\n   * The index of the current row element in the table.\n   *\n   * @readonly\n   * @returns {Number}\n   */\n\n\n  get rowIndex() {\n    return this._rowIndex;\n  }\n  /**\n   * Returns the {@link module:engine/model/position~Position} before the table slot.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  getPositionBefore() {\n    const model = this._table.root.document.model;\n    return model.createPositionAt(this._table.getChild(this.row), this._cellIndex);\n  } // @if CK_DEBUG // get isSpanned() { throwMissingGetterError( 'isSpanned' ); }\n  // @if CK_DEBUG // get colspan() { throwMissingGetterError( 'colspan' ); }\n  // @if CK_DEBUG // get rowspan() { throwMissingGetterError( 'rowspan' ); }\n  // @if CK_DEBUG // get cellIndex() { throwMissingGetterError( 'cellIndex' ); }\n\n\n}\n/**\n * This `TableSlot`'s getter (property) was removed in CKEditor 5 v20.0.0.\n *\n * Check out the new `TableWalker`'s API in the documentation.\n *\n * @error tableslot-getter-removed\n * @param {String} getterName\n */\n// @if CK_DEBUG // function throwMissingGetterError( getterName ) {\n// @if CK_DEBUG //\t\tthrow new CKEditorError( 'tableslot-getter-removed', this, {\n// @if CK_DEBUG //\t\t\tgetterName\n// @if CK_DEBUG //\t\t} );\n// @if CK_DEBUG // }","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js"],"names":["TableWalker","constructor","table","options","_table","_startRow","row","undefined","startRow","_endRow","endRow","_startColumn","column","startColumn","_endColumn","endColumn","_includeAllSlots","includeAllSlots","_skipRows","Set","_row","_rowIndex","_column","_cellIndex","_spannedCells","Map","_nextCellAtColumn","Symbol","iterator","next","getChild","_isOverEndRow","done","is","_isOverEndColumn","_advanceToNextRow","outValue","spanData","_getSpanned","_shouldSkipSlot","_formatOutValue","cell","colspan","parseInt","getAttribute","rowspan","_recordSpans","skipRow","add","anchorRow","anchorColumn","value","TableSlot","rowIsMarkedAsSkipped","has","rowIsBeforeStartRow","columnIsBeforeStartColumn","columnIsAfterEndColumn","rowMap","get","data","rowToUpdate","columnToUpdate","_markSpannedCell","set","rowSpans","tableWalker","cellAnchorRow","cellAnchorColumn","isAnchor","cellWidth","cellHeight","rowIndex","getPositionBefore","model","root","document","createPositionAt"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAMA,WAAN,CAAkB;AAChC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,KAAF,EAAwB;AAAA,QAAfC,OAAe,uEAAL,EAAK;;AAClC;AACF;AACA;AACA;AACA;AACA;AACA;AACE,SAAKC,MAAL,GAAcF,KAAd;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKG,SAAL,GAAiBF,OAAO,CAACG,GAAR,KAAgBC,SAAhB,GAA4BJ,OAAO,CAACG,GAApC,GAA0CH,OAAO,CAACK,QAAR,IAAoB,CAA/E;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,OAAL,GAAeN,OAAO,CAACG,GAAR,KAAgBC,SAAhB,GAA4BJ,OAAO,CAACG,GAApC,GAA0CH,OAAO,CAACO,MAAjE;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoBR,OAAO,CAACS,MAAR,KAAmBL,SAAnB,GAA+BJ,OAAO,CAACS,MAAvC,GAAgDT,OAAO,CAACU,WAAR,IAAuB,CAA3F;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,UAAL,GAAkBX,OAAO,CAACS,MAAR,KAAmBL,SAAnB,GAA+BJ,OAAO,CAACS,MAAvC,GAAgDT,OAAO,CAACY,SAA1E;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,gBAAL,GA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n\n// @if CK_DEBUG // import { CKEditorError } from 'ckeditor5/src/utils';\n\n/**\n * The table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableSlot} with proper table cell attributes.\n */\nexport default class TableWalker {\n\t/**\n\t * Creates an instance of the table walker.\n\t *\n\t * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n\t * It walks row by row and column by column in order to output values defined in the constructor.\n\t * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,\n\t * pass the `includeAllSlots` option to the constructor.\n\t *\n\t * The most important values of the iterator are column and row indexes of a cell.\n\t *\n\t * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.\n\t *\n\t * To iterate over a given row:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n\t *\n\t *\t\tfor ( const tableSlot of tableWalker ) {\n\t *\t\t\tconsole.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );\n\t *\t\t}\n\t *\n\t * For instance the code above for the following table:\n\t *\n\t *\t\t+----+----+----+----+----+----+\n\t *\t\t| 00      | 02 | 03 | 04 | 05 |\n\t *\t\t|         +----+----+----+----+\n\t *\t\t|         | 12      | 14 | 15 |\n\t *\t\t|         +----+----+----+    +\n\t *\t\t|         | 22           |    |\n\t *\t\t|----+----+----+----+----+    +\n\t *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n\t *\t\t+----+----+----+----+----+----+\n\t *\n\t * will log in the console:\n\t *\n\t *\t\t'A cell at row 1 and column 2'\n\t *\t\t'A cell at row 1 and column 4'\n\t *\t\t'A cell at row 1 and column 5'\n\t *\t\t'A cell at row 2 and column 2'\n\t *\n\t * To also iterate over spanned cells:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );\n\t *\n\t *\t\tfor ( const tableSlot of tableWalker ) {\n\t *\t\t\tconsole.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );\n\t *\t\t}\n\t *\n\t * will log in the console for the table from the previous example:\n\t *\n\t *\t\t'Cell at 1 x 0 : is spanned'\n\t *\t\t'Cell at 1 x 1 : is spanned'\n\t *\t\t'Cell at 1 x 2 : is anchored'\n\t *\t\t'Cell at 1 x 3 : is spanned'\n\t *\t\t'Cell at 1 x 4 : is anchored'\n\t *\t\t'Cell at 1 x 5 : is anchored'\n\t *\n\t * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.\n\t * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`\n\t * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).\n\t *\n\t * @constructor\n\t * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n\t * @param {Object} [options={}] An object with configuration.\n\t * @param {Number} [options.row] A row index for which this iterator will output cells.\n\t * Can't be used together with `startRow` and `endRow`.\n\t * @param {Number} [options.startRow=0] A row index from which this iterator should start. Can't be used together with `row`.\n\t * @param {Number} [options.endRow] A row index at which this iterator should end. Can't be used together with `row`.\n\t * @param {Number} [options.column] A column index for which this iterator will output cells.\n\t * Can't be used together with `startColumn` and `endColumn`.\n\t * @param {Number} [options.startColumn=0] A column index from which this iterator should start. Can't be used together with `column`.\n\t * @param {Number} [options.endColumn] A column index at which this iterator should end. Can't be used together with `column`.\n\t * @param {Boolean} [options.includeAllSlots=false] Also return values for spanned cells.\n\t */\n\tconstructor( table, options = {} ) {\n\t\t/**\n\t\t * The walker's table element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element}\n\t\t * @protected\n\t\t */\n\t\tthis._table = table;\n\n\t\t/**\n\t\t * A row index from which this iterator will start.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._startRow = options.row !== undefined ? options.row : options.startRow || 0;\n\n\t\t/**\n\t\t * A row index at which this iterator will end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._endRow = options.row !== undefined ? options.row : options.endRow;\n\n\t\t/**\n\t\t * If set, the table walker will only output cells from a given column and following ones or cells that overlap them.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._startColumn = options.column !== undefined ? options.column : options.startColumn || 0;\n\n\t\t/**\n\t\t * If set, the table walker will only output cells up to a given column.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._endColumn = options.column !== undefined ? options.column : options.endColumn;\n\n\t\t/**\n\t\t * Enables output of spanned cells that are normally not yielded.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t * @private\n\t\t */\n\t\tthis._includeAllSlots = !!options.includeAllSlots;\n\n\t\t/**\n\t\t * Row indexes to skip from the iteration.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set<Number>}\n\t\t * @private\n\t\t */\n\t\tthis._skipRows = new Set();\n\n\t\t/**\n\t\t * The current row index.\n\t\t *\n\t\t * @member {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._row = 0;\n\n\t\t/**\n\t\t * The index of the current row element in the table.\n\t\t *\n\t\t * @type {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._rowIndex = 0;\n\n\t\t/**\n\t\t * The current column index.\n\t\t *\n\t\t * @member {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._column = 0;\n\n\t\t/**\n\t\t * The cell index in a parent row. For spanned cells when {@link #_includeAllSlots} is set to `true`,\n\t\t * this represents the index of the next table cell.\n\t\t *\n\t\t * @member {Number}\n\t\t * @protected\n\t\t */\n\t\tthis._cellIndex = 0;\n\n\t\t/**\n\t\t * Holds a map of spanned cells in a table.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map.<Number, Map.<Number, Object>>}\n\t\t * @private\n\t\t */\n\t\tthis._spannedCells = new Map();\n\n\t\t/**\n\t\t * Index of the next column where a cell is anchored.\n\t\t *\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._nextCellAtColumn = -1;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:table/tablewalker~TableSlot>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets the next table walker's value.\n\t *\n\t * @returns {module:table/tablewalker~TableSlot} The next table walker's value.\n\t */\n\tnext() {\n\t\tconst row = this._table.getChild( this._rowIndex );\n\n\t\t// Iterator is done when there's no row (table ended) or the row is after `endRow` limit.\n\t\tif ( !row || this._isOverEndRow() ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We step over current element when it is not a tableRow instance.\n\t\tif ( !row.is( 'element', 'tableRow' ) ) {\n\t\t\tthis._rowIndex++;\n\n\t\t\treturn this.next();\n\t\t}\n\n\t\tif ( this._isOverEndColumn() ) {\n\t\t\treturn this._advanceToNextRow();\n\t\t}\n\n\t\tlet outValue = null;\n\n\t\tconst spanData = this._getSpanned();\n\n\t\tif ( spanData ) {\n\t\t\tif ( this._includeAllSlots && !this._shouldSkipSlot() ) {\n\t\t\t\toutValue = this._formatOutValue( spanData.cell, spanData.row, spanData.column );\n\t\t\t}\n\t\t} else {\n\t\t\tconst cell = row.getChild( this._cellIndex );\n\n\t\t\tif ( !cell ) {\n\t\t\t\t// If there are no more cells left in row advance to the next row.\n\t\t\t\treturn this._advanceToNextRow();\n\t\t\t}\n\n\t\t\tconst colspan = parseInt( cell.getAttribute( 'colspan' ) || 1 );\n\t\t\tconst rowspan = parseInt( cell.getAttribute( 'rowspan' ) || 1 );\n\n\t\t\t// Record this cell spans if it's not 1x1 cell.\n\t\t\tif ( colspan > 1 || rowspan > 1 ) {\n\t\t\t\tthis._recordSpans( cell, rowspan, colspan );\n\t\t\t}\n\n\t\t\tif ( !this._shouldSkipSlot() ) {\n\t\t\t\toutValue = this._formatOutValue( cell );\n\t\t\t}\n\n\t\t\tthis._nextCellAtColumn = this._column + colspan;\n\t\t}\n\n\t\t// Advance to the next column before returning value.\n\t\tthis._column++;\n\n\t\tif ( this._column == this._nextCellAtColumn ) {\n\t\t\tthis._cellIndex++;\n\t\t}\n\n\t\t// The current value will be returned only if current row and column are not skipped.\n\t\treturn outValue || this.next();\n\t}\n\n\t/**\n\t * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n\t * to output.\n\t *\n\t * @param {Number} row The row index to skip.\n\t */\n\tskipRow( row ) {\n\t\tthis._skipRows.add( row );\n\t}\n\n\t/**\n\t * Advances internal cursor to the next row.\n\t *\n\t * @private\n\t * @returns {module:table/tablewalker~TableSlot}\n\t */\n\t_advanceToNextRow() {\n\t\tthis._row++;\n\t\tthis._rowIndex++;\n\t\tthis._column = 0;\n\t\tthis._cellIndex = 0;\n\t\tthis._nextCellAtColumn = -1;\n\n\t\treturn this.next();\n\t}\n\n\t/**\n\t * Checks if the current row is over {@link #_endRow}.\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_isOverEndRow() {\n\t\t// If #_endRow is defined skip all rows after it.\n\t\treturn this._endRow !== undefined && this._row > this._endRow;\n\t}\n\n\t/**\n\t * Checks if the current cell is over {@link #_endColumn}\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_isOverEndColumn() {\n\t\t// If #_endColumn is defined skip all cells after it.\n\t\treturn this._endColumn !== undefined && this._column > this._endColumn;\n\t}\n\n\t/**\n\t * A common method for formatting the iterator's output value.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} cell The table cell to output.\n\t * @param {Number} [anchorRow] The row index of a cell anchor slot.\n\t * @param {Number} [anchorColumn] The column index of a cell anchor slot.\n\t * @returns {{done: Boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n\t */\n\t_formatOutValue( cell, anchorRow = this._row, anchorColumn = this._column ) {\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: new TableSlot( this, cell, anchorRow, anchorColumn )\n\t\t};\n\t}\n\n\t/**\n\t * Checks if the current slot should be skipped.\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_shouldSkipSlot() {\n\t\tconst rowIsMarkedAsSkipped = this._skipRows.has( this._row );\n\t\tconst rowIsBeforeStartRow = this._row < this._startRow;\n\n\t\tconst columnIsBeforeStartColumn = this._column < this._startColumn;\n\t\tconst columnIsAfterEndColumn = this._endColumn !== undefined && this._column > this._endColumn;\n\n\t\treturn rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;\n\t}\n\n\t/**\n\t * Returns the cell element that is spanned over the current cell location.\n\t *\n\t * @private\n\t * @returns {module:engine/model/element~Element}\n\t */\n\t_getSpanned() {\n\t\tconst rowMap = this._spannedCells.get( this._row );\n\n\t\t// No spans for given row.\n\t\tif ( !rowMap ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If spans for given rows has entry for column it means that this location if spanned by other cell.\n\t\treturn rowMap.get( this._column ) || null;\n\t}\n\n\t/**\n\t * Updates spanned cells map relative to the current cell location and its span dimensions.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} cell A cell that is spanned.\n\t * @param {Number} rowspan Cell height.\n\t * @param {Number} colspan Cell width.\n\t */\n\t_recordSpans( cell, rowspan, colspan ) {\n\t\tconst data = {\n\t\t\tcell,\n\t\t\trow: this._row,\n\t\t\tcolumn: this._column\n\t\t};\n\n\t\tfor ( let rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++ ) {\n\t\t\tfor ( let columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++ ) {\n\t\t\t\tif ( rowToUpdate != this._row || columnToUpdate != this._column ) {\n\t\t\t\t\tthis._markSpannedCell( rowToUpdate, columnToUpdate, data );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Marks the cell location as spanned by another cell.\n\t *\n\t * @private\n\t * @param {Number} row The row index of the cell location.\n\t * @param {Number} column The column index of the cell location.\n\t * @param {Object} data A spanned cell details (cell element, anchor row and column).\n\t */\n\t_markSpannedCell( row, column, data ) {\n\t\tif ( !this._spannedCells.has( row ) ) {\n\t\t\tthis._spannedCells.set( row, new Map() );\n\t\t}\n\n\t\tconst rowSpans = this._spannedCells.get( row );\n\n\t\trowSpans.set( column, data );\n\t}\n}\n\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n */\nclass TableSlot {\n\t/**\n\t * Creates an instance of the table walker value.\n\t *\n\t * @protected\n\t * @param {module:table/tablewalker~TableWalker} tableWalker The table walker instance.\n\t * @param {module:engine/model/element~Element} cell The current table cell.\n\t * @param {Number} anchorRow The row index of a cell anchor slot.\n\t * @param {Number} anchorColumn The column index of a cell anchor slot.\n\t */\n\tconstructor( tableWalker, cell, anchorRow, anchorColumn ) {\n\t\t/**\n\t\t * The current table cell.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element}\n\t\t */\n\t\tthis.cell = cell;\n\n\t\t/**\n\t\t * The row index of a table slot.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.row = tableWalker._row;\n\n\t\t/**\n\t\t * The column index of a table slot.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.column = tableWalker._column;\n\n\t\t/**\n\t\t * The row index of a cell anchor slot.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.cellAnchorRow = anchorRow;\n\n\t\t/**\n\t\t * The column index of a cell anchor slot.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.cellAnchorColumn = anchorColumn;\n\n\t\t/**\n\t\t * The index of the current cell in the parent row.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._cellIndex = tableWalker._cellIndex;\n\n\t\t/**\n\t\t * The index of the current row element in the table.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._rowIndex = tableWalker._rowIndex;\n\n\t\t/**\n\t\t * The table element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element}\n\t\t * @private\n\t\t */\n\t\tthis._table = tableWalker._table;\n\t}\n\n\t/**\n\t * Whether the cell is anchored in the current slot.\n\t *\n\t * @readonly\n\t * @returns {Boolean}\n\t */\n\tget isAnchor() {\n\t\treturn this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;\n\t}\n\n\t/**\n\t * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.\n\t *\n\t * @readonly\n\t * @returns {Number}\n\t */\n\tget cellWidth() {\n\t\treturn parseInt( this.cell.getAttribute( 'colspan' ) || 1 );\n\t}\n\n\t/**\n\t * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.\n\t *\n\t * @readonly\n\t * @returns {Number}\n\t */\n\tget cellHeight() {\n\t\treturn parseInt( this.cell.getAttribute( 'rowspan' ) || 1 );\n\t}\n\n\t/**\n\t * The index of the current row element in the table.\n\t *\n\t * @readonly\n\t * @returns {Number}\n\t */\n\tget rowIndex() {\n\t\treturn this._rowIndex;\n\t}\n\n\t/**\n\t * Returns the {@link module:engine/model/position~Position} before the table slot.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetPositionBefore() {\n\t\tconst model = this._table.root.document.model;\n\n\t\treturn model.createPositionAt( this._table.getChild( this.row ), this._cellIndex );\n\t}\n\n\t// @if CK_DEBUG // get isSpanned() { throwMissingGetterError( 'isSpanned' ); }\n\t// @if CK_DEBUG // get colspan() { throwMissingGetterError( 'colspan' ); }\n\t// @if CK_DEBUG // get rowspan() { throwMissingGetterError( 'rowspan' ); }\n\t// @if CK_DEBUG // get cellIndex() { throwMissingGetterError( 'cellIndex' ); }\n}\n\n/**\n * This `TableSlot`'s getter (property) was removed in CKEditor 5 v20.0.0.\n *\n * Check out the new `TableWalker`'s API in the documentation.\n *\n * @error tableslot-getter-removed\n * @param {String} getterName\n */\n\n// @if CK_DEBUG // function throwMissingGetterError( getterName ) {\n// @if CK_DEBUG //\t\tthrow new CKEditorError( 'tableslot-getter-removed', this, {\n// @if CK_DEBUG //\t\t\tgetterName\n// @if CK_DEBUG //\t\t} );\n// @if CK_DEBUG // }\n"]},"metadata":{},"sourceType":"module"}
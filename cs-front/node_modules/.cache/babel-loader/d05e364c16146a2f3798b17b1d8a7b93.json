{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/removecolumncommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport TableWalker from '../tablewalker';\nimport { getColumnIndexes, getSelectionAffectedTableCells } from '../utils/selection';\n/**\n * The remove column command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'removeTableColumn'` editor command.\n *\n * To remove the column containing the selected cell, execute the command:\n *\n *\t\teditor.execute( 'removeTableColumn' );\n *\n * @extends module:core/command~Command\n */\n\nexport default class RemoveColumnCommand extends Command {\n  /**\n   * @inheritDoc\n   */\n  refresh() {\n    const selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);\n    const firstCell = selectedCells[0];\n\n    if (firstCell) {\n      const table = firstCell.findAncestor('table');\n      const tableColumnCount = this.editor.plugins.get('TableUtils').getColumns(table);\n      const {\n        first,\n        last\n      } = getColumnIndexes(selectedCells);\n      this.isEnabled = last - first < tableColumnCount - 1;\n    } else {\n      this.isEnabled = false;\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  execute() {\n    const [firstCell, lastCell] = getBoundaryCells(this.editor.model.document.selection);\n    const table = firstCell.parent.parent; // Cache the table before removing or updating colspans.\n\n    const tableMap = [...new TableWalker(table)]; // Store column indexes of removed columns.\n\n    const removedColumnIndexes = {\n      first: tableMap.find(value => value.cell === firstCell).column,\n      last: tableMap.find(value => value.cell === lastCell).column\n    };\n    const cellToFocus = getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes);\n    this.editor.model.change(writer => {\n      const columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;\n      this.editor.plugins.get('TableUtils').removeColumns(table, {\n        at: removedColumnIndexes.first,\n        columns: columnsToRemove\n      });\n      writer.setSelection(writer.createPositionAt(cellToFocus, 0));\n    });\n  }\n\n} // Returns a proper table cell to focus after removing a column.\n// - selection is on last table cell it will return previous cell.\n\nfunction getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes) {\n  const colspan = parseInt(lastCell.getAttribute('colspan') || 1); // If the table cell is spanned over 2+ columns - it will be truncated so the selection should\n  // stay in that cell.\n\n  if (colspan > 1) {\n    return lastCell;\n  } // Normally, look for the cell in the same row that precedes the first cell to put selection there (\"column on the left\").\n  // If the deleted column is the first column of the table, there will be no predecessor: use the cell\n  // from the column that follows then (also in the same row).\n  else if (firstCell.previousSibling || lastCell.nextSibling) {\n    return lastCell.nextSibling || firstCell.previousSibling;\n  } // It can happen that table cells have no siblings in a row, for instance, when there are row spans\n  // in the table (in the previous row). Then just look for the closest cell that is in a column\n  // that will not be removed to put the selection there.\n  else {\n    // Look for any cell in a column that precedes the first removed column.\n    if (removedColumnIndexes.first) {\n      return tableMap.reverse().find(_ref => {\n        let {\n          column\n        } = _ref;\n        return column < removedColumnIndexes.first;\n      }).cell;\n    } // If the first removed column is the first column of the table, then\n    // look for any cell that is in a column that follows the last removed column.\n    else {\n      return tableMap.reverse().find(_ref2 => {\n        let {\n          column\n        } = _ref2;\n        return column > removedColumnIndexes.last;\n      }).cell;\n    }\n  }\n} // Returns helper object returning the first and the last cell contained in given selection, based on DOM order.\n\n\nfunction getBoundaryCells(selection) {\n  const referenceCells = getSelectionAffectedTableCells(selection);\n  const firstCell = referenceCells[0];\n  const lastCell = referenceCells.pop();\n  const returnValue = [firstCell, lastCell];\n  return firstCell.isBefore(lastCell) ? returnValue : returnValue.reverse();\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/commands/removecolumncommand.js"],"names":["Command","TableWalker","getColumnIndexes","getSelectionAffectedTableCells","RemoveColumnCommand","refresh","selectedCells","editor","model","document","selection","firstCell","table","findAncestor","tableColumnCount","plugins","get","getColumns","first","last","isEnabled","execute","lastCell","getBoundaryCells","parent","tableMap","removedColumnIndexes","find","value","cell","column","cellToFocus","getCellToFocus","change","writer","columnsToRemove","removeColumns","at","columns","setSelection","createPositionAt","colspan","parseInt","getAttribute","previousSibling","nextSibling","reverse","referenceCells","pop","returnValue","isBefore"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/removecolumncommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\n\nimport TableWalker from '../tablewalker';\nimport { getColumnIndexes, getSelectionAffectedTableCells } from '../utils/selection';\n\n/**\n * The remove column command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'removeTableColumn'` editor command.\n *\n * To remove the column containing the selected cell, execute the command:\n *\n *\t\teditor.execute( 'removeTableColumn' );\n *\n * @extends module:core/command~Command\n */\nexport default class RemoveColumnCommand extends Command {\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst selectedCells = getSelectionAffectedTableCells( this.editor.model.document.selection );\n\t\tconst firstCell = selectedCells[ 0 ];\n\n\t\tif ( firstCell ) {\n\t\t\tconst table = firstCell.findAncestor( 'table' );\n\t\t\tconst tableColumnCount = this.editor.plugins.get( 'TableUtils' ).getColumns( table );\n\n\t\t\tconst { first, last } = getColumnIndexes( selectedCells );\n\n\t\t\tthis.isEnabled = last - first < ( tableColumnCount - 1 );\n\t\t} else {\n\t\t\tthis.isEnabled = false;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\texecute() {\n\t\tconst [ firstCell, lastCell ] = getBoundaryCells( this.editor.model.document.selection );\n\t\tconst table = firstCell.parent.parent;\n\n\t\t// Cache the table before removing or updating colspans.\n\t\tconst tableMap = [ ...new TableWalker( table ) ];\n\n\t\t// Store column indexes of removed columns.\n\t\tconst removedColumnIndexes = {\n\t\t\tfirst: tableMap.find( value => value.cell === firstCell ).column,\n\t\t\tlast: tableMap.find( value => value.cell === lastCell ).column\n\t\t};\n\n\t\tconst cellToFocus = getCellToFocus( tableMap, firstCell, lastCell, removedColumnIndexes );\n\n\t\tthis.editor.model.change( writer => {\n\t\t\tconst columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;\n\n\t\t\tthis.editor.plugins.get( 'TableUtils' ).removeColumns( table, {\n\t\t\t\tat: removedColumnIndexes.first,\n\t\t\t\tcolumns: columnsToRemove\n\t\t\t} );\n\n\t\t\twriter.setSelection( writer.createPositionAt( cellToFocus, 0 ) );\n\t\t} );\n\t}\n}\n\n// Returns a proper table cell to focus after removing a column.\n// - selection is on last table cell it will return previous cell.\nfunction getCellToFocus( tableMap, firstCell, lastCell, removedColumnIndexes ) {\n\tconst colspan = parseInt( lastCell.getAttribute( 'colspan' ) || 1 );\n\n\t// If the table cell is spanned over 2+ columns - it will be truncated so the selection should\n\t// stay in that cell.\n\tif ( colspan > 1 ) {\n\t\treturn lastCell;\n\t}\n\t// Normally, look for the cell in the same row that precedes the first cell to put selection there (\"column on the left\").\n\t// If the deleted column is the first column of the table, there will be no predecessor: use the cell\n\t// from the column that follows then (also in the same row).\n\telse if ( firstCell.previousSibling || lastCell.nextSibling ) {\n\t\treturn lastCell.nextSibling || firstCell.previousSibling;\n\t}\n\t// It can happen that table cells have no siblings in a row, for instance, when there are row spans\n\t// in the table (in the previous row). Then just look for the closest cell that is in a column\n\t// that will not be removed to put the selection there.\n\telse {\n\t\t// Look for any cell in a column that precedes the first removed column.\n\t\tif ( removedColumnIndexes.first ) {\n\t\t\treturn tableMap.reverse().find( ( { column } ) => {\n\t\t\t\treturn column < removedColumnIndexes.first;\n\t\t\t} ).cell;\n\t\t}\n\t\t// If the first removed column is the first column of the table, then\n\t\t// look for any cell that is in a column that follows the last removed column.\n\t\telse {\n\t\t\treturn tableMap.reverse().find( ( { column } ) => {\n\t\t\t\treturn column > removedColumnIndexes.last;\n\t\t\t} ).cell;\n\t\t}\n\t}\n}\n\n// Returns helper object returning the first and the last cell contained in given selection, based on DOM order.\nfunction getBoundaryCells( selection ) {\n\tconst referenceCells = getSelectionAffectedTableCells( selection );\n\tconst firstCell = referenceCells[ 0 ];\n\tconst lastCell = referenceCells.pop();\n\n\tconst returnValue = [ firstCell, lastCell ];\n\n\treturn firstCell.isBefore( lastCell ) ? returnValue : returnValue.reverse();\n}\n"]},"metadata":{},"sourceType":"module"}
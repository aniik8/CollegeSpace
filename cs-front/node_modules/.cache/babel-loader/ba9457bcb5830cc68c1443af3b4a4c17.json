{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellscommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport TableUtils from '../tableutils';\nimport { getSelectedTableCells, isSelectionRectangular } from '../utils/selection';\nimport { updateNumericAttribute } from '../utils/common';\nimport { removeEmptyRowsColumns } from '../utils/structure';\n/**\n * The merge cells command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCells'` editor command.\n *\n * For example, to merge selected table cells:\n *\n *\t\teditor.execute( 'mergeTableCells' );\n *\n * @extends module:core/command~Command\n */\n\nexport default class MergeCellsCommand extends Command {\n  /**\n   * @inheritDoc\n   */\n  refresh() {\n    const selectedTableCells = getSelectedTableCells(this.editor.model.document.selection);\n    this.isEnabled = isSelectionRectangular(selectedTableCells, this.editor.plugins.get(TableUtils));\n  }\n  /**\n   * Executes the command.\n   *\n   * @fires execute\n   */\n\n\n  execute() {\n    const model = this.editor.model;\n    const tableUtils = this.editor.plugins.get(TableUtils);\n    model.change(writer => {\n      const selectedTableCells = getSelectedTableCells(model.document.selection); // All cells will be merged into the first one.\n\n      const firstTableCell = selectedTableCells.shift(); // Update target cell dimensions.\n\n      const {\n        mergeWidth,\n        mergeHeight\n      } = getMergeDimensions(firstTableCell, selectedTableCells, tableUtils);\n      updateNumericAttribute('colspan', mergeWidth, firstTableCell, writer);\n      updateNumericAttribute('rowspan', mergeHeight, firstTableCell, writer);\n\n      for (const tableCell of selectedTableCells) {\n        mergeTableCells(tableCell, firstTableCell, writer);\n      }\n\n      const table = firstTableCell.findAncestor('table'); // Remove rows and columns that become empty (have no anchored cells).\n\n      removeEmptyRowsColumns(table, tableUtils);\n      writer.setSelection(firstTableCell, 'in');\n    });\n  }\n\n} // Merges two table cells. It will ensure that after merging cells with empty paragraphs the resulting table cell will only have one\n// paragraph. If one of the merged table cells is empty, the merged table cell will have contents of the non-empty table cell.\n// If both are empty, the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellBeingMerged\n// @param {module:engine/model/element~Element} targetCell\n// @param {module:engine/model/writer~Writer} writer\n\nfunction mergeTableCells(cellBeingMerged, targetCell, writer) {\n  if (!isEmpty(cellBeingMerged)) {\n    if (isEmpty(targetCell)) {\n      writer.remove(writer.createRangeIn(targetCell));\n    }\n\n    writer.move(writer.createRangeIn(cellBeingMerged), writer.createPositionAt(targetCell, 'end'));\n  } // Remove merged table cell.\n\n\n  writer.remove(cellBeingMerged);\n} // Checks if the passed table cell contains an empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\n\n\nfunction isEmpty(tableCell) {\n  return tableCell.childCount == 1 && tableCell.getChild(0).is('element', 'paragraph') && tableCell.getChild(0).isEmpty;\n}\n\nfunction getMergeDimensions(firstTableCell, selectedTableCells, tableUtils) {\n  let maxWidthOffset = 0;\n  let maxHeightOffset = 0;\n\n  for (const tableCell of selectedTableCells) {\n    const {\n      row,\n      column\n    } = tableUtils.getCellLocation(tableCell);\n    maxWidthOffset = getMaxOffset(tableCell, column, maxWidthOffset, 'colspan');\n    maxHeightOffset = getMaxOffset(tableCell, row, maxHeightOffset, 'rowspan');\n  } // Update table cell span attribute and merge set selection on a merged contents.\n\n\n  const {\n    row: firstCellRow,\n    column: firstCellColumn\n  } = tableUtils.getCellLocation(firstTableCell);\n  const mergeWidth = maxWidthOffset - firstCellColumn;\n  const mergeHeight = maxHeightOffset - firstCellRow;\n  return {\n    mergeWidth,\n    mergeHeight\n  };\n}\n\nfunction getMaxOffset(tableCell, start, currentMaxOffset, which) {\n  const dimensionValue = parseInt(tableCell.getAttribute(which) || 1);\n  return Math.max(currentMaxOffset, start + dimensionValue);\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellscommand.js"],"names":["Command","TableUtils","getSelectedTableCells","isSelectionRectangular","updateNumericAttribute","removeEmptyRowsColumns","MergeCellsCommand","refresh","selectedTableCells","editor","model","document","selection","isEnabled","plugins","get","execute","tableUtils","change","writer","firstTableCell","shift","mergeWidth","mergeHeight","getMergeDimensions","tableCell","mergeTableCells","table","findAncestor","setSelection","cellBeingMerged","targetCell","isEmpty","remove","createRangeIn","move","createPositionAt","childCount","getChild","is","maxWidthOffset","maxHeightOffset","row","column","getCellLocation","getMaxOffset","firstCellRow","firstCellColumn","start","currentMaxOffset","which","dimensionValue","parseInt","getAttribute","Math","max"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellscommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\nimport TableUtils from '../tableutils';\nimport { getSelectedTableCells, isSelectionRectangular } from '../utils/selection';\nimport { updateNumericAttribute } from '../utils/common';\nimport { removeEmptyRowsColumns } from '../utils/structure';\n\n/**\n * The merge cells command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCells'` editor command.\n *\n * For example, to merge selected table cells:\n *\n *\t\teditor.execute( 'mergeTableCells' );\n *\n * @extends module:core/command~Command\n */\nexport default class MergeCellsCommand extends Command {\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst selectedTableCells = getSelectedTableCells( this.editor.model.document.selection );\n\t\tthis.isEnabled = isSelectionRectangular( selectedTableCells, this.editor.plugins.get( TableUtils ) );\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * @fires execute\n\t */\n\texecute() {\n\t\tconst model = this.editor.model;\n\t\tconst tableUtils = this.editor.plugins.get( TableUtils );\n\n\t\tmodel.change( writer => {\n\t\t\tconst selectedTableCells = getSelectedTableCells( model.document.selection );\n\n\t\t\t// All cells will be merged into the first one.\n\t\t\tconst firstTableCell = selectedTableCells.shift();\n\n\t\t\t// Update target cell dimensions.\n\t\t\tconst { mergeWidth, mergeHeight } = getMergeDimensions( firstTableCell, selectedTableCells, tableUtils );\n\t\t\tupdateNumericAttribute( 'colspan', mergeWidth, firstTableCell, writer );\n\t\t\tupdateNumericAttribute( 'rowspan', mergeHeight, firstTableCell, writer );\n\n\t\t\tfor ( const tableCell of selectedTableCells ) {\n\t\t\t\tmergeTableCells( tableCell, firstTableCell, writer );\n\t\t\t}\n\n\t\t\tconst table = firstTableCell.findAncestor( 'table' );\n\n\t\t\t// Remove rows and columns that become empty (have no anchored cells).\n\t\t\tremoveEmptyRowsColumns( table, tableUtils );\n\n\t\t\twriter.setSelection( firstTableCell, 'in' );\n\t\t} );\n\t}\n}\n\n// Merges two table cells. It will ensure that after merging cells with empty paragraphs the resulting table cell will only have one\n// paragraph. If one of the merged table cells is empty, the merged table cell will have contents of the non-empty table cell.\n// If both are empty, the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellBeingMerged\n// @param {module:engine/model/element~Element} targetCell\n// @param {module:engine/model/writer~Writer} writer\nfunction mergeTableCells( cellBeingMerged, targetCell, writer ) {\n\tif ( !isEmpty( cellBeingMerged ) ) {\n\t\tif ( isEmpty( targetCell ) ) {\n\t\t\twriter.remove( writer.createRangeIn( targetCell ) );\n\t\t}\n\n\t\twriter.move( writer.createRangeIn( cellBeingMerged ), writer.createPositionAt( targetCell, 'end' ) );\n\t}\n\n\t// Remove merged table cell.\n\twriter.remove( cellBeingMerged );\n}\n\n// Checks if the passed table cell contains an empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\nfunction isEmpty( tableCell ) {\n\treturn tableCell.childCount == 1 && tableCell.getChild( 0 ).is( 'element', 'paragraph' ) && tableCell.getChild( 0 ).isEmpty;\n}\n\nfunction getMergeDimensions( firstTableCell, selectedTableCells, tableUtils ) {\n\tlet maxWidthOffset = 0;\n\tlet maxHeightOffset = 0;\n\n\tfor ( const tableCell of selectedTableCells ) {\n\t\tconst { row, column } = tableUtils.getCellLocation( tableCell );\n\n\t\tmaxWidthOffset = getMaxOffset( tableCell, column, maxWidthOffset, 'colspan' );\n\t\tmaxHeightOffset = getMaxOffset( tableCell, row, maxHeightOffset, 'rowspan' );\n\t}\n\n\t// Update table cell span attribute and merge set selection on a merged contents.\n\tconst { row: firstCellRow, column: firstCellColumn } = tableUtils.getCellLocation( firstTableCell );\n\n\tconst mergeWidth = maxWidthOffset - firstCellColumn;\n\tconst mergeHeight = maxHeightOffset - firstCellRow;\n\n\treturn { mergeWidth, mergeHeight };\n}\n\nfunction getMaxOffset( tableCell, start, currentMaxOffset, which ) {\n\tconst dimensionValue = parseInt( tableCell.getAttribute( which ) || 1 );\n\n\treturn Math.max( currentMaxOffset, start + dimensionValue );\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellcommand\n */\nimport { Command } from 'ckeditor5/src/core';\nimport TableWalker from '../tablewalker';\nimport { getTableCellsContainingSelection } from '../utils/selection';\nimport { isHeadingColumnCell } from '../utils/common';\nimport { removeEmptyRowsColumns } from '../utils/structure';\n/**\n * The merge cell command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCellRight'`, `'mergeTableCellLeft'`,\n * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.\n *\n * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.\n *\n * For example, to merge with a cell to the right:\n *\n *\t\teditor.execute( 'mergeTableCellRight' );\n *\n * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)\n * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)\n * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.\n *\n * @extends module:core/command~Command\n */\n\nexport default class MergeCellCommand extends Command {\n  /**\n   * Creates a new `MergeCellCommand` instance.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n   * @param {Object} options\n   * @param {String} options.direction Indicates which cell to merge with the currently selected one.\n   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.\n   */\n  constructor(editor, options) {\n    super(editor);\n    /**\n     * The direction that indicates which cell will be merged with the currently selected one.\n     *\n     * @readonly\n     * @member {String} #direction\n     */\n\n    this.direction = options.direction;\n    /**\n     * Whether the merge is horizontal (left/right) or vertical (up/down).\n     *\n     * @readonly\n     * @member {Boolean} #isHorizontal\n     */\n\n    this.isHorizontal = this.direction == 'right' || this.direction == 'left';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    const cellToMerge = this._getMergeableCell();\n\n    this.value = cellToMerge;\n    this.isEnabled = !!cellToMerge;\n  }\n  /**\n   * Executes the command.\n   *\n   * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.\n   *\n   * @fires execute\n   */\n\n\n  execute() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const tableCell = getTableCellsContainingSelection(doc.selection)[0];\n    const cellToMerge = this.value;\n    const direction = this.direction;\n    model.change(writer => {\n      const isMergeNext = direction == 'right' || direction == 'down'; // The merge mechanism is always the same so sort cells to be merged.\n\n      const cellToExpand = isMergeNext ? tableCell : cellToMerge;\n      const cellToRemove = isMergeNext ? cellToMerge : tableCell; // Cache the parent of cell to remove for later check.\n\n      const removedTableCellRow = cellToRemove.parent;\n      mergeTableCells(cellToRemove, cellToExpand, writer);\n      const spanAttribute = this.isHorizontal ? 'colspan' : 'rowspan';\n      const cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n      const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1); // Update table cell span attribute and merge set selection on merged contents.\n\n      writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);\n      writer.setSelection(writer.createRangeIn(cellToExpand));\n      const tableUtils = this.editor.plugins.get('TableUtils');\n      const table = removedTableCellRow.findAncestor('table'); // Remove empty rows and columns after merging.\n\n      removeEmptyRowsColumns(table, tableUtils);\n    });\n  }\n  /**\n   * Returns a cell that can be merged with the current cell depending on the command's direction.\n   *\n   * @returns {module:engine/model/element~Element|undefined}\n   * @private\n   */\n\n\n  _getMergeableCell() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const tableCell = getTableCellsContainingSelection(doc.selection)[0];\n\n    if (!tableCell) {\n      return;\n    }\n\n    const tableUtils = this.editor.plugins.get('TableUtils'); // First get the cell on proper direction.\n\n    const cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction, tableUtils);\n\n    if (!cellToMerge) {\n      return;\n    } // If found check if the span perpendicular to merge direction is equal on both cells.\n\n\n    const spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';\n    const span = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n    const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1);\n\n    if (cellToMergeSpan === span) {\n      return cellToMerge;\n    }\n  }\n\n} // Returns the cell that can be merged horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {module:engine/model/node~Node|null}\n\nfunction getHorizontalCell(tableCell, direction, tableUtils) {\n  const tableRow = tableCell.parent;\n  const table = tableRow.parent;\n  const horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;\n  const hasHeadingColumns = (table.getAttribute('headingColumns') || 0) > 0;\n\n  if (!horizontalCell) {\n    return;\n  } // Sort cells:\n\n\n  const cellOnLeft = direction == 'right' ? tableCell : horizontalCell;\n  const cellOnRight = direction == 'right' ? horizontalCell : tableCell; // Get their column indexes:\n\n  const {\n    column: leftCellColumn\n  } = tableUtils.getCellLocation(cellOnLeft);\n  const {\n    column: rightCellColumn\n  } = tableUtils.getCellLocation(cellOnRight);\n  const leftCellSpan = parseInt(cellOnLeft.getAttribute('colspan') || 1);\n  const isCellOnLeftInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnLeft, table);\n  const isCellOnRightInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnRight, table); // We cannot merge heading columns cells with regular cells.\n\n  if (hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn) {\n    return;\n  } // The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).\n\n\n  const cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn; // If the right cell's column index is different it means that there are rowspanned cells between them.\n\n  return cellsAreTouching ? horizontalCell : undefined;\n} // Returns the cell that can be merged vertically.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {module:engine/model/node~Node|null}\n\n\nfunction getVerticalCell(tableCell, direction, tableUtils) {\n  const tableRow = tableCell.parent;\n  const table = tableRow.parent;\n  const rowIndex = table.getChildIndex(tableRow); // Don't search for mergeable cell if direction points out of the table.\n\n  if (direction == 'down' && rowIndex === tableUtils.getRows(table) - 1 || direction == 'up' && rowIndex === 0) {\n    return;\n  }\n\n  const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  const headingRows = table.getAttribute('headingRows') || 0;\n  const isMergeWithBodyCell = direction == 'down' && rowIndex + rowspan === headingRows;\n  const isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows; // Don't search for mergeable cell if direction points out of the current table section.\n\n  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {\n    return;\n  }\n\n  const currentCellRowSpan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  const rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;\n  const tableMap = [...new TableWalker(table, {\n    endRow: rowOfCellToMerge\n  })];\n  const currentCellData = tableMap.find(value => value.cell === tableCell);\n  const mergeColumn = currentCellData.column;\n  const cellToMergeData = tableMap.find(_ref => {\n    let {\n      row,\n      cellHeight,\n      column\n    } = _ref;\n\n    if (column !== mergeColumn) {\n      return false;\n    }\n\n    if (direction == 'down') {\n      // If merging a cell below the mergeRow is already calculated.\n      return row === rowOfCellToMerge;\n    } else {\n      // If merging a cell above calculate if it spans to mergeRow.\n      return rowOfCellToMerge === row + cellHeight;\n    }\n  });\n  return cellToMergeData && cellToMergeData.cell;\n} // Merges two table cells. It will ensure that after merging cells with an empty paragraph, the resulting table cell will only have one\n// paragraph. If one of the merged table cells is empty, the merged table cell will have the contents of the non-empty table cell.\n// If both are empty, the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellToRemove\n// @param {module:engine/model/element~Element} cellToExpand\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction mergeTableCells(cellToRemove, cellToExpand, writer) {\n  if (!isEmpty(cellToRemove)) {\n    if (isEmpty(cellToExpand)) {\n      writer.remove(writer.createRangeIn(cellToExpand));\n    }\n\n    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, 'end'));\n  } // Remove merged table cell.\n\n\n  writer.remove(cellToRemove);\n} // Checks if the passed table cell contains an empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\n\n\nfunction isEmpty(tableCell) {\n  return tableCell.childCount == 1 && tableCell.getChild(0).is('element', 'paragraph') && tableCell.getChild(0).isEmpty;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js"],"names":["Command","TableWalker","getTableCellsContainingSelection","isHeadingColumnCell","removeEmptyRowsColumns","MergeCellCommand","constructor","editor","options","direction","isHorizontal","refresh","cellToMerge","_getMergeableCell","value","isEnabled","execute","model","doc","document","tableCell","selection","change","writer","isMergeNext","cellToExpand","cellToRemove","removedTableCellRow","parent","mergeTableCells","spanAttribute","cellSpan","parseInt","getAttribute","cellToMergeSpan","setAttribute","setSelection","createRangeIn","tableUtils","plugins","get","table","findAncestor","getHorizontalCell","getVerticalCell","span","tableRow","horizontalCell","nextSibling","previousSibling","hasHeadingColumns","cellOnLeft","cellOnRight","column","leftCellColumn","getCellLocation","rightCellColumn","leftCellSpan","isCellOnLeftInHeadingColumn","isCellOnRightInHeadingColumn","cellsAreTouching","undefined","rowIndex","getChildIndex","getRows","rowspan","headingRows","isMergeWithBodyCell","isMergeWithHeadCell","currentCellRowSpan","rowOfCellToMerge","tableMap","endRow","currentCellData","find","cell","mergeColumn","cellToMergeData","row","cellHeight","isEmpty","remove","move","createPositionAt","childCount","getChild","is"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellcommand\n */\n\nimport { Command } from 'ckeditor5/src/core';\nimport TableWalker from '../tablewalker';\nimport { getTableCellsContainingSelection } from '../utils/selection';\nimport { isHeadingColumnCell } from '../utils/common';\nimport { removeEmptyRowsColumns } from '../utils/structure';\n\n/**\n * The merge cell command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCellRight'`, `'mergeTableCellLeft'`,\n * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.\n *\n * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.\n *\n * For example, to merge with a cell to the right:\n *\n *\t\teditor.execute( 'mergeTableCellRight' );\n *\n * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)\n * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)\n * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.\n *\n * @extends module:core/command~Command\n */\nexport default class MergeCellCommand extends Command {\n\t/**\n\t * Creates a new `MergeCellCommand` instance.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n\t * @param {Object} options\n\t * @param {String} options.direction Indicates which cell to merge with the currently selected one.\n\t * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.\n\t */\n\tconstructor( editor, options ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The direction that indicates which cell will be merged with the currently selected one.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} #direction\n\t\t */\n\t\tthis.direction = options.direction;\n\n\t\t/**\n\t\t * Whether the merge is horizontal (left/right) or vertical (up/down).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isHorizontal\n\t\t */\n\t\tthis.isHorizontal = this.direction == 'right' || this.direction == 'left';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst cellToMerge = this._getMergeableCell();\n\n\t\tthis.value = cellToMerge;\n\t\tthis.isEnabled = !!cellToMerge;\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.\n\t *\n\t * @fires execute\n\t */\n\texecute() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst tableCell = getTableCellsContainingSelection( doc.selection )[ 0 ];\n\n\t\tconst cellToMerge = this.value;\n\t\tconst direction = this.direction;\n\n\t\tmodel.change( writer => {\n\t\t\tconst isMergeNext = direction == 'right' || direction == 'down';\n\n\t\t\t// The merge mechanism is always the same so sort cells to be merged.\n\t\t\tconst cellToExpand = isMergeNext ? tableCell : cellToMerge;\n\t\t\tconst cellToRemove = isMergeNext ? cellToMerge : tableCell;\n\n\t\t\t// Cache the parent of cell to remove for later check.\n\t\t\tconst removedTableCellRow = cellToRemove.parent;\n\n\t\t\tmergeTableCells( cellToRemove, cellToExpand, writer );\n\n\t\t\tconst spanAttribute = this.isHorizontal ? 'colspan' : 'rowspan';\n\t\t\tconst cellSpan = parseInt( tableCell.getAttribute( spanAttribute ) || 1 );\n\t\t\tconst cellToMergeSpan = parseInt( cellToMerge.getAttribute( spanAttribute ) || 1 );\n\n\t\t\t// Update table cell span attribute and merge set selection on merged contents.\n\t\t\twriter.setAttribute( spanAttribute, cellSpan + cellToMergeSpan, cellToExpand );\n\t\t\twriter.setSelection( writer.createRangeIn( cellToExpand ) );\n\n\t\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\t\t\tconst table = removedTableCellRow.findAncestor( 'table' );\n\n\t\t\t// Remove empty rows and columns after merging.\n\t\t\tremoveEmptyRowsColumns( table, tableUtils );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns a cell that can be merged with the current cell depending on the command's direction.\n\t *\n\t * @returns {module:engine/model/element~Element|undefined}\n\t * @private\n\t */\n\t_getMergeableCell() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst tableCell = getTableCellsContainingSelection( doc.selection )[ 0 ];\n\n\t\tif ( !tableCell ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\n\t\t// First get the cell on proper direction.\n\t\tconst cellToMerge = this.isHorizontal ?\n\t\t\tgetHorizontalCell( tableCell, this.direction, tableUtils ) :\n\t\t\tgetVerticalCell( tableCell, this.direction, tableUtils );\n\n\t\tif ( !cellToMerge ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If found check if the span perpendicular to merge direction is equal on both cells.\n\t\tconst spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';\n\t\tconst span = parseInt( tableCell.getAttribute( spanAttribute ) || 1 );\n\n\t\tconst cellToMergeSpan = parseInt( cellToMerge.getAttribute( spanAttribute ) || 1 );\n\n\t\tif ( cellToMergeSpan === span ) {\n\t\t\treturn cellToMerge;\n\t\t}\n\t}\n}\n\n// Returns the cell that can be merged horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {module:engine/model/node~Node|null}\nfunction getHorizontalCell( tableCell, direction, tableUtils ) {\n\tconst tableRow = tableCell.parent;\n\tconst table = tableRow.parent;\n\tconst horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;\n\tconst hasHeadingColumns = ( table.getAttribute( 'headingColumns' ) || 0 ) > 0;\n\n\tif ( !horizontalCell ) {\n\t\treturn;\n\t}\n\n\t// Sort cells:\n\tconst cellOnLeft = direction == 'right' ? tableCell : horizontalCell;\n\tconst cellOnRight = direction == 'right' ? horizontalCell : tableCell;\n\n\t// Get their column indexes:\n\tconst { column: leftCellColumn } = tableUtils.getCellLocation( cellOnLeft );\n\tconst { column: rightCellColumn } = tableUtils.getCellLocation( cellOnRight );\n\n\tconst leftCellSpan = parseInt( cellOnLeft.getAttribute( 'colspan' ) || 1 );\n\n\tconst isCellOnLeftInHeadingColumn = isHeadingColumnCell( tableUtils, cellOnLeft, table );\n\tconst isCellOnRightInHeadingColumn = isHeadingColumnCell( tableUtils, cellOnRight, table );\n\n\t// We cannot merge heading columns cells with regular cells.\n\tif ( hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn ) {\n\t\treturn;\n\t}\n\n\t// The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).\n\tconst cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn;\n\n\t// If the right cell's column index is different it means that there are rowspanned cells between them.\n\treturn cellsAreTouching ? horizontalCell : undefined;\n}\n\n// Returns the cell that can be merged vertically.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @param {module:table/tableutils~TableUtils} tableUtils\n// @returns {module:engine/model/node~Node|null}\nfunction getVerticalCell( tableCell, direction, tableUtils ) {\n\tconst tableRow = tableCell.parent;\n\tconst table = tableRow.parent;\n\n\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t// Don't search for mergeable cell if direction points out of the table.\n\tif ( ( direction == 'down' && rowIndex === tableUtils.getRows( table ) - 1 ) || ( direction == 'up' && rowIndex === 0 ) ) {\n\t\treturn;\n\t}\n\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\tconst isMergeWithBodyCell = direction == 'down' && ( rowIndex + rowspan ) === headingRows;\n\tconst isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows;\n\n\t// Don't search for mergeable cell if direction points out of the current table section.\n\tif ( headingRows && ( isMergeWithBodyCell || isMergeWithHeadCell ) ) {\n\t\treturn;\n\t}\n\n\tconst currentCellRowSpan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\tconst rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;\n\n\tconst tableMap = [ ...new TableWalker( table, { endRow: rowOfCellToMerge } ) ];\n\n\tconst currentCellData = tableMap.find( value => value.cell === tableCell );\n\tconst mergeColumn = currentCellData.column;\n\n\tconst cellToMergeData = tableMap.find( ( { row, cellHeight, column } ) => {\n\t\tif ( column !== mergeColumn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( direction == 'down' ) {\n\t\t\t// If merging a cell below the mergeRow is already calculated.\n\t\t\treturn row === rowOfCellToMerge;\n\t\t} else {\n\t\t\t// If merging a cell above calculate if it spans to mergeRow.\n\t\t\treturn rowOfCellToMerge === row + cellHeight;\n\t\t}\n\t} );\n\n\treturn cellToMergeData && cellToMergeData.cell;\n}\n\n// Merges two table cells. It will ensure that after merging cells with an empty paragraph, the resulting table cell will only have one\n// paragraph. If one of the merged table cells is empty, the merged table cell will have the contents of the non-empty table cell.\n// If both are empty, the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellToRemove\n// @param {module:engine/model/element~Element} cellToExpand\n// @param {module:engine/model/writer~Writer} writer\nfunction mergeTableCells( cellToRemove, cellToExpand, writer ) {\n\tif ( !isEmpty( cellToRemove ) ) {\n\t\tif ( isEmpty( cellToExpand ) ) {\n\t\t\twriter.remove( writer.createRangeIn( cellToExpand ) );\n\t\t}\n\n\t\twriter.move( writer.createRangeIn( cellToRemove ), writer.createPositionAt( cellToExpand, 'end' ) );\n\t}\n\n\t// Remove merged table cell.\n\twriter.remove( cellToRemove );\n}\n\n// Checks if the passed table cell contains an empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\nfunction isEmpty( tableCell ) {\n\treturn tableCell.childCount == 1 && tableCell.getChild( 0 ).is( 'element', 'paragraph' ) && tableCell.getChild( 0 ).isEmpty;\n}\n"]},"metadata":{},"sourceType":"module"}
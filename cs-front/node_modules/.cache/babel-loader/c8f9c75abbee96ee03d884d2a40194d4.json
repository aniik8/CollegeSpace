{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablekeyboard\n */\nimport TableSelection from './tableselection';\nimport TableWalker from './tablewalker';\nimport { Plugin } from 'ckeditor5/src/core';\nimport { getLocalizedArrowKeyCodeDirection } from 'ckeditor5/src/utils';\nimport { getSelectedTableCells, getTableCellsContainingSelection } from './utils/selection';\n/**\n * This plugin enables keyboard navigation for tables.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableKeyboard extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableKeyboard';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  static get requires() {\n    return [TableSelection];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    var _this = this;\n\n    const view = this.editor.editing.view;\n    const viewDocument = view.document; // Handle Tab key navigation.\n\n    this.editor.keystrokes.set('Tab', function () {\n      return _this._handleTabOnSelectedTable(...arguments);\n    }, {\n      priority: 'low'\n    });\n    this.editor.keystrokes.set('Tab', this._getTabHandler(true), {\n      priority: 'low'\n    });\n    this.editor.keystrokes.set('Shift+Tab', this._getTabHandler(false), {\n      priority: 'low'\n    });\n    this.listenTo(viewDocument, 'arrowKey', function () {\n      return _this._onArrowKey(...arguments);\n    }, {\n      context: 'table'\n    });\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n   * when the table widget is selected.\n   *\n   * @private\n   * @param {module:engine/view/observer/keyobserver~KeyEventData} data Key event data.\n   * @param {Function} cancel The stop/stopPropagation/preventDefault function.\n   */\n\n\n  _handleTabOnSelectedTable(data, cancel) {\n    const editor = this.editor;\n    const selection = editor.model.document.selection;\n    const selectedElement = selection.getSelectedElement();\n\n    if (!selectedElement || !selectedElement.is('element', 'table')) {\n      return;\n    }\n\n    cancel();\n    editor.model.change(writer => {\n      writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));\n    });\n  }\n  /**\n   * Returns a handler for {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n   * inside table cells.\n   *\n   * @private\n   * @param {Boolean} isForward Whether this handler will move the selection to the next or the previous cell.\n   */\n\n\n  _getTabHandler(isForward) {\n    const editor = this.editor;\n    return (domEventData, cancel) => {\n      const selection = editor.model.document.selection;\n      let tableCell = getTableCellsContainingSelection(selection)[0];\n\n      if (!tableCell) {\n        tableCell = this.editor.plugins.get('TableSelection').getFocusCell();\n      }\n\n      if (!tableCell) {\n        return;\n      }\n\n      cancel();\n      const tableRow = tableCell.parent;\n      const table = tableRow.parent;\n      const currentRowIndex = table.getChildIndex(tableRow);\n      const currentCellIndex = tableRow.getChildIndex(tableCell);\n      const isFirstCellInRow = currentCellIndex === 0;\n\n      if (!isForward && isFirstCellInRow && currentRowIndex === 0) {\n        // Set the selection over the whole table if the selection was in the first table cell.\n        editor.model.change(writer => {\n          writer.setSelection(writer.createRangeOn(table));\n        });\n        return;\n      }\n\n      const tableUtils = this.editor.plugins.get('TableUtils');\n      const isLastCellInRow = currentCellIndex === tableRow.childCount - 1;\n      const isLastRow = currentRowIndex === tableUtils.getRows(table) - 1;\n\n      if (isForward && isLastRow && isLastCellInRow) {\n        editor.execute('insertTableRowBelow'); // Check if the command actually added a row. If `insertTableRowBelow` execution didn't add a row (because it was disabled\n        // or it got overwritten) set the selection over the whole table to mirror the first cell case.\n\n        if (currentRowIndex === tableUtils.getRows(table) - 1) {\n          editor.model.change(writer => {\n            writer.setSelection(writer.createRangeOn(table));\n          });\n          return;\n        }\n      }\n\n      let cellToFocus; // Move to the first cell in the next row.\n\n      if (isForward && isLastCellInRow) {\n        const nextRow = table.getChild(currentRowIndex + 1);\n        cellToFocus = nextRow.getChild(0);\n      } // Move to the last cell in the previous row.\n      else if (!isForward && isFirstCellInRow) {\n        const previousRow = table.getChild(currentRowIndex - 1);\n        cellToFocus = previousRow.getChild(previousRow.childCount - 1);\n      } // Move to the next/previous cell.\n      else {\n        cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));\n      }\n\n      editor.model.change(writer => {\n        writer.setSelection(writer.createRangeIn(cellToFocus));\n      });\n    };\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _onArrowKey(eventInfo, domEventData) {\n    const editor = this.editor;\n    const keyCode = domEventData.keyCode;\n    const direction = getLocalizedArrowKeyCodeDirection(keyCode, editor.locale.contentLanguageDirection);\n\n    const wasHandled = this._handleArrowKeys(direction, domEventData.shiftKey);\n\n    if (wasHandled) {\n      domEventData.preventDefault();\n      domEventData.stopPropagation();\n      eventInfo.stop();\n    }\n  }\n  /**\n   * Handles arrow keys to move the selection around the table.\n   *\n   * @private\n   * @param {'left'|'up'|'right'|'down'} direction The direction of the arrow key.\n   * @param {Boolean} expandSelection If the current selection should be expanded.\n   * @returns {Boolean} Returns `true` if key was handled.\n   */\n\n\n  _handleArrowKeys(direction, expandSelection) {\n    const model = this.editor.model;\n    const selection = model.document.selection;\n    const isForward = ['right', 'down'].includes(direction); // In case one or more table cells are selected (from outside),\n    // move the selection to a cell adjacent to the selected table fragment.\n\n    const selectedCells = getSelectedTableCells(selection);\n\n    if (selectedCells.length) {\n      let focusCell;\n\n      if (expandSelection) {\n        focusCell = this.editor.plugins.get('TableSelection').getFocusCell();\n      } else {\n        focusCell = isForward ? selectedCells[selectedCells.length - 1] : selectedCells[0];\n      }\n\n      this._navigateFromCellInDirection(focusCell, direction, expandSelection);\n\n      return true;\n    } // Abort if we're not in a table cell.\n\n\n    const tableCell = selection.focus.findAncestor('tableCell');\n    /* istanbul ignore if: paranoid check */\n\n    if (!tableCell) {\n      return false;\n    } // When the selection is not collapsed.\n\n\n    if (!selection.isCollapsed) {\n      if (expandSelection) {\n        // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n        // Selection for sure will not approach cell edge.\n        //\n        // With a special case when all cell content is selected - then selection should expand to the other cell.\n        // Note: When the entire cell gets selected using CTRL+A, the selection is always forward.\n        if (selection.isBackward == isForward && !selection.containsEntireContent(tableCell)) {\n          return false;\n        }\n      } else {\n        const selectedElement = selection.getSelectedElement(); // It will collapse for non-object selected so it's not going to move to other cell.\n\n        if (!selectedElement || !model.schema.isObject(selectedElement)) {\n          return false;\n        }\n      }\n    } // Let's check if the selection is at the beginning/end of the cell.\n\n\n    if (this._isSelectionAtCellEdge(selection, tableCell, isForward)) {\n      this._navigateFromCellInDirection(tableCell, direction, expandSelection);\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.\n   *\n   * @private\n   * @param {module:engine/model/selection~Selection} selection The current selection.\n   * @param {module:engine/model/element~Element} tableCell The current table cell element.\n   * @param {Boolean} isForward The expected navigation direction.\n   * @returns {Boolean}\n   */\n\n\n  _isSelectionAtCellEdge(selection, tableCell, isForward) {\n    const model = this.editor.model;\n    const schema = this.editor.model.schema;\n    const focus = isForward ? selection.getLastPosition() : selection.getFirstPosition(); // If the current limit element is not table cell we are for sure not at the cell edge.\n    // Also `modifySelection` will not let us out of it.\n\n    if (!schema.getLimitElement(focus).is('element', 'tableCell')) {\n      const boundaryPosition = model.createPositionAt(tableCell, isForward ? 'end' : 0);\n      return boundaryPosition.isTouching(focus);\n    }\n\n    const probe = model.createSelection(focus);\n    model.modifySelection(probe, {\n      direction: isForward ? 'forward' : 'backward'\n    }); // If there was no change in the focus position, then it's not possible to move the selection there.\n\n    return focus.isEqual(probe.focus);\n  }\n  /**\n   * Moves the selection from the given table cell in the specified direction.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} focusCell The table cell that is current multi-cell selection focus.\n   * @param {'left'|'up'|'right'|'down'} direction Direction in which selection should move.\n   * @param {Boolean} [expandSelection=false] If the current selection should be expanded.\n   */\n\n\n  _navigateFromCellInDirection(focusCell, direction) {\n    let expandSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const model = this.editor.model;\n    const table = focusCell.findAncestor('table');\n    const tableMap = [...new TableWalker(table, {\n      includeAllSlots: true\n    })];\n    const {\n      row: lastRow,\n      column: lastColumn\n    } = tableMap[tableMap.length - 1];\n    const currentCellInfo = tableMap.find(_ref => {\n      let {\n        cell\n      } = _ref;\n      return cell == focusCell;\n    });\n    let {\n      row,\n      column\n    } = currentCellInfo;\n\n    switch (direction) {\n      case 'left':\n        column--;\n        break;\n\n      case 'up':\n        row--;\n        break;\n\n      case 'right':\n        column += currentCellInfo.cellWidth;\n        break;\n\n      case 'down':\n        row += currentCellInfo.cellHeight;\n        break;\n    }\n\n    const isOutsideVertically = row < 0 || row > lastRow;\n    const isBeforeFirstCell = column < 0 && row <= 0;\n    const isAfterLastCell = column > lastColumn && row >= lastRow; // Note that if the table cell at the end of a row is row-spanned then isAfterLastCell will never be true.\n    // However, we don't know if user was navigating on the last row or not, so let's stay in the table.\n\n    if (isOutsideVertically || isBeforeFirstCell || isAfterLastCell) {\n      model.change(writer => {\n        writer.setSelection(writer.createRangeOn(table));\n      });\n      return;\n    }\n\n    if (column < 0) {\n      column = expandSelection ? 0 : lastColumn;\n      row--;\n    } else if (column > lastColumn) {\n      column = expandSelection ? lastColumn : 0;\n      row++;\n    }\n\n    const cellToSelect = tableMap.find(cellInfo => cellInfo.row == row && cellInfo.column == column).cell;\n    const isForward = ['right', 'down'].includes(direction);\n    const tableSelection = this.editor.plugins.get('TableSelection');\n\n    if (expandSelection && tableSelection.isEnabled) {\n      const anchorCell = tableSelection.getAnchorCell() || focusCell;\n      tableSelection.setCellSelection(anchorCell, cellToSelect);\n    } else {\n      const positionToSelect = model.createPositionAt(cellToSelect, isForward ? 0 : 'end');\n      model.change(writer => {\n        writer.setSelection(positionToSelect);\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/tablekeyboard.js"],"names":["TableSelection","TableWalker","Plugin","getLocalizedArrowKeyCodeDirection","getSelectedTableCells","getTableCellsContainingSelection","TableKeyboard","pluginName","requires","init","view","editor","editing","viewDocument","document","keystrokes","set","_handleTabOnSelectedTable","priority","_getTabHandler","listenTo","_onArrowKey","context","data","cancel","selection","model","selectedElement","getSelectedElement","is","change","writer","setSelection","createRangeIn","getChild","isForward","domEventData","tableCell","plugins","get","getFocusCell","tableRow","parent","table","currentRowIndex","getChildIndex","currentCellIndex","isFirstCellInRow","createRangeOn","tableUtils","isLastCellInRow","childCount","isLastRow","getRows","execute","cellToFocus","nextRow","previousRow","eventInfo","keyCode","direction","locale","contentLanguageDirection","wasHandled","_handleArrowKeys","shiftKey","preventDefault","stopPropagation","stop","expandSelection","includes","selectedCells","length","focusCell","_navigateFromCellInDirection","focus","findAncestor","isCollapsed","isBackward","containsEntireContent","schema","isObject","_isSelectionAtCellEdge","getLastPosition","getFirstPosition","getLimitElement","boundaryPosition","createPositionAt","isTouching","probe","createSelection","modifySelection","isEqual","tableMap","includeAllSlots","row","lastRow","column","lastColumn","currentCellInfo","find","cell","cellWidth","cellHeight","isOutsideVertically","isBeforeFirstCell","isAfterLastCell","cellToSelect","cellInfo","tableSelection","isEnabled","anchorCell","getAnchorCell","setCellSelection","positionToSelect"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablekeyboard\n */\n\nimport TableSelection from './tableselection';\nimport TableWalker from './tablewalker';\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { getLocalizedArrowKeyCodeDirection } from 'ckeditor5/src/utils';\nimport { getSelectedTableCells, getTableCellsContainingSelection } from './utils/selection';\n\n/**\n * This plugin enables keyboard navigation for tables.\n * It is loaded automatically by the {@link module:table/table~Table} plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableKeyboard extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableKeyboard';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ TableSelection ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst view = this.editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t// Handle Tab key navigation.\n\t\tthis.editor.keystrokes.set( 'Tab', ( ...args ) => this._handleTabOnSelectedTable( ...args ), { priority: 'low' } );\n\t\tthis.editor.keystrokes.set( 'Tab', this._getTabHandler( true ), { priority: 'low' } );\n\t\tthis.editor.keystrokes.set( 'Shift+Tab', this._getTabHandler( false ), { priority: 'low' } );\n\n\t\tthis.listenTo( viewDocument, 'arrowKey', ( ...args ) => this._onArrowKey( ...args ), { context: 'table' } );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n\t * when the table widget is selected.\n\t *\n\t * @private\n\t * @param {module:engine/view/observer/keyobserver~KeyEventData} data Key event data.\n\t * @param {Function} cancel The stop/stopPropagation/preventDefault function.\n\t */\n\t_handleTabOnSelectedTable( data, cancel ) {\n\t\tconst editor = this.editor;\n\t\tconst selection = editor.model.document.selection;\n\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\tif ( !selectedElement || !selectedElement.is( 'element', 'table' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcancel();\n\n\t\teditor.model.change( writer => {\n\t\t\twriter.setSelection( writer.createRangeIn( selectedElement.getChild( 0 ).getChild( 0 ) ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns a handler for {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed\n\t * inside table cells.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Whether this handler will move the selection to the next or the previous cell.\n\t */\n\t_getTabHandler( isForward ) {\n\t\tconst editor = this.editor;\n\n\t\treturn ( domEventData, cancel ) => {\n\t\t\tconst selection = editor.model.document.selection;\n\t\t\tlet tableCell = getTableCellsContainingSelection( selection )[ 0 ];\n\n\t\t\tif ( !tableCell ) {\n\t\t\t\ttableCell = this.editor.plugins.get( 'TableSelection' ).getFocusCell();\n\t\t\t}\n\n\t\t\tif ( !tableCell ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcancel();\n\n\t\t\tconst tableRow = tableCell.parent;\n\t\t\tconst table = tableRow.parent;\n\n\t\t\tconst currentRowIndex = table.getChildIndex( tableRow );\n\t\t\tconst currentCellIndex = tableRow.getChildIndex( tableCell );\n\n\t\t\tconst isFirstCellInRow = currentCellIndex === 0;\n\n\t\t\tif ( !isForward && isFirstCellInRow && currentRowIndex === 0 ) {\n\t\t\t\t// Set the selection over the whole table if the selection was in the first table cell.\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.setSelection( writer.createRangeOn( table ) );\n\t\t\t\t} );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\t\t\tconst isLastCellInRow = currentCellIndex === tableRow.childCount - 1;\n\t\t\tconst isLastRow = currentRowIndex === tableUtils.getRows( table ) - 1;\n\n\t\t\tif ( isForward && isLastRow && isLastCellInRow ) {\n\t\t\t\teditor.execute( 'insertTableRowBelow' );\n\n\t\t\t\t// Check if the command actually added a row. If `insertTableRowBelow` execution didn't add a row (because it was disabled\n\t\t\t\t// or it got overwritten) set the selection over the whole table to mirror the first cell case.\n\t\t\t\tif ( currentRowIndex === tableUtils.getRows( table ) - 1 ) {\n\t\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\t\twriter.setSelection( writer.createRangeOn( table ) );\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet cellToFocus;\n\n\t\t\t// Move to the first cell in the next row.\n\t\t\tif ( isForward && isLastCellInRow ) {\n\t\t\t\tconst nextRow = table.getChild( currentRowIndex + 1 );\n\n\t\t\t\tcellToFocus = nextRow.getChild( 0 );\n\t\t\t}\n\t\t\t// Move to the last cell in the previous row.\n\t\t\telse if ( !isForward && isFirstCellInRow ) {\n\t\t\t\tconst previousRow = table.getChild( currentRowIndex - 1 );\n\n\t\t\t\tcellToFocus = previousRow.getChild( previousRow.childCount - 1 );\n\t\t\t}\n\t\t\t// Move to the next/previous cell.\n\t\t\telse {\n\t\t\t\tcellToFocus = tableRow.getChild( currentCellIndex + ( isForward ? 1 : -1 ) );\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.setSelection( writer.createRangeIn( cellToFocus ) );\n\t\t\t} );\n\t\t};\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onArrowKey( eventInfo, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst keyCode = domEventData.keyCode;\n\n\t\tconst direction = getLocalizedArrowKeyCodeDirection( keyCode, editor.locale.contentLanguageDirection );\n\t\tconst wasHandled = this._handleArrowKeys( direction, domEventData.shiftKey );\n\n\t\tif ( wasHandled ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\tdomEventData.stopPropagation();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles arrow keys to move the selection around the table.\n\t *\n\t * @private\n\t * @param {'left'|'up'|'right'|'down'} direction The direction of the arrow key.\n\t * @param {Boolean} expandSelection If the current selection should be expanded.\n\t * @returns {Boolean} Returns `true` if key was handled.\n\t */\n\t_handleArrowKeys( direction, expandSelection ) {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\t\tconst isForward = [ 'right', 'down' ].includes( direction );\n\n\t\t// In case one or more table cells are selected (from outside),\n\t\t// move the selection to a cell adjacent to the selected table fragment.\n\t\tconst selectedCells = getSelectedTableCells( selection );\n\n\t\tif ( selectedCells.length ) {\n\t\t\tlet focusCell;\n\n\t\t\tif ( expandSelection ) {\n\t\t\t\tfocusCell = this.editor.plugins.get( 'TableSelection' ).getFocusCell();\n\t\t\t} else {\n\t\t\t\tfocusCell = isForward ? selectedCells[ selectedCells.length - 1 ] : selectedCells[ 0 ];\n\t\t\t}\n\n\t\t\tthis._navigateFromCellInDirection( focusCell, direction, expandSelection );\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Abort if we're not in a table cell.\n\t\tconst tableCell = selection.focus.findAncestor( 'tableCell' );\n\n\t\t/* istanbul ignore if: paranoid check */\n\t\tif ( !tableCell ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// When the selection is not collapsed.\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tif ( expandSelection ) {\n\t\t\t\t// Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n\t\t\t\t// Selection for sure will not approach cell edge.\n\t\t\t\t//\n\t\t\t\t// With a special case when all cell content is selected - then selection should expand to the other cell.\n\t\t\t\t// Note: When the entire cell gets selected using CTRL+A, the selection is always forward.\n\t\t\t\tif ( selection.isBackward == isForward && !selection.containsEntireContent( tableCell ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst selectedElement = selection.getSelectedElement();\n\n\t\t\t\t// It will collapse for non-object selected so it's not going to move to other cell.\n\t\t\t\tif ( !selectedElement || !model.schema.isObject( selectedElement ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Let's check if the selection is at the beginning/end of the cell.\n\t\tif ( this._isSelectionAtCellEdge( selection, tableCell, isForward ) ) {\n\t\t\tthis._navigateFromCellInDirection( tableCell, direction, expandSelection );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection The current selection.\n\t * @param {module:engine/model/element~Element} tableCell The current table cell element.\n\t * @param {Boolean} isForward The expected navigation direction.\n\t * @returns {Boolean}\n\t */\n\t_isSelectionAtCellEdge( selection, tableCell, isForward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = this.editor.model.schema;\n\n\t\tconst focus = isForward ? selection.getLastPosition() : selection.getFirstPosition();\n\n\t\t// If the current limit element is not table cell we are for sure not at the cell edge.\n\t\t// Also `modifySelection` will not let us out of it.\n\t\tif ( !schema.getLimitElement( focus ).is( 'element', 'tableCell' ) ) {\n\t\t\tconst boundaryPosition = model.createPositionAt( tableCell, isForward ? 'end' : 0 );\n\n\t\t\treturn boundaryPosition.isTouching( focus );\n\t\t}\n\n\t\tconst probe = model.createSelection( focus );\n\n\t\tmodel.modifySelection( probe, { direction: isForward ? 'forward' : 'backward' } );\n\n\t\t// If there was no change in the focus position, then it's not possible to move the selection there.\n\t\treturn focus.isEqual( probe.focus );\n\t}\n\n\t/**\n\t * Moves the selection from the given table cell in the specified direction.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} focusCell The table cell that is current multi-cell selection focus.\n\t * @param {'left'|'up'|'right'|'down'} direction Direction in which selection should move.\n\t * @param {Boolean} [expandSelection=false] If the current selection should be expanded.\n\t */\n\t_navigateFromCellInDirection( focusCell, direction, expandSelection = false ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst table = focusCell.findAncestor( 'table' );\n\t\tconst tableMap = [ ...new TableWalker( table, { includeAllSlots: true } ) ];\n\t\tconst { row: lastRow, column: lastColumn } = tableMap[ tableMap.length - 1 ];\n\n\t\tconst currentCellInfo = tableMap.find( ( { cell } ) => cell == focusCell );\n\t\tlet { row, column } = currentCellInfo;\n\n\t\tswitch ( direction ) {\n\t\t\tcase 'left':\n\t\t\t\tcolumn--;\n\t\t\t\tbreak;\n\n\t\t\tcase 'up':\n\t\t\t\trow--;\n\t\t\t\tbreak;\n\n\t\t\tcase 'right':\n\t\t\t\tcolumn += currentCellInfo.cellWidth;\n\t\t\t\tbreak;\n\n\t\t\tcase 'down':\n\t\t\t\trow += currentCellInfo.cellHeight;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst isOutsideVertically = row < 0 || row > lastRow;\n\t\tconst isBeforeFirstCell = column < 0 && row <= 0;\n\t\tconst isAfterLastCell = column > lastColumn && row >= lastRow;\n\n\t\t// Note that if the table cell at the end of a row is row-spanned then isAfterLastCell will never be true.\n\t\t// However, we don't know if user was navigating on the last row or not, so let's stay in the table.\n\n\t\tif ( isOutsideVertically || isBeforeFirstCell || isAfterLastCell ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( writer.createRangeOn( table ) );\n\t\t\t} );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( column < 0 ) {\n\t\t\tcolumn = expandSelection ? 0 : lastColumn;\n\t\t\trow--;\n\t\t} else if ( column > lastColumn ) {\n\t\t\tcolumn = expandSelection ? lastColumn : 0;\n\t\t\trow++;\n\t\t}\n\n\t\tconst cellToSelect = tableMap.find( cellInfo => cellInfo.row == row && cellInfo.column == column ).cell;\n\t\tconst isForward = [ 'right', 'down' ].includes( direction );\n\t\tconst tableSelection = this.editor.plugins.get( 'TableSelection' );\n\n\t\tif ( expandSelection && tableSelection.isEnabled ) {\n\t\t\tconst anchorCell = tableSelection.getAnchorCell() || focusCell;\n\n\t\t\ttableSelection.setCellSelection( anchorCell, cellToSelect );\n\t\t} else {\n\t\t\tconst positionToSelect = model.createPositionAt( cellToSelect, isForward ? 0 : 'end' );\n\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( positionToSelect );\n\t\t\t} );\n\t\t}\n\t}\n}\n\n"]},"metadata":{},"sourceType":"module"}
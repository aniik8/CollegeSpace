{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-cell-refresh-post-fixer\n */\nimport { isSingleParagraphWithoutAttributes } from './downcast';\n/**\n * Injects a table cell post-fixer into the model which marks the table cell in the differ to have it re-rendered.\n *\n * Model `paragraph` inside a table cell can be rendered as `<span>` or `<p>`. It is rendered as `<span>` if this is the only block\n * element in that table cell and it does not have any attributes. It is rendered as `<p>` otherwise.\n *\n * When table cell content changes, for example a second `paragraph` element is added, we need to ensure that the first `paragraph` is\n * re-rendered so it changes from `<span>` to `<p>`. The easiest way to do it is to re-render the entire table cell.\n *\n * @param {module:engine/model/model~Model} model\n * @param {module:engine/conversion/mapper~Mapper} mapper\n */\n\nexport default function injectTableCellRefreshPostFixer(model, mapper) {\n  model.document.registerPostFixer(() => tableCellRefreshPostFixer(model.document.differ, mapper));\n}\n\nfunction tableCellRefreshPostFixer(differ, mapper) {\n  // Stores cells to be refreshed, so the table cell will be refreshed once for multiple changes.\n  // 1. Gather all changes inside table cell.\n  const cellsToCheck = new Set();\n\n  for (const change of differ.getChanges()) {\n    const parent = change.type == 'attribute' ? change.range.start.parent : change.position.parent;\n\n    if (parent.is('element', 'tableCell')) {\n      cellsToCheck.add(parent);\n    }\n  } // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: Checking table cell to refresh (${ cellsToCheck.size }).` );\n  // @if CK_DEBUG_TABLE // let paragraphsRefreshed = 0;\n\n\n  for (const tableCell of cellsToCheck.values()) {\n    for (const paragraph of [...tableCell.getChildren()].filter(child => shouldRefresh(child, mapper))) {\n      // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: refreshing paragraph in table cell (${++paragraphsRefreshed}).` );\n      differ.refreshItem(paragraph);\n    }\n  } // Always return false to prevent the refresh post-fixer from re-running on the same set of changes and going into an infinite loop.\n  // This \"post-fixer\" does not change the model structure so there shouldn't be need to run other post-fixers again.\n  // See https://github.com/ckeditor/ckeditor5/issues/1936 & https://github.com/ckeditor/ckeditor5/issues/8200.\n\n\n  return false;\n} // Check if given model element needs refreshing.\n//\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\n\nfunction shouldRefresh(child, mapper) {\n  if (!child.is('element', 'paragraph')) {\n    return false;\n  }\n\n  const viewElement = mapper.toViewElement(child);\n\n  if (!viewElement) {\n    return false;\n  }\n\n  return isSingleParagraphWithoutAttributes(child) !== viewElement.is('element', 'span');\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-refresh-post-fixer.js"],"names":["isSingleParagraphWithoutAttributes","injectTableCellRefreshPostFixer","model","mapper","document","registerPostFixer","tableCellRefreshPostFixer","differ","cellsToCheck","Set","change","getChanges","parent","type","range","start","position","is","add","tableCell","values","paragraph","getChildren","filter","child","shouldRefresh","refreshItem","viewElement","toViewElement"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,kCAAT,QAAmD,YAAnD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,+BAAT,CAA0CC,KAA1C,EAAiDC,MAAjD,EAA0D;AACxED,EAAAA,KAAK,CAACE,QAAN,CAAeC,iBAAf,CAAkC,MAAMC,yBAAyB,CAAEJ,KAAK,CAACE,QAAN,CAAeG,MAAjB,EAAyBJ,MAAzB,CAAjE;AACA;;AAED,SAASG,yBAAT,CAAoCC,MAApC,EAA4CJ,MAA5C,EAAqD;AACpD;AAEA;AACA,QAAMK,YAAY,GAAG,IAAIC,GAAJ,EAArB;;AAEA,OAAM,MAAMC,MAAZ,IAAsBH,MAAM,CAACI,UAAP,EAAtB,EAA4C;AAC3C,UAAMC,MAAM,GAAGF,MAAM,CAACG,IAAP,IAAe,WAAf,GAA6BH,MAAM,CAACI,KAAP,CAAaC,KAAb,CAAmBH,MAAhD,GAAyDF,MAAM,CAACM,QAAP,CAAgBJ,MAAxF;;AAEA,QAAKA,MAAM,CAACK,EAAP,CAAW,SAAX,EAAsB,WAAtB,CAAL,EAA2C;AAC1CT,MAAAA,YAAY,CAACU,GAAb,CAAkBN,MAAlB;AACA;AACD,GAZmD,CAcpD;AACA;;;AAEA,OAAM,MAAMO,SAAZ,IAAyBX,YAAY,CAACY,MAAb,EAAzB,EAAiD;AAChD,SAAM,MAAMC,SAAZ,IAAyB,CAAE,GAAGF,SAAS,CAACG,WAAV,EAAL,EAA+BC,MAA/B,CAAuCC,KAAK,IAAIC,aAAa,CAAED,KAAF,EAASrB,MAAT,CAA7D,CAAzB,EAA4G;AAC3G;AACAI,MAAAA,MAAM,CAACmB,WAAP,CAAoBL,SAApB;AACA;AACD,GAtBmD,CAwBpD;AACA;AACA;;;AACA,SAAO,KAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAwBD,KAAxB,EAA+BrB,MAA/B,EAAwC;AACvC,MAAK,CAACqB,KAAK,CAACP,EAAN,CAAU,SAAV,EAAqB,WAArB,CAAN,EAA2C;AAC1C,WAAO,KAAP;AACA;;AAED,QAAMU,WAAW,GAAGxB,MAAM,CAACyB,aAAP,CAAsBJ,KAAtB,CAApB;;AAEA,MAAK,CAACG,WAAN,EAAoB;AACnB,WAAO,KAAP;AACA;;AAED,SAAO3B,kCAAkC,CAAEwB,KAAF,CAAlC,KAAgDG,WAAW,CAACV,EAAZ,CAAgB,SAAhB,EAA2B,MAA3B,CAAvD;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-cell-refresh-post-fixer\n */\n\nimport { isSingleParagraphWithoutAttributes } from './downcast';\n\n/**\n * Injects a table cell post-fixer into the model which marks the table cell in the differ to have it re-rendered.\n *\n * Model `paragraph` inside a table cell can be rendered as `<span>` or `<p>`. It is rendered as `<span>` if this is the only block\n * element in that table cell and it does not have any attributes. It is rendered as `<p>` otherwise.\n *\n * When table cell content changes, for example a second `paragraph` element is added, we need to ensure that the first `paragraph` is\n * re-rendered so it changes from `<span>` to `<p>`. The easiest way to do it is to re-render the entire table cell.\n *\n * @param {module:engine/model/model~Model} model\n * @param {module:engine/conversion/mapper~Mapper} mapper\n */\nexport default function injectTableCellRefreshPostFixer( model, mapper ) {\n\tmodel.document.registerPostFixer( () => tableCellRefreshPostFixer( model.document.differ, mapper ) );\n}\n\nfunction tableCellRefreshPostFixer( differ, mapper ) {\n\t// Stores cells to be refreshed, so the table cell will be refreshed once for multiple changes.\n\n\t// 1. Gather all changes inside table cell.\n\tconst cellsToCheck = new Set();\n\n\tfor ( const change of differ.getChanges() ) {\n\t\tconst parent = change.type == 'attribute' ? change.range.start.parent : change.position.parent;\n\n\t\tif ( parent.is( 'element', 'tableCell' ) ) {\n\t\t\tcellsToCheck.add( parent );\n\t\t}\n\t}\n\n\t// @if CK_DEBUG_TABLE // console.log( `Post-fixing table: Checking table cell to refresh (${ cellsToCheck.size }).` );\n\t// @if CK_DEBUG_TABLE // let paragraphsRefreshed = 0;\n\n\tfor ( const tableCell of cellsToCheck.values() ) {\n\t\tfor ( const paragraph of [ ...tableCell.getChildren() ].filter( child => shouldRefresh( child, mapper ) ) ) {\n\t\t\t// @if CK_DEBUG_TABLE // console.log( `Post-fixing table: refreshing paragraph in table cell (${++paragraphsRefreshed}).` );\n\t\t\tdiffer.refreshItem( paragraph );\n\t\t}\n\t}\n\n\t// Always return false to prevent the refresh post-fixer from re-running on the same set of changes and going into an infinite loop.\n\t// This \"post-fixer\" does not change the model structure so there shouldn't be need to run other post-fixers again.\n\t// See https://github.com/ckeditor/ckeditor5/issues/1936 & https://github.com/ckeditor/ckeditor5/issues/8200.\n\treturn false;\n}\n\n// Check if given model element needs refreshing.\n//\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldRefresh( child, mapper ) {\n\tif ( !child.is( 'element', 'paragraph' ) ) {\n\t\treturn false;\n\t}\n\n\tconst viewElement = mapper.toViewElement( child );\n\n\tif ( !viewElement ) {\n\t\treturn false;\n\t}\n\n\treturn isSingleParagraphWithoutAttributes( child ) !== viewElement.is( 'element', 'span' );\n}\n"]},"metadata":{},"sourceType":"module"}
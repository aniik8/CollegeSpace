{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/upcasttable\n */\nimport { createEmptyTableCell } from '../utils/common';\nimport { first } from 'ckeditor5/src/utils';\n/**\n * Returns a function that converts the table view representation:\n *\n *\t\t<figure class=\"table\"><table>...</table></figure>\n *\n * to the model representation:\n *\n *\t\t<table></table>\n *\n * @returns {Function}\n */\n\nexport function upcastTableFigure() {\n  return dispatcher => {\n    dispatcher.on('element:figure', (evt, data, conversionApi) => {\n      // Do not convert if this is not a \"table figure\".\n      if (!conversionApi.consumable.test(data.viewItem, {\n        name: true,\n        classes: 'table'\n      })) {\n        return;\n      } // Find an table element inside the figure element.\n\n\n      const viewTable = getViewTableFromFigure(data.viewItem); // Do not convert if table element is absent or was already converted.\n\n      if (!viewTable || !conversionApi.consumable.test(viewTable, {\n        name: true\n      })) {\n        return;\n      } // Consume the figure to prevent other converters from processing it again.\n\n\n      conversionApi.consumable.consume(data.viewItem, {\n        name: true,\n        classes: 'table'\n      }); // Convert view table to model table.\n\n      const conversionResult = conversionApi.convertItem(viewTable, data.modelCursor); // Get table element from conversion result.\n\n      const modelTable = first(conversionResult.modelRange.getItems()); // When table wasn't successfully converted then finish conversion.\n\n      if (!modelTable) {\n        // Revert consumed figure so other features can convert it.\n        conversionApi.consumable.revert(data.viewItem, {\n          name: true,\n          classes: 'table'\n        });\n        return;\n      }\n\n      conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelTable, 'end'));\n      conversionApi.updateConversionResult(modelTable, data);\n    });\n  };\n}\n/**\n * View table element to model table element conversion helper.\n *\n * This conversion helper converts the table element as well as table rows.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport default function upcastTable() {\n  return dispatcher => {\n    dispatcher.on('element:table', (evt, data, conversionApi) => {\n      const viewTable = data.viewItem; // When element was already consumed then skip it.\n\n      if (!conversionApi.consumable.test(viewTable, {\n        name: true\n      })) {\n        return;\n      }\n\n      const {\n        rows,\n        headingRows,\n        headingColumns\n      } = scanTable(viewTable); // Only set attributes if values is greater then 0.\n\n      const attributes = {};\n\n      if (headingColumns) {\n        attributes.headingColumns = headingColumns;\n      }\n\n      if (headingRows) {\n        attributes.headingRows = headingRows;\n      }\n\n      const table = conversionApi.writer.createElement('table', attributes);\n\n      if (!conversionApi.safeInsert(table, data.modelCursor)) {\n        return;\n      }\n\n      conversionApi.consumable.consume(viewTable, {\n        name: true\n      }); // Upcast table rows in proper order (heading rows first).\n\n      rows.forEach(row => conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, 'end'))); // Convert everything else.\n\n      conversionApi.convertChildren(viewTable, conversionApi.writer.createPositionAt(table, 'end')); // Create one row and one table cell for empty table.\n\n      if (table.isEmpty) {\n        const row = conversionApi.writer.createElement('tableRow');\n        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, 'end'));\n        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, 'end'));\n      }\n\n      conversionApi.updateConversionResult(table, data);\n    });\n  };\n}\n/**\n * A conversion helper that skips empty <tr> elements from upcasting at the beginning of the table.\n *\n * An empty row is considered a table model error but when handling clipboard data there could be rows that contain only row-spanned cells\n * and empty TR-s are used to maintain the table structure (also {@link module:table/tablewalker~TableWalker} assumes that there are only\n * rows that have related `tableRow` elements).\n *\n * *Note:* Only the first empty rows are removed because they have no meaning and it solves the issue\n * of an improper table with all empty rows.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function skipEmptyTableRow() {\n  return dispatcher => {\n    dispatcher.on('element:tr', (evt, data) => {\n      if (data.viewItem.isEmpty && data.modelCursor.index == 0) {\n        evt.stop();\n      }\n    }, {\n      priority: 'high'\n    });\n  };\n}\n/**\n * A converter that ensures an empty paragraph is inserted in a table cell if no other content was converted.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function ensureParagraphInTableCell(elementName) {\n  return dispatcher => {\n    dispatcher.on(`element:${elementName}`, (evt, data, conversionApi) => {\n      // The default converter will create a model range on converted table cell.\n      if (!data.modelRange) {\n        return;\n      } // Ensure a paragraph in the model for empty table cells for converted table cells.\n\n\n      if (data.viewItem.isEmpty) {\n        const tableCell = data.modelRange.start.nodeAfter;\n        const modelCursor = conversionApi.writer.createPositionAt(tableCell, 0);\n        conversionApi.writer.insertElement('paragraph', modelCursor);\n      }\n    }, {\n      priority: 'low'\n    });\n  };\n} // Get view `<table>` element from the view widget (`<figure>`).\n//\n// @private\n// @param {module:engine/view/element~Element} figureView\n// @returns {module:engine/view/element~Element}\n\nfunction getViewTableFromFigure(figureView) {\n  for (const figureChild of figureView.getChildren()) {\n    if (figureChild.is('element', 'table')) {\n      return figureChild;\n    }\n  }\n} // Scans table rows and extracts required metadata from the table:\n//\n// headingRows    - The number of rows that go as table headers.\n// headingColumns - The maximum number of row headings.\n// rows           - Sorted `<tr>` elements as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.\n//\n// @private\n// @param {module:engine/view/element~Element} viewTable\n// @returns {{headingRows, headingColumns, rows}}\n\n\nfunction scanTable(viewTable) {\n  const tableMeta = {\n    headingRows: 0,\n    headingColumns: 0\n  }; // The `<tbody>` and `<thead>` sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more than one\n  // of them.\n  // As the model does not have these sections, rows from different sections must be sorted.\n  // For example, below is a valid HTML table:\n  //\n  //\t\t<table>\n  //\t\t\t<tbody><tr><td>2</td></tr></tbody>\n  //\t\t\t<thead><tr><td>1</td></tr></thead>\n  //\t\t\t<tbody><tr><td>3</td></tr></tbody>\n  //\t\t</table>\n  //\n  // But browsers will render rows in order as: 1 as the heading and 2 and 3 as the body.\n\n  const headRows = [];\n  const bodyRows = []; // Currently the editor does not support more then one <thead> section.\n  // Only the first <thead> from the view will be used as a heading row and the others will be converted to body rows.\n\n  let firstTheadElement;\n\n  for (const tableChild of Array.from(viewTable.getChildren())) {\n    // Only `<thead>`, `<tbody>` & `<tfoot>` from allowed table children can have `<tr>`s.\n    // The else is for future purposes (mainly `<caption>`).\n    if (tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot') {\n      // Save the first `<thead>` in the table as table header - all other ones will be converted to table body rows.\n      if (tableChild.name === 'thead' && !firstTheadElement) {\n        firstTheadElement = tableChild;\n      } // There might be some extra empty text nodes between the `<tr>`s.\n      // Make sure further code operates on `tr`s only. (#145)\n\n\n      const trs = Array.from(tableChild.getChildren()).filter(el => el.is('element', 'tr'));\n\n      for (const tr of trs) {\n        // This <tr> is a child of a first <thead> element.\n        if (tr.parent.name === 'thead' && tr.parent === firstTheadElement) {\n          tableMeta.headingRows++;\n          headRows.push(tr);\n        } else {\n          bodyRows.push(tr); // For other rows check how many column headings this row has.\n\n          const headingCols = scanRowForHeadingColumns(tr, tableMeta, firstTheadElement);\n\n          if (headingCols > tableMeta.headingColumns) {\n            tableMeta.headingColumns = headingCols;\n          }\n        }\n      }\n    }\n  }\n\n  tableMeta.rows = [...headRows, ...bodyRows];\n  return tableMeta;\n} // Scans a `<tr>` element and its children for metadata:\n// - For heading row:\n//     - Adds this row to either the heading or the body rows.\n//     - Updates the number of heading rows.\n// - For body rows:\n//     - Calculates the number of column headings.\n//\n// @private\n// @param {module:engine/view/element~Element} tr\n// @returns {Number}\n\n\nfunction scanRowForHeadingColumns(tr) {\n  let headingColumns = 0;\n  let index = 0; // Filter out empty text nodes from tr children.\n\n  const children = Array.from(tr.getChildren()).filter(child => child.name === 'th' || child.name === 'td'); // Count starting adjacent <th> elements of a <tr>.\n\n  while (index < children.length && children[index].name === 'th') {\n    const th = children[index]; // Adjust columns calculation by the number of spanned columns.\n\n    const colspan = parseInt(th.getAttribute('colspan') || 1);\n    headingColumns = headingColumns + colspan;\n    index++;\n  }\n\n  return headingColumns;\n}","map":{"version":3,"sources":["/Users/jaibhole/Documents/CS/cs-front/node_modules/@ckeditor/ckeditor5-table/src/converters/upcasttable.js"],"names":["createEmptyTableCell","first","upcastTableFigure","dispatcher","on","evt","data","conversionApi","consumable","test","viewItem","name","classes","viewTable","getViewTableFromFigure","consume","conversionResult","convertItem","modelCursor","modelTable","modelRange","getItems","revert","convertChildren","writer","createPositionAt","updateConversionResult","upcastTable","rows","headingRows","headingColumns","scanTable","attributes","table","createElement","safeInsert","forEach","row","isEmpty","insert","skipEmptyTableRow","index","stop","priority","ensureParagraphInTableCell","elementName","tableCell","start","nodeAfter","insertElement","figureView","figureChild","getChildren","is","tableMeta","headRows","bodyRows","firstTheadElement","tableChild","Array","from","trs","filter","el","tr","parent","push","headingCols","scanRowForHeadingColumns","children","child","length","th","colspan","parseInt","getAttribute"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/upcasttable\n */\n\nimport { createEmptyTableCell } from '../utils/common';\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * Returns a function that converts the table view representation:\n *\n *\t\t<figure class=\"table\"><table>...</table></figure>\n *\n * to the model representation:\n *\n *\t\t<table></table>\n *\n * @returns {Function}\n */\nexport function upcastTableFigure() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:figure', ( evt, data, conversionApi ) => {\n\t\t\t// Do not convert if this is not a \"table figure\".\n\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: true, classes: 'table' } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find an table element inside the figure element.\n\t\t\tconst viewTable = getViewTableFromFigure( data.viewItem );\n\n\t\t\t// Do not convert if table element is absent or was already converted.\n\t\t\tif ( !viewTable || !conversionApi.consumable.test( viewTable, { name: true } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Consume the figure to prevent other converters from processing it again.\n\t\t\tconversionApi.consumable.consume( data.viewItem, { name: true, classes: 'table' } );\n\n\t\t\t// Convert view table to model table.\n\t\t\tconst conversionResult = conversionApi.convertItem( viewTable, data.modelCursor );\n\n\t\t\t// Get table element from conversion result.\n\t\t\tconst modelTable = first( conversionResult.modelRange.getItems() );\n\n\t\t\t// When table wasn't successfully converted then finish conversion.\n\t\t\tif ( !modelTable ) {\n\t\t\t\t// Revert consumed figure so other features can convert it.\n\t\t\t\tconversionApi.consumable.revert( data.viewItem, { name: true, classes: 'table' } );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconversionApi.convertChildren( data.viewItem, conversionApi.writer.createPositionAt( modelTable, 'end' ) );\n\t\t\tconversionApi.updateConversionResult( modelTable, data );\n\t\t} );\n\t};\n}\n\n/**\n * View table element to model table element conversion helper.\n *\n * This conversion helper converts the table element as well as table rows.\n *\n * @returns {Function} Conversion helper.\n */\nexport default function upcastTable() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:table', ( evt, data, conversionApi ) => {\n\t\t\tconst viewTable = data.viewItem;\n\n\t\t\t// When element was already consumed then skip it.\n\t\t\tif ( !conversionApi.consumable.test( viewTable, { name: true } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { rows, headingRows, headingColumns } = scanTable( viewTable );\n\n\t\t\t// Only set attributes if values is greater then 0.\n\t\t\tconst attributes = {};\n\n\t\t\tif ( headingColumns ) {\n\t\t\t\tattributes.headingColumns = headingColumns;\n\t\t\t}\n\n\t\t\tif ( headingRows ) {\n\t\t\t\tattributes.headingRows = headingRows;\n\t\t\t}\n\n\t\t\tconst table = conversionApi.writer.createElement( 'table', attributes );\n\n\t\t\tif ( !conversionApi.safeInsert( table, data.modelCursor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconversionApi.consumable.consume( viewTable, { name: true } );\n\n\t\t\t// Upcast table rows in proper order (heading rows first).\n\t\t\trows.forEach( row => conversionApi.convertItem( row, conversionApi.writer.createPositionAt( table, 'end' ) ) );\n\n\t\t\t// Convert everything else.\n\t\t\tconversionApi.convertChildren( viewTable, conversionApi.writer.createPositionAt( table, 'end' ) );\n\n\t\t\t// Create one row and one table cell for empty table.\n\t\t\tif ( table.isEmpty ) {\n\t\t\t\tconst row = conversionApi.writer.createElement( 'tableRow' );\n\t\t\t\tconversionApi.writer.insert( row, conversionApi.writer.createPositionAt( table, 'end' ) );\n\n\t\t\t\tcreateEmptyTableCell( conversionApi.writer, conversionApi.writer.createPositionAt( row, 'end' ) );\n\t\t\t}\n\n\t\t\tconversionApi.updateConversionResult( table, data );\n\t\t} );\n\t};\n}\n\n/**\n * A conversion helper that skips empty <tr> elements from upcasting at the beginning of the table.\n *\n * An empty row is considered a table model error but when handling clipboard data there could be rows that contain only row-spanned cells\n * and empty TR-s are used to maintain the table structure (also {@link module:table/tablewalker~TableWalker} assumes that there are only\n * rows that have related `tableRow` elements).\n *\n * *Note:* Only the first empty rows are removed because they have no meaning and it solves the issue\n * of an improper table with all empty rows.\n *\n * @returns {Function} Conversion helper.\n */\nexport function skipEmptyTableRow() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:tr', ( evt, data ) => {\n\t\t\tif ( data.viewItem.isEmpty && data.modelCursor.index == 0 ) {\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t};\n}\n\n/**\n * A converter that ensures an empty paragraph is inserted in a table cell if no other content was converted.\n *\n * @returns {Function} Conversion helper.\n */\nexport function ensureParagraphInTableCell( elementName ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `element:${ elementName }`, ( evt, data, conversionApi ) => {\n\t\t\t// The default converter will create a model range on converted table cell.\n\t\t\tif ( !data.modelRange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ensure a paragraph in the model for empty table cells for converted table cells.\n\t\t\tif ( data.viewItem.isEmpty ) {\n\t\t\t\tconst tableCell = data.modelRange.start.nodeAfter;\n\t\t\t\tconst modelCursor = conversionApi.writer.createPositionAt( tableCell, 0 );\n\n\t\t\t\tconversionApi.writer.insertElement( 'paragraph', modelCursor );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t};\n}\n\n// Get view `<table>` element from the view widget (`<figure>`).\n//\n// @private\n// @param {module:engine/view/element~Element} figureView\n// @returns {module:engine/view/element~Element}\nfunction getViewTableFromFigure( figureView ) {\n\tfor ( const figureChild of figureView.getChildren() ) {\n\t\tif ( figureChild.is( 'element', 'table' ) ) {\n\t\t\treturn figureChild;\n\t\t}\n\t}\n}\n\n// Scans table rows and extracts required metadata from the table:\n//\n// headingRows    - The number of rows that go as table headers.\n// headingColumns - The maximum number of row headings.\n// rows           - Sorted `<tr>` elements as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.\n//\n// @private\n// @param {module:engine/view/element~Element} viewTable\n// @returns {{headingRows, headingColumns, rows}}\nfunction scanTable( viewTable ) {\n\tconst tableMeta = {\n\t\theadingRows: 0,\n\t\theadingColumns: 0\n\t};\n\n\t// The `<tbody>` and `<thead>` sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more than one\n\t// of them.\n\t// As the model does not have these sections, rows from different sections must be sorted.\n\t// For example, below is a valid HTML table:\n\t//\n\t//\t\t<table>\n\t//\t\t\t<tbody><tr><td>2</td></tr></tbody>\n\t//\t\t\t<thead><tr><td>1</td></tr></thead>\n\t//\t\t\t<tbody><tr><td>3</td></tr></tbody>\n\t//\t\t</table>\n\t//\n\t// But browsers will render rows in order as: 1 as the heading and 2 and 3 as the body.\n\tconst headRows = [];\n\tconst bodyRows = [];\n\n\t// Currently the editor does not support more then one <thead> section.\n\t// Only the first <thead> from the view will be used as a heading row and the others will be converted to body rows.\n\tlet firstTheadElement;\n\n\tfor ( const tableChild of Array.from( viewTable.getChildren() ) ) {\n\t\t// Only `<thead>`, `<tbody>` & `<tfoot>` from allowed table children can have `<tr>`s.\n\t\t// The else is for future purposes (mainly `<caption>`).\n\t\tif ( tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot' ) {\n\t\t\t// Save the first `<thead>` in the table as table header - all other ones will be converted to table body rows.\n\t\t\tif ( tableChild.name === 'thead' && !firstTheadElement ) {\n\t\t\t\tfirstTheadElement = tableChild;\n\t\t\t}\n\n\t\t\t// There might be some extra empty text nodes between the `<tr>`s.\n\t\t\t// Make sure further code operates on `tr`s only. (#145)\n\t\t\tconst trs = Array.from( tableChild.getChildren() ).filter( el => el.is( 'element', 'tr' ) );\n\n\t\t\tfor ( const tr of trs ) {\n\t\t\t\t// This <tr> is a child of a first <thead> element.\n\t\t\t\tif ( tr.parent.name === 'thead' && tr.parent === firstTheadElement ) {\n\t\t\t\t\ttableMeta.headingRows++;\n\t\t\t\t\theadRows.push( tr );\n\t\t\t\t} else {\n\t\t\t\t\tbodyRows.push( tr );\n\t\t\t\t\t// For other rows check how many column headings this row has.\n\n\t\t\t\t\tconst headingCols = scanRowForHeadingColumns( tr, tableMeta, firstTheadElement );\n\n\t\t\t\t\tif ( headingCols > tableMeta.headingColumns ) {\n\t\t\t\t\t\ttableMeta.headingColumns = headingCols;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttableMeta.rows = [ ...headRows, ...bodyRows ];\n\n\treturn tableMeta;\n}\n\n// Scans a `<tr>` element and its children for metadata:\n// - For heading row:\n//     - Adds this row to either the heading or the body rows.\n//     - Updates the number of heading rows.\n// - For body rows:\n//     - Calculates the number of column headings.\n//\n// @private\n// @param {module:engine/view/element~Element} tr\n// @returns {Number}\nfunction scanRowForHeadingColumns( tr ) {\n\tlet headingColumns = 0;\n\tlet index = 0;\n\n\t// Filter out empty text nodes from tr children.\n\tconst children = Array.from( tr.getChildren() )\n\t\t.filter( child => child.name === 'th' || child.name === 'td' );\n\n\t// Count starting adjacent <th> elements of a <tr>.\n\twhile ( index < children.length && children[ index ].name === 'th' ) {\n\t\tconst th = children[ index ];\n\n\t\t// Adjust columns calculation by the number of spanned columns.\n\t\tconst colspan = parseInt( th.getAttribute( 'colspan' ) || 1 );\n\n\t\theadingColumns = headingColumns + colspan;\n\t\tindex++;\n\t}\n\n\treturn headingColumns;\n}\n"]},"metadata":{},"sourceType":"module"}